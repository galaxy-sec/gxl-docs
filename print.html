<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>galaxy-sec operator ecosystem</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mermaid.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">galaxy-sec operator ecosystem</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="galaxy-sec--operator--ecosystem"><a class="header" href="#galaxy-sec--operator--ecosystem">Galaxy-Sec  Operator  Ecosystem</a></h1>
<h2 id="包括"><a class="header" href="#包括">包括：</a></h2>
<ul>
<li>DSL语言: Gxl</li>
<li>维护器</li>
<li>命令工具
<ul>
<li>gflow :Gxl的执行器</li>
<li>gops : 维护工程</li>
<li>gsys ：系统维护器</li>
<li>gmod ：模块维护器</li>
</ul>
</li>
</ul>
<h2 id="核心流程"><a class="header" href="#核心流程">核心流程</a></h2>
<ul>
<li>1、gmod 创建模块维护器，用gxl 编写维护器的workflow</li>
<li>2、gsys 创建系统维护器，并组合多个模块维护器,用gxl 编写维护器的workflow</li>
<li>3、系统维护器 保存到配置管理库中，待发布到客户环境。</li>
<li>4、在客户环境中，使用gops 创建维护工程， 并加载系统维护器。</li>
<li>5、在客户环境中，使用gflow 执行维护器的workflow。</li>
<li>6、保存维护工程到配置管理库中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h1 id="galaxy-flow-v083--v086-发布说明"><a class="header" href="#galaxy-flow-v083--v086-发布说明">Galaxy Flow v0.8.3 → v0.8.6 发布说明</a></h1>
<h2 id="-版本信息"><a class="header" href="#-版本信息">🚀 版本信息</a></h2>
<ul>
<li>起始版本 : v0.8.3</li>
<li>目标版本 : v0.8.6</li>
<li>当前版本 : 0.8.6</li>
</ul>
<h2 id="-主要新功能"><a class="header" href="#-主要新功能">✨ 主要新功能</a></h2>
<h3 id="1-日志重定向系统重构"><a class="header" href="#1-日志重定向系统重构">1. 日志重定向系统重构</a></h3>
<ul>
<li>新增 : 使用管道(pip)进行日志重定向的全新实现</li>
<li>优化 : 改进了日志处理机制，提高了性能和稳定性</li>
<li>提交 : a5bf576 , deea236 , 2e1ce2c , be686b1 , 4e3f1a7</li>
</ul>
<h3 id="2-逻辑表达式支持"><a class="header" href="#2-逻辑表达式支持">2. 逻辑表达式支持</a></h3>
<ul>
<li>新增 : 逻辑表达式( logic_exp )功能实现</li>
<li>实现 : 完整的逻辑表达式解析和执行能力</li>
<li>提交 : d646fd4 , fc7c975</li>
</ul>
<h3 id="3-归档功能增强"><a class="header" href="#3-归档功能增强">3. 归档功能增强</a></h3>
<ul>
<li>新增 : gx.tar 和 gx.untar 命令支持</li>
<li>用途 : 提供原生的压缩和解压缩能力</li>
<li>提交 : 1755d4d</li>
</ul>
<h2 id="-改进与优化"><a class="header" href="#-改进与优化">🔧 改进与优化</a></h2>
<h3 id="代码质量"><a class="header" href="#代码质量">代码质量</a></h3>
<ul>
<li>重构 : 成功状态处理逻辑重构 ( 6dce866 )</li>
<li>优化 : 表达式逻辑更新 ( 73dcb46 )</li>
<li>清理 : 取消taskvalue中的日志信息 ( 523f85b )</li>
</ul>
<h3 id="依赖更新"><a class="header" href="#依赖更新">依赖更新</a></h3>
<ul>
<li>更新 : clap依赖升级到最新版本 ( 9246378 )</li>
<li>更新 : 多个crate依赖项更新 ( 1051001 , 352e19a )</li>
<li>维护 : 代码格式化和clippy修复 ( 08b51f2 , c57879b , b049906 )</li>
</ul>
<h2 id="-问题修复"><a class="header" href="#-问题修复">🐛 问题修复</a></h2>
<h3 id="关键修复"><a class="header" href="#关键修复">关键修复</a></h3>
<ul>
<li>修复 : 模块路径错误问题 (#61) - d099a55</li>
<li>修复 : 多个相关问题 (#62, #61) - 4419cad</li>
<li>修复 : 模块名称列表问题 - 19bfa32</li>
</ul>
<h3 id="其他修复"><a class="header" href="#其他修复">其他修复</a></h3>
<ul>
<li>修复 : 通道与启用状态的关联问题 - 5592286</li>
<li>修复 : 干运行参数传递给子gxl的问题 - 4644a1b</li>
</ul>
<h2 id="-其他变更"><a class="header" href="#-其他变更">📋 其他变更</a></h2>
<h3 id="构建和部署"><a class="header" href="#构建和部署">构建和部署</a></h3>
<ul>
<li>更新 : artifact构建更新 ( 9c1193d )</li>
<li>更新 : 管理配置更新 ( 3dcc127 )</li>
<li>维护 : 版本号更新到0.8.6 ( 2f4acfe , 5b4dbb0 )</li>
</ul>
<h3 id="内部改进"><a class="header" href="#内部改进">内部改进</a></h3>
<ul>
<li>重构 : 使用常量字符串优化 ( 64e7d30 , daf17ef )</li>
<li>新增 : 读取文件日志功能 ( 142b448 )</li>
</ul>
<h2 id="-升级建议"><a class="header" href="#-升级建议">📝 升级建议</a></h2>
<ol>
<li>
<ol>
<li></li>
</ol>
平滑升级 : 从v0.8.3升级到v0.8.6是向后兼容的</li>
<li>
<ol start="2">
<li></li>
</ol>
新功能试用 : 建议尝试新的日志重定向和逻辑表达式功能</li>
<li>
<ol start="3">
<li></li>
</ol>
依赖检查 : 确保所有依赖项已更新到兼容版本</li>
</ol>
<h2 id="-变更统计"><a class="header" href="#-变更统计">📊 变更统计</a></h2>
<ul>
<li>总提交数 : 30+ 次提交</li>
<li>功能新增 : 5个主要功能</li>
<li>问题修复 : 6个关键修复</li>
<li>代码优化 : 10+ 项改进
本次发布专注于提升系统稳定性、增加新功能，并修复已知问题，为用户提供更好的DevSecOps自动化体验。</li>
</ul>
<h1 id="083"><a class="header" href="#083">0.8.3</a></h1>
<h2 id="新增"><a class="header" href="#新增">新增</a></h2>
<ul>
<li>GXL 支持 数字、BOOL、数组、对象 数据类型</li>
<li>提供 defined 函数 - 检查变量是否已定义</li>
<li>提供 gx.shell 方便 shell 调用</li>
<li>支持 ${VAR:default} 变量定义默认值</li>
<li>gprj update mod 或 gflow --update mod 支持更新项目依赖的Mod</li>
</ul>
<h2 id="改进"><a class="header" href="#改进">改进</a></h2>
<ul>
<li>gx.read_file 读取内容到对象，便于后续处理</li>
<li>winnow 升级 0.7</li>
<li>对于远程Mod的获取，去掉外部Git 依赖</li>
<li>修改外部依赖</li>
</ul>
<h1 id="070"><a class="header" href="#070">0.7.0</a></h1>
<h2 id="新增-1"><a class="header" href="#新增-1">新增</a></h2>
<ul>
<li>支持事务机制</li>
<li>支持dryrun机制 - 允许预览操作结果而不实际执行</li>
</ul>
<h1 id="064"><a class="header" href="#064">0.6.4</a></h1>
<h2 id="新增-2"><a class="header" href="#新增-2">新增</a></h2>
<ul>
<li>支持 gx.cmd  quiet (静默） - 自定义控制cmd的日志输出与否</li>
</ul>
<h1 id="062"><a class="header" href="#062">0.6.2</a></h1>
<h2 id="新增-3"><a class="header" href="#新增-3">新增</a></h2>
<ul>
<li>优化日志输出，增加日志的重定向，支持捕获控制台标准日志输出</li>
</ul>
<h1 id="060"><a class="header" href="#060">0.6.0</a></h1>
<h2 id="新增-4"><a class="header" href="#新增-4">新增</a></h2>
<ul>
<li>生成任务报告 - 提供执行过程和结果的详细信息</li>
<li>支持flow上的Task注解 - 增强流程定义的灵活性</li>
</ul>
<h2 id="改进-1"><a class="header" href="#改进-1">改进</a></h2>
<ul>
<li>改进 flow 编排语法，由: 变为 |  符号</li>
</ul>
<h1 id="gflow-053"><a class="header" href="#gflow-053">gflow-0.5.3</a></h1>
<h2 id="内置环境变量"><a class="header" href="#内置环境变量">内置环境变量</a></h2>
<ul>
<li>GXL_PRJ_ROOT:    最近定义的 _gal/project.toml 的目录</li>
</ul>
<h2 id="extern-mod-支持变量"><a class="header" href="#extern-mod-支持变量">extern mod 支持变量</a></h2>
<pre><code>extern mod head { path = "${GXL_START_ROOT}/_gal/"; }
</code></pre>
<p><a href="https://github.com/galaxy-sec/galaxy-flow/releases/tag/v0.5.3">0.5.3 下载</a></p>
<h1 id="052"><a class="header" href="#052">0.5.2</a></h1>
<h2 id="内置环境变量-1"><a class="header" href="#内置环境变量-1">内置环境变量</a></h2>
<ul>
<li>GXL_START_ROOT:  GXL 启动处理的目录</li>
<li>GXL_CUR_DIR:  GXL 当前所在目录，在调用gx.run时，与GXL_START_ROOT可能不同</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gflow-命令使用文档"><a class="header" href="#gflow-命令使用文档">gflow 命令使用文档</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p><code>gflow</code> 是 Galaxy Flow 的核心执行引擎，用于运行 GXL 流程文件。</p>
<h2 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h2>
<pre><code class="language-bash">gflow [OPTIONS] [FLOW]...
</code></pre>
<h2 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h2>
<h3 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h3>
<ul>
<li><code>FLOW...</code>: 要执行的流程名称，例如：conf, test, package</li>
</ul>
<h3 id="选项参数"><a class="header" href="#选项参数">选项参数</a></h3>
<ul>
<li><code>-e, --env &lt;ENV&gt;</code>: 环境名称，例如：-e dev（默认：default）</li>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别，例如：-d 1（默认：0）</li>
<li><code>-f, --conf &lt;CONF&gt;</code>: 配置文件路径，默认为：
<ul>
<li>work: <code>./_rg/work.gxl</code></li>
<li>adm: <code>./_rg/adm.gxl</code></li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code>: 配置日志级别，例如：--log cmd=debug,parse=info</li>
<li><code>-q, --quiet</code>: 静默模式</li>
<li><code>-h, --help</code>: 显示帮助信息</li>
<li><code>-V, --version</code>: 显示版本信息</li>
</ul>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<h3 id="基本执行"><a class="header" href="#基本执行">基本执行</a></h3>
<pre><code class="language-bash"># 执行默认工作流
gflow

# 执行指定流程
gflow conf test package
</code></pre>
<h3 id="环境切换"><a class="header" href="#环境切换">环境切换</a></h3>
<pre><code class="language-bash"># 使用开发环境
gflow -e dev

# 使用生产环境
gflow -e prod
</code></pre>
<h3 id="调试模式"><a class="header" href="#调试模式">调试模式</a></h3>
<pre><code class="language-bash"># 启用调试模式
gflow -d 2

# 配置详细日志
gflow --log cmd=debug,parse=info
</code></pre>
<h3 id="指定配置"><a class="header" href="#指定配置">指定配置</a></h3>
<pre><code class="language-bash"># 使用自定义配置文件
gflow -f ./config/my-config.gxl
</code></pre>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<p>默认配置文件为：</p>
<ul>
<li><code>./_rg/work.gxl</code> - 工作流配置</li>
<li><code>./_rg/adm.gxl</code> - 管理配置</li>
</ul>
<p>配置文件包含：</p>
<ul>
<li>任务定义</li>
<li>变量配置</li>
<li>模块引用</li>
<li>执行策略</li>
</ul>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<ul>
<li><code>GALAXY_FLOW_HOME</code>: Galaxy Flow 主目录</li>
<li><code>RUST_LOG</code>: Rust 日志级别</li>
</ul>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<ul>
<li><code>0</code>: 执行成功</li>
<li><code>非0</code>: 执行失败，返回错误码</li>
</ul>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="找不到配置文件"><a class="header" href="#找不到配置文件">找不到配置文件</a></h3>
<p>确保当前目录下有 <code>_rg/work.gxl</code> 或 <code>_rg/adm.gxl</code> 文件，或使用 <code>-f</code> 指定配置文件。</p>
<h3 id="权限问题"><a class="header" href="#权限问题">权限问题</a></h3>
<p>确保有执行权限：</p>
<pre><code class="language-bash">chmod +x gflow
</code></pre>
<h3 id="模块加载失败"><a class="header" href="#模块加载失败">模块加载失败</a></h3>
<p>检查网络连接和模块路径配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod"><a class="header" href="#gmod">gmod</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gops---galaxy-operations-system-系统操作管理工具"><a class="header" href="#gops---galaxy-operations-system-系统操作管理工具">gops - Galaxy Operations System 系统操作管理工具</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p><code>gops</code> 是 Galaxy Operations System 的核心命令行工具，用于管理系统配置、模块操作和系统设置。它提供了完整的系统管理功能，帮助开发者高效地管理 Galaxy 系统的各种组件和配置。</p>
<h2 id="基本用法-1"><a class="header" href="#基本用法-1">基本用法</a></h2>
<h3 id="显示版本信息"><a class="header" href="#显示版本信息">显示版本信息</a></h3>
<pre><code class="language-bash">gops
# 输出示例：gops: 0.12.0
</code></pre>
<h3 id="显示帮助信息"><a class="header" href="#显示帮助信息">显示帮助信息</a></h3>
<pre><code class="language-bash">gops --help
gops &lt;command&gt; --help
gops &lt;command&gt; &lt;subcommand&gt; --help
</code></pre>
<h2 id="命令结构"><a class="header" href="#命令结构">命令结构</a></h2>
<p><code>gops</code> 采用三层命令结构：</p>
<pre><code>gops [全局选项] &lt;主命令&gt; [子命令选项] &lt;子命令&gt;
</code></pre>
<h3 id="主命令"><a class="header" href="#主命令">主命令</a></h3>
<ol>
<li><strong><code>gops prj</code></strong> - 工程管理命令</li>
<li><strong><code>gops mod</code></strong> - 模块管理命令</li>
<li><strong><code>gops sys</code></strong> - 系统管理命令</li>
</ol>
<h2 id="全局选项"><a class="header" href="#全局选项">全局选项</a></h2>
<p>所有命令都支持以下全局选项：</p>
<h3 id="调试选项"><a class="header" href="#调试选项">调试选项</a></h3>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li><code>0</code>: 关闭调试输出</li>
<li><code>1</code>: 基础调试信息</li>
<li><code>2</code>: 详细调试信息</li>
<li><code>3</code>: 跟踪调试信息</li>
<li><code>4</code>: 完整调试信息</li>
</ul>
</li>
</ul>
<h3 id="日志选项"><a class="header" href="#日志选项">日志选项</a></h3>
<ul>
<li><code>--log &lt;LOG&gt;</code> - 日志级别配置
<ul>
<li>格式：<code>模块=级别,模块=级别</code></li>
<li>例如：<code>--log setting=debug,system=info</code></li>
</ul>
</li>
</ul>
<h3 id="强制选项"><a class="header" href="#强制选项">强制选项</a></h3>
<ul>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li><code>0</code>: 正常模式（默认）</li>
<li><code>1</code>: 跳过确认</li>
<li><code>2</code>: 覆盖文件</li>
<li><code>3</code>: 强制拉取</li>
</ul>
</li>
</ul>
<h2 id="工程管理命令-gops-prj"><a class="header" href="#工程管理命令-gops-prj">工程管理命令 (gops prj)</a></h2>
<h3 id="创建维护工程"><a class="header" href="#创建维护工程">创建维护工程</a></h3>
<pre><code class="language-bash">gops prj new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 工程配置名称（必填）</li>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的维护工程</li>
<li>初始化工程目录结构</li>
<li>生成必要的配置文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 my-project 的工程
gops prj new --name my-project

# 创建工程并启用调试
gops prj new --name my-project --debug 2
</code></pre>
<h3 id="导入系统到工程"><a class="header" href="#导入系统到工程">导入系统到工程</a></h3>
<pre><code class="language-bash">gops prj import [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-p, --path &lt;PATH&gt;</code> - 系统导入路径（必填）</li>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>从指定路径导入系统配置</li>
<li>将系统集成到当前工程</li>
<li>自动处理系统依赖关系</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 从指定路径导入系统
gops prj import --path /path/to/system

# 详细调试导入过程
gops prj import --path /path/to/system --debug 3
</code></pre>
<h3 id="更新工程"><a class="header" href="#更新工程">更新工程</a></h3>
<pre><code class="language-bash">gops prj update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新工程中的系统引用</li>
<li>更新模块依赖关系</li>
<li>下载远程资源</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新工程
gops prj update

# 强制更新（覆盖文件）
gops prj update --force 2

# 详细调试更新过程
gops prj update --debug 3 --log update=debug
</code></pre>
<h3 id="工程设置"><a class="header" href="#工程设置">工程设置</a></h3>
<pre><code class="language-bash">gops prj setting [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-i, --interactive</code> - 启用交互模式（默认：true）</li>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>管理工程级别的变量设置</li>
<li>支持交互式和非交互式配置</li>
<li>自动保存配置到 value.yml 文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 基于默认值，生成value.yml
gops prj setting



# 显式启用交互模式
gops prj setting -i

</code></pre>
<h2 id="模块管理命令-gops-mod"><a class="header" href="#模块管理命令-gops-mod">模块管理命令 (gops mod)</a></h2>
<h3 id="创建示例模块结构"><a class="header" href="#创建示例模块结构">创建示例模块结构</a></h3>
<pre><code class="language-bash">gops mod example [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建完整的示例模块结构</li>
<li>包含示例配置和工作流</li>
<li>展示模块组织最佳实践</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建示例模块
gops mod example

# 创建示例模块并启用调试
gops mod example --debug 2
</code></pre>
<h3 id="定义新模块操作符"><a class="header" href="#定义新模块操作符">定义新模块操作符</a></h3>
<pre><code class="language-bash">gops mod new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 模块名称（必填）
<ul>
<li>支持字母数字、连字符和下划线</li>
</ul>
</li>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>使用给定名称创建新模块规范</li>
<li>初始化模块目录结构</li>
<li>生成所有必要的配置文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 my-module 的模块
gops mod new --name my-module

# 创建模块并启用调试
gops mod new --name my-module --debug 3
</code></pre>
<h3 id="更新现有模块操作符"><a class="header" href="#更新现有模块操作符">更新现有模块操作符</a></h3>
<pre><code class="language-bash">gops mod update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新现有模块的配置</li>
<li>更新模块依赖关系或规范</li>
<li>支持强制更新模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新模块
gops mod update

# 强制更新模块
gops mod update --force 1

# 详细调试更新过程
gops mod update --debug 4 --log mod=debug
</code></pre>
<h3 id="本地化模块配置"><a class="header" href="#本地化模块配置">本地化模块配置</a></h3>
<pre><code class="language-bash">gops mod localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 包含环境特定值的 YAML/JSON 文件路径</li>
<li><code>--default</code> - 使用内置默认值而不是用户提供的 value.yml</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>基于环境特定值生成本地化配置文件</li>
<li>适配不同部署环境的需求</li>
<li>支持自定义值或默认值选择</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认值本地化
gops mod localize --default

# 使用自定义值文件本地化
gops mod localize --value prod-values.yml

# 使用自定义值文件并启用调试
gops mod localize --value dev-values.yml --debug 2
</code></pre>
<h2 id="系统管理命令-gops-sys"><a class="header" href="#系统管理命令-gops-sys">系统管理命令 (gops sys)</a></h2>
<h3 id="创建新的系统操作符"><a class="header" href="#创建新的系统操作符">创建新的系统操作符</a></h3>
<pre><code class="language-bash">gops sys new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 系统名称（必填）
<ul>
<li>支持字母数字、连字符和下划线</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建新的系统规范</li>
<li>初始化系统目录结构</li>
<li>生成所有必要的配置文件和模板</li>
<li>交互式选择系统型号配置（测试环境下自动选择）</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建新系统（交互式选择型号）
gops sys new --name my-system

# 在测试环境中创建系统
TEST_MODE=true gops sys new --name test-system
</code></pre>
<h3 id="更新系统配置"><a class="header" href="#更新系统配置">更新系统配置</a></h3>
<pre><code class="language-bash">gops sys update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新现有系统配置</li>
<li>更新系统规范或依赖关系</li>
<li>支持强制更新以不确认的情况下覆盖配置</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新系统
gops sys update

# 强制更新系统（跳过确认）
gops sys update --force 1

# 详细调试更新过程
gops sys update --debug 3 --log sys=debug
</code></pre>
<h3 id="为环境本地化系统配置"><a class="header" href="#为环境本地化系统配置">为环境本地化系统配置</a></h3>
<pre><code class="language-bash">gops sys localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 包含环境特定值的 YAML/JSON 文件路径</li>
<li><code>--default</code> - 使用内置默认值而不是用户提供的 value.yml</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>基于环境特定值生成本地化系统配置文件</li>
<li>适配不同部署环境的系统配置</li>
<li>支持自定义值或默认值选择</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认值本地化系统配置
gops sys localize --default

# 使用自定义值文件本地化
gops sys localize --value prod-config.yml

# 使用自定义值文件并启用调试
gops sys localize --value dev-config.yml --debug 2
</code></pre>
<h2 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h2>
<h3 id="调试环境变量"><a class="header" href="#调试环境变量">调试环境变量</a></h3>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置
<ul>
<li>当设置为任意值时，启用测试环境行为</li>
<li>在 <code>gops sys new</code> 中自动选择系统型号而不是交互式选择</li>
</ul>
</li>
</ul>
<h3 id="模拟环境变量"><a class="header" href="#模拟环境变量">模拟环境变量</a></h3>
<ul>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态
<ul>
<li>用于测试环境中模拟成功的操作</li>
<li>通常与 <code>TEST_MODE</code> 一起使用</li>
</ul>
</li>
</ul>
<h2 id="配置文件结构"><a class="header" href="#配置文件结构">配置文件结构</a></h2>
<h3 id="工程目录结构"><a class="header" href="#工程目录结构">工程目录结构</a></h3>
<pre><code>my-project/
├── ops-prj.yml              # 工程主配置文件
├── values/                  # 配置值目录
│   └── {system-name}/      # 系统特定值
│       └── value.yml       # 系统变量值文件
├── ops-systems.yml          # 系统引用配置
└── {system-name}/          # 系统目录
    ├── sys/                 # 系统配置
    │   ├── sys.yml          # 系统规范
    │   └── vars.yml         # 系统变量定义
    └── values/              # 系统值链接（指向 values/{system-name}/）
</code></pre>
<h3 id="模块目录结构"><a class="header" href="#模块目录结构">模块目录结构</a></h3>
<pre><code>my-module/
├── mod.yml                  # 模块配置文件
├── sys/                     # 系统配置
├── workflow/                # 工作流配置
├── artifacts/               # 构建产物
├── config/                  # 配置文件
└── settings/                # 模块设置
</code></pre>
<h3 id="系统目录结构"><a class="header" href="#系统目录结构">系统目录结构</a></h3>
<pre><code>my-system/
├── sys/                     # 系统配置
│   ├── sys.yml              # 系统规范
│   ├── model.yml            # 系统模型
│   └── vars.yml             # 系统变量定义
├── workflow/                # 工作流配置
├── templates/               # 模板文件
├── examples/                # 示例配置
└── scripts/                 # 脚本文件
</code></pre>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<h3 id="工程管理"><a class="header" href="#工程管理">工程管理</a></h3>
<pre><code class="language-bash"># 1. 创建新工程
gops prj new --name my-project

# 2. 导入系统到工程
gops prj import --path /path/to/system --force 1

# 3. 更新工程
gops prj update

# 4. 配置工程变量（交互模式）
gops prj setting

# 5. 配置工程变量（非交互模式）
gops prj setting --no-interactive
</code></pre>
<h3 id="模块开发"><a class="header" href="#模块开发">模块开发</a></h3>
<pre><code class="language-bash"># 1. 创建示例模块（学习结构）
gops mod example

# 2. 创建新模块
gops mod new --name my-module

# 3. 更新模块
gops mod update --force 2

# 4. 本地化模块配置
gops mod localize --value dev-values.yml
</code></pre>
<h3 id="系统管理"><a class="header" href="#系统管理">系统管理</a></h3>
<pre><code class="language-bash"># 1. 创建新系统
gops sys new --name my-system

# 2. 更新系统
gops sys update --force 1

# 3. 本地化系统配置
gops sys localize --value prod-config.yml
</code></pre>
<h3 id="调试技巧"><a class="header" href="#调试技巧">调试技巧</a></h3>
<pre><code class="language-bash"># 启用详细调试
gops prj import --path /test --debug 4 --log all=debug

# 调试特定模块
gops mod update --debug 3 --log mod=debug

# 调试系统操作
gops sys update --debug 3 --log sys=debug

# 调试设置操作
gops prj setting --debug 2 --log setting=debug
</code></pre>
<h2 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h2>
<h3 id="常见错误及解决方案"><a class="header" href="#常见错误及解决方案">常见错误及解决方案</a></h3>
<p><strong>Q: 工程创建失败</strong></p>
<pre><code>错误：无法创建目录 "my-project"
解决：检查目录权限，或选择不同的名称
</code></pre>
<p><strong>Q: 系统导入失败</strong></p>
<pre><code>错误：load project from ./path fail!
解决：检查路径是否正确，确保有适当的访问权限
gops prj import --path /path/to/system --debug 3
</code></pre>
<p><strong>Q: 模块更新失败</strong></p>
<pre><code>错误：无法加载模块配置
解决：确保在正确的模块目录中执行命令
gops mod update --debug 4 --log mod=debug
</code></pre>
<p><strong>Q: 系统创建卡在选择界面</strong></p>
<pre><code>解决：在测试环境中设置 TEST_MODE 环境变量
TEST_MODE=true gops sys new --name test-system
</code></pre>
<p><strong>Q: 设置命令在非交互模式下失败</strong></p>
<pre><code>解决：确保 value.yml 文件存在且格式正确
gops prj setting --no-interactive --debug 2
</code></pre>
<h3 id="调试模式使用"><a class="header" href="#调试模式使用">调试模式使用</a></h3>
<pre><code class="language-bash"># 基础调试
gops prj import --path /test --debug 1

# 详细调试
gops mod update --debug 2 --log mod=debug

# 跟踪级别调试
gops sys update --debug 3 --log sys=trace

# 完整调试
gops prj setting --debug 4 --log all=debug
</code></pre>
<h3 id="日志配置示例"><a class="header" href="#日志配置示例">日志配置示例</a></h3>
<pre><code class="language-bash"># 调试特定模块
gops mod update --log mod=debug

# 调试多个模块
gops sys update --log sys=debug,net=info

# 设置不同级别
gops prj import --log import=debug,system=info,net=trace

# 调试所有内容
gops mod update --log all=debug
</code></pre>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxops_run_success

# 运行测试并显示输出
cargo test -- --nocapture

# 在测试环境中运行
TEST_MODE=true cargo test

# 运行特定命令的测试
cargo test test_ia_setting_interactive
cargo test test_ia_setting_non_interactive
</code></pre>
<h2 id="示例工作流"><a class="header" href="#示例工作流">示例工作流</a></h2>
<h3 id="开发环境设置"><a class="header" href="#开发环境设置">开发环境设置</a></h3>
<pre><code class="language-bash"># 1. 创建开发工程
gops prj new --name dev-project

# 2. 导入开发系统
gops prj import --path /path/to/dev-system --force 1

# 3. 更新工程依赖
gops prj update --debug 2

# 4. 配置开发变量（非交互模式）
gops prj setting --no-interactive

# 5. 创建开发模块
gops mod new --name dev-module

# 6. 本地化模块配置
gops mod localize --value dev-values.yml
</code></pre>
<h3 id="生产环境部署"><a class="header" href="#生产环境部署">生产环境部署</a></h3>
<pre><code class="language-bash"># 1. 创建生产工程
gops prj new --name prod-project

# 2. 导入生产系统
gops prj import --path /path/to/prod-system --force 3

# 3. 配置生产变量（使用默认值）
gops prj setting --no-interactive

# 4. 本地化生产配置
gops sys localize --value prod-config.yml --default
</code></pre>
<h2 id="版本信息"><a class="header" href="#版本信息">版本信息</a></h2>
<p>当前版本：<code>0.12.0</code></p>
<h2 id="功能状态"><a class="header" href="#功能状态">功能状态</a></h2>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>子命令</th><th>状态</th><th>说明</th></tr></thead><tbody>
<tr><td><code>gops prj</code></td><td><code>new</code></td><td>✅ 完成</td><td>创建维护工程</td></tr>
<tr><td><code>gops prj</code></td><td><code>import</code></td><td>✅ 完成</td><td>导入系统到工程</td></tr>
<tr><td><code>gops prj</code></td><td><code>update</code></td><td>✅ 完成</td><td>更新工程</td></tr>
<tr><td><code>gops prj</code></td><td><code>setting</code></td><td>✅ 完成</td><td>工程设置（支持交互/非交互模式）</td></tr>
<tr><td><code>gops mod</code></td><td><code>example</code></td><td>✅ 完成</td><td>创建示例模块结构</td></tr>
<tr><td><code>gops mod</code></td><td><code>new</code></td><td>✅ 完成</td><td>定义新模块操作符</td></tr>
<tr><td><code>gops mod</code></td><td><code>update</code></td><td>✅ 完成</td><td>更新现有模块操作符</td></tr>
<tr><td><code>gops mod</code></td><td><code>localize</code></td><td>✅ 完成</td><td>本地化模块配置</td></tr>
<tr><td><code>gops sys</code></td><td><code>new</code></td><td>✅ 完成</td><td>创建新的系统操作符</td></tr>
<tr><td><code>gops sys</code></td><td><code>update</code></td><td>✅ 完成</td><td>更新系统配置</td></tr>
<tr><td><code>gops sys</code></td><td><code>localize</code></td><td>✅ 完成</td><td>为环境本地化系统配置</td></tr>
</tbody></table>
</div>
<h2 id="许可证"><a class="header" href="#许可证">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见项目根目录的 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gprj-命令使用文档"><a class="header" href="#gprj-命令使用文档">gprj 命令使用文档</a></h1>
<h2 id="概述-2"><a class="header" href="#概述-2">概述</a></h2>
<p><code>gprj</code> 是 Galaxy Flow 的项目管理工具，用于初始化和管理 Galaxy 项目环境。</p>
<h2 id="基本用法-2"><a class="header" href="#基本用法-2">基本用法</a></h2>
<pre><code class="language-bash">gprj &lt;COMMAND&gt; [OPTIONS]
</code></pre>
<h2 id="命令列表"><a class="header" href="#命令列表">命令列表</a></h2>
<h3 id="1-init---初始化命令"><a class="header" href="#1-init---初始化命令">1. init - 初始化命令</a></h3>
<p>用于初始化 Galaxy 环境和项目。</p>
<h4 id="init-env---初始化-galaxy-环境"><a class="header" href="#init-env---初始化-galaxy-环境">init env - 初始化 Galaxy 环境</a></h4>
<pre><code class="language-bash">gprj init env
</code></pre>
<p>初始化系统级的 Galaxy 运行环境。</p>
<h4 id="init-prj-with-local---使用本地模块初始化项目"><a class="header" href="#init-prj-with-local---使用本地模块初始化项目">init prj-with-local - 使用本地模块初始化项目</a></h4>
<pre><code class="language-bash">gprj init prj-with-local
</code></pre>
<p>创建新项目并使用本地模块作为依赖。</p>
<h4 id="init-prj---使用远程模板初始化项目"><a class="header" href="#init-prj---使用远程模板初始化项目">init prj - 使用远程模板初始化项目</a></h4>
<pre><code class="language-bash">gprj init prj [OPTIONS]
</code></pre>
<h5 id="参数"><a class="header" href="#参数">参数</a></h5>
<ul>
<li><code>--tpl &lt;TPL&gt;</code>: 选择模板名称（默认：simple）
<ul>
<li>可选值：simple, open_pages, rust_prj 等</li>
</ul>
</li>
<li><code>--branch &lt;BRANCH&gt;</code>: 指定模板仓库分支</li>
<li><code>--tag &lt;TAG&gt;</code>: 指定模板仓库标签
<ul>
<li>可选值：alpha, develop, beta, release/1.0</li>
</ul>
</li>
<li><code>--repo &lt;REPO&gt;</code>: 模板仓库地址（默认：https://gal-tpl.git）</li>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别（默认：0）</li>
<li><code>--log &lt;LOG&gt;</code>: 日志配置</li>
<li><code>-p, --cmd-print</code>: 打印执行的命令</li>
</ul>
<h5 id="示例"><a class="header" href="#示例">示例</a></h5>
<pre><code class="language-bash"># 使用默认模板初始化
gprj init prj

# 使用特定模板
gprj init prj --tpl rust_prj

# 使用特定分支
gprj init prj --branch develop

# 使用特定标签
gprj init prj --tag release/1.0
</code></pre>
<h3 id="2-update---更新命令"><a class="header" href="#2-update---更新命令">2. update - 更新命令</a></h3>
<p>用于更新项目模块。</p>
<h4 id="update-mod---更新模块"><a class="header" href="#update-mod---更新模块">update mod - 更新模块</a></h4>
<pre><code class="language-bash">gprj update mod [OPTIONS]
</code></pre>
<h5 id="参数-1"><a class="header" href="#参数-1">参数</a></h5>
<ul>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别（默认：0）</li>
<li><code>-f, --conf-work &lt;CONF_WORK&gt;</code>: 工作配置文件（默认：./_gal/work.gxl）</li>
<li><code>--conf-adm &lt;CONF_ADM&gt;</code>: 管理配置文件（默认：./_gal/adm.gxl）</li>
<li><code>--log &lt;LOG&gt;</code>: 日志配置</li>
<li><code>-q, --quiet</code>: 静默模式（默认：true）</li>
</ul>
<h5 id="示例-1"><a class="header" href="#示例-1">示例</a></h5>
<pre><code class="language-bash"># 更新模块
gprj update mod

# 使用自定义配置更新
gprj update mod -f ./config/work.gxl
</code></pre>
<h3 id="3-conf---配置管理"><a class="header" href="#3-conf---配置管理">3. conf - 配置管理</a></h3>
<p>用于管理配置文件。</p>
<h4 id="conf-init---初始化配置"><a class="header" href="#conf-init---初始化配置">conf init - 初始化配置</a></h4>
<pre><code class="language-bash">gprj conf init [OPTIONS]
</code></pre>
<h5 id="参数-2"><a class="header" href="#参数-2">参数</a></h5>
<ul>
<li><code>-r, --remote</code>: 使用远程配置（默认：false）</li>
</ul>
<h5 id="示例-2"><a class="header" href="#示例-2">示例</a></h5>
<pre><code class="language-bash"># 初始化本地配置
gprj conf init

# 初始化远程配置
gprj conf init --remote
</code></pre>
<h3 id="4-check---检查命令"><a class="header" href="#4-check---检查命令">4. check - 检查命令</a></h3>
<p>检查当前项目配置和环境。</p>
<pre><code class="language-bash">gprj check
</code></pre>
<h3 id="5-adm---管理命令"><a class="header" href="#5-adm---管理命令">5. adm - 管理命令</a></h3>
<p>执行管理任务，等同于 gflow 的管理模式。</p>
<pre><code class="language-bash">gprj adm [OPTIONS]
</code></pre>
<h2 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h2>
<h3 id="默认配置文件"><a class="header" href="#默认配置文件">默认配置文件</a></h3>
<ul>
<li><code>./_gal/work.gxl</code> - 工作流配置</li>
<li><code>./_gal/adm.gxl</code> - 管理配置</li>
<li><code>./_gal/head.gxl</code> - 头部配置</li>
</ul>
<h3 id="配置内容"><a class="header" href="#配置内容">配置内容</a></h3>
<ul>
<li>项目元数据</li>
<li>模块依赖</li>
<li>环境变量</li>
<li>执行策略</li>
</ul>
<h2 id="使用流程"><a class="header" href="#使用流程">使用流程</a></h2>
<h3 id="1-初始化新项目"><a class="header" href="#1-初始化新项目">1. 初始化新项目</a></h3>
<pre><code class="language-bash"># 1. 初始化环境
gprj init env

# 2. 初始化项目
gprj init prj --tpl simple

# 3. 检查配置
gprj check
</code></pre>
<h3 id="2-更新项目"><a class="header" href="#2-更新项目">2. 更新项目</a></h3>
<pre><code class="language-bash"># 更新所有模块
gprj update mod

# 使用自定义配置更新
gprj update mod -f ./my-config.gxl
</code></pre>
<h3 id="3-配置管理"><a class="header" href="#3-配置管理">3. 配置管理</a></h3>
<pre><code class="language-bash"># 初始化配置
gprj conf init

# 使用远程配置
gprj conf init --remote
</code></pre>
<h2 id="模板仓库"><a class="header" href="#模板仓库">模板仓库</a></h2>
<h3 id="默认模板仓库"><a class="header" href="#默认模板仓库">默认模板仓库</a></h3>
<ul>
<li>地址：https://gal-tpl.git</li>
<li>包含模板：simple, open_pages, rust_prj 等</li>
</ul>
<h3 id="自定义模板仓库"><a class="header" href="#自定义模板仓库">自定义模板仓库</a></h3>
<pre><code class="language-bash">gprj init prj --repo https://my-tpl.git --tpl my-template
</code></pre>
<h2 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h2>
<ul>
<li><code>GALAXY_FLOW_HOME</code>: Galaxy Flow 主目录</li>
<li><code>RUST_LOG</code>: Rust 日志级别</li>
</ul>
<h2 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h2>
<ul>
<li><code>0</code>: 执行成功</li>
<li><code>非0</code>: 执行失败，返回错误码</li>
</ul>
<h2 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h2>
<h3 id="权限问题-1"><a class="header" href="#权限问题-1">权限问题</a></h3>
<p>确保有执行权限：</p>
<pre><code class="language-bash">chmod +x gprj
</code></pre>
<h3 id="网络连接"><a class="header" href="#网络连接">网络连接</a></h3>
<p>初始化项目时需要网络连接以下载模板。</p>
<h3 id="模板选择"><a class="header" href="#模板选择">模板选择</a></h3>
<p>使用 <code>gprj init prj --help</code> 查看所有可用模板。</p>
<h3 id="配置冲突"><a class="header" href="#配置冲突">配置冲突</a></h3>
<p>如果配置文件已存在，先备份再重新初始化：</p>
<pre><code class="language-bash">mv _gal/work.gxl _gal/work.gxl.backup
gprj conf init
</code></pre>
<h2 id="最佳实践-1"><a class="header" href="#最佳实践-1">最佳实践</a></h2>
<h3 id="项目初始化"><a class="header" href="#项目初始化">项目初始化</a></h3>
<ol>
<li>先初始化环境：<code>gprj init env</code></li>
<li>选择合适的模板：<code>gprj init prj --tpl &lt;template&gt;</code></li>
<li>检查配置：<code>gprj check</code></li>
<li>更新模块：<code>gprj update mod</code></li>
</ol>
<h3 id="团队协作"><a class="header" href="#团队协作">团队协作</a></h3>
<ul>
<li>使用统一的模板仓库</li>
<li>定期更新模块：<code>gprj update mod</code></li>
<li>使用版本控制管理配置文件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gsys"><a class="header" href="#gsys">gsys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buildin"><a class="header" href="#buildin">BUILDIN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="维护器"><a class="header" href="#维护器">维护器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统维护器"><a class="header" href="#系统维护器">系统维护器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统模型配置"><a class="header" href="#系统模型配置">系统模型配置</a></h1>
<h2 id="概述-3"><a class="header" href="#概述-3">概述</a></h2>
<p><code>sys_model.yml</code> 是 Sys-Operator 中最重要的配置文件之一，定义了系统的基础信息、目标运行环境和扩展元数据。所有系统都必须包含这个文件，它是系统定义的核心。</p>
<h2 id="配置结构"><a class="header" href="#配置结构">配置结构</a></h2>
<h3 id="基础系统定义"><a class="header" href="#基础系统定义">基础系统定义</a></h3>
<pre><code class="language-yaml"># 必需字段
name: system_name                    # 系统名称（必需）
model: arm-mac14-host               # 目标平台模型（必需）
vender: "Galaxy-Ops"                # 厂商信息（可选）
</code></pre>
<h3 id="扩展元数据"><a class="header" href="#扩展元数据">扩展元数据</a></h3>
<h2 id="字段详解"><a class="header" href="#字段详解">字段详解</a></h2>
<h3 id="1-name---系统名称"><a class="header" href="#1-name---系统名称">1. <code>name</code> - 系统名称</a></h3>
<p><strong>类型</strong>: <code>string</code>
<strong>必需</strong>: <code>是</code>
<strong>描述</strong>: 系统的唯一标识名称</p>
<p><strong>规范</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>避免特殊字符和空格</li>
<li>长度建议不超过 64 个字符</li>
<li>避免使用保留关键字</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的示例
name: production_web_system
name: microservice_platform
name: database_cluster

# 避免的示例
name: Production Web System  # 包含空格
name: prod_web_system$      # 包含特殊字符
name: sys_1                 # 无意义的编号
</code></pre>
<h3 id="2-model---目标平台模型"><a class="header" href="#2-model---目标平台模型">2. <code>model</code> - 目标平台模型</a></h3>
<p><strong>类型</strong>: <code>string</code>
<strong>必需</strong>: <code>是</code>
<strong>描述</strong>: 系统运行的目标平台和环境</p>
<p><strong>格式</strong>: <code>arch-os-spc</code></p>
<p><strong>组成部分</strong>:</p>
<ul>
<li>
<p><strong>架构 (arch)</strong>:</p>
<ul>
<li><code>arm</code>: ARM 架构（Apple M1/M2, Raspberry Pi 等）</li>
<li><code>x86</code>: x86-64 架构（Intel/AMD）</li>
<li><code>amd64</code>: AMD64 架构（兼容 x86-64）</li>
<li><code>aarch64</code>: ARM64 架构</li>
</ul>
</li>
<li>
<p><strong>操作系统 (os)</strong>:</p>
<ul>
<li><code>mac14</code>: macOS 14.x</li>
<li><code>ubt22</code>: Ubuntu 22.04 LTS</li>
</ul>
</li>
<li>
<p><strong>环境 (spc)</strong>:</p>
<ul>
<li><code>host</code>: 宿主机环境</li>
<li><code>k8s</code>: Kubernetes 环境</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># Apple M1 芯片，macOS 14，Host 模式
model: arm-mac14-host

# Intel x86，Ubuntu 22.04，Kubernetes 模式
model: x86-ubt22-k8s

# Intel x86，Ubuntu 22.04，Docker 容器模式
model: x86-ubt22-docker

</code></pre>
<h3 id="3-vender---厂商信息"><a class="header" href="#3-vender---厂商信息">3. <code>vender</code> - 厂商信息</a></h3>
<p><strong>类型</strong>: <code>string</code>
<strong>必需</strong>: <code>否</code>
<strong>描述</strong>: 系统的厂商、组织或开发者信息</p>
<p><strong>用途</strong>:</p>
<ul>
<li>标识系统来源</li>
<li>版本管理和发布</li>
<li>技术支持联系</li>
<li>生态系统分类</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml">vender: "Galaxy-Ops"
vender: "Enterprise Corp"
vender: "Open Source Community"
vender: "Development Team"
</code></pre>
<h2 id="最佳实践-2"><a class="header" href="#最佳实践-2">最佳实践</a></h2>
<h3 id="1-命名最佳实践"><a class="header" href="#1-命名最佳实践">1. 命名最佳实践</a></h3>
<h4 id="系统命名建议"><a class="header" href="#系统命名建议">系统命名建议</a></h4>
<ul>
<li>使用描述性名称，清晰表达系统功能</li>
<li>包含环境标识（如 <code>production_</code>, <code>staging_</code>, <code>dev_</code>）</li>
<li>避免使用版本号（使用 <code>metadata.version</code> 管理）</li>
<li>保持命名一致性</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的命名
name: production_web_system
name: staging_api_gateway
name: dev_database_cluster
name: monitoring_platform

# 避免的命名
name: web_system_prod      # 环境标识分离
name: sys_v2               # 版本号分离
name: app1                 # 无意义的编号
</code></pre>
<h4 id="版本管理建议"><a class="header" href="#版本管理建议">版本管理建议</a></h4>
<ul>
<li>使用语义化版本</li>
<li>使用 <code>metadata.version</code> 而非文件名</li>
<li>考虑使用标签和分支管理版本</li>
</ul>
<h3 id="3-模型选择建议"><a class="header" href="#3-模型选择建议">3. 模型选择建议</a></h3>
<h4 id="平台兼容性"><a class="header" href="#平台兼容性">平台兼容性</a></h4>
<ul>
<li>选择目标部署环境支持的平台模型</li>
<li>考虑跨平台兼容性需求</li>
<li>明确标记平台特定的配置</li>
</ul>
<h4 id="环境区分"><a class="header" href="#环境区分">环境区分</a></h4>
<ul>
<li>使用不同的模型区分开发和生产环境</li>
<li>考虑容器化 vs 宿主机部署的差异</li>
<li>支持混合环境部署需求</li>
</ul>
<h2 id="故障排除-1"><a class="header" href="#故障排除-1">故障排除</a></h2>
<h3 id="1-常见错误"><a class="header" href="#1-常见错误">1. 常见错误</a></h3>
<h4 id="缺少必需字段"><a class="header" href="#缺少必需字段">缺少必需字段</a></h4>
<pre><code class="language-yaml"># 错误示例
# 缺少 name 字段
model: x86-ubt22-host
vender: "Example Corp"

# 缺少 model 字段
name: example_system
vender: "Example Corp"
</code></pre>
<h4 id="模型格式错误"><a class="header" href="#模型格式错误">模型格式错误</a></h4>
<pre><code class="language-yaml"># 错误示例
model: arm-mac-14-host    # 分隔符错误
model: x86-ubuntu-22-host # 操作系统名称错误
model: arm-mac14-docker  # 不支持的环境
</code></pre>
<h4 id="命名格式错误"><a class="header" href="#命名格式错误">命名格式错误</a></h4>
<pre><code class="language-yaml"># 错误示例
name: Production System  # 包含空格
name: system$1           # 包含特殊字符
name: SYSTEM_NAME        # 包含大写字母
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><code>sys_model.yml</code> 是系统配置的核心文件，定义了系统的基础信息和运行环境。理解各个字段的含义和规范对于正确配置系统至关重要：</p>
<ol>
<li><strong>name</strong>: 系统的唯一标识，必须规范命名</li>
<li><strong>model</strong>: 目标平台环境，格式必须正确</li>
<li><strong>vender</strong>: 厂商信息，用于标识系统来源</li>
</ol>
<p>遵循这些配置规范和最佳实践，可以：</p>
<ul>
<li>提高配置的可读性和维护性</li>
<li>确保系统在不同环境中的正确部署</li>
<li>支持系统的版本管理和生命周期管理</li>
<li>便于团队协作和知识共享</li>
</ul>
<p>建议在使用过程中：</p>
<ul>
<li>定期验证配置文件的正确性</li>
<li>保持命名和格式的一致性</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务系统示例"><a class="header" href="#微服务系统示例">微服务系统示例</a></h1>
<h2 id="概述-4"><a class="header" href="#概述-4">概述</a></h2>
<p>本文档提供了一个完整的微服务系统示例，展示如何使用 Sys-Operator 构建和管理复杂的微服务架构。该示例包含 Web 前端、API 网关、用户服务、订单服务和数据库等多个模块，体现了现代微服务系统的典型架构模式。</p>
<h2 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h2>
<h3 id="整体架构图"><a class="header" href="#整体架构图">整体架构图</a></h3>
<pre class="mermaid">graph TB
    subgraph &quot;客户端层&quot;
        A[Web浏览器]
        B[移动应用]
        C[API客户端]
    end

    subgraph &quot;接入层&quot;
        D[Nginx Ingress]
        E[API Gateway]
    end

    subgraph &quot;业务服务层&quot;
        F[用户服务]
        G[订单服务]
        H[支付服务]
        I[通知服务]
    end

    subgraph &quot;数据层&quot;
        J[PostgreSQL主库]
        K[PostgreSQL从库]
        L[Redis缓存]
    end

    subgraph &quot;基础设施层&quot;
        M[Kubernetes集群]
        N[监控系统]
        O[日志系统]
    end

    A --&gt; D
    B --&gt; D
    C --&gt; E

    D --&gt; E
    E --&gt; F
    E --&gt; G
    E --&gt; H
    E --&gt; I

    F --&gt; J
    G --&gt; J
    H --&gt; J
    I --&gt; L

    J --&gt; K
    J --&gt; L

    F --&gt; M
    G --&gt; M
    H --&gt; M
    I --&gt; M

    M --&gt; N
    M --&gt; O
</pre>
<h3 id="服务依赖关系"><a class="header" href="#服务依赖关系">服务依赖关系</a></h3>
<pre><code>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户服务      │───▶│   订单服务      │───▶│   支付服务      │
│ (UserService)   │    │ (OrderService)  │    │ (PaymentService) │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   PostgreSQL    │    │   PostgreSQL    │    │   PostgreSQL    │
│    主库         │    │    主库         │    │    主库         │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    Redis缓存    │    │    Redis缓存    │    │    Redis缓存    │
│ (用户会话)      │    │ (订单状态)      │    │ (支付状态)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
</code></pre>
<h2 id="系统配置"><a class="header" href="#系统配置">系统配置</a></h2>
<h3 id="1-系统模型定义-syssys_modelyml"><a class="header" href="#1-系统模型定义-syssys_modelyml">1. 系统模型定义 (<code>sys/sys_model.yml</code>)</a></h3>
<pre><code class="language-yaml"># 系统基本信息
name: microservice_platform
model: x86-ubt22-k8s
vender: "TechCorp"


### 2. 模块列表配置 (`sys/mod_list.yml`)

```yaml
# 接入层模块
- name: nginx_ingress
  addr:
    repo: https://github.com/galaxy-operators/nginx
    tag: v1.25.3
  model: x86-ubt22-k8s
  enable: true


- name: api_gateway
  addr:
    repo: https://github.com/galaxy-operators/api-gateway
    tag: v3.0.0
  model: x86-ubt22-k8s
  enable: true
  priority: 90


# 用户服务模块
- name: user_service
  addr:
    repo: https://github.com/techcorp/user-service
    tag: v4.1.0
  model: x86-ubt22-k8s
  enable: true
  priority: 80


# 订单服务模块
- name: order_service
  addr:
    repo: https://github.com/techcorp/order-service
    tag: v3.5.0
  model: x86-ubt22-k8s
  enable: true


# 支付服务模块
- name: payment_service
  addr:
    repo: https://github.com/techcorp/payment-service
    tag: v2.8.0
  model: x86-ubt22-k8s
  enable: true


# 通知服务模块
- name: notification_service
  addr:
    repo: https://github.com/techcorp/notification-service
    tag: v1.6.0
  model: x86-ubt22-k8s



# 数据库模块
- name: postgres_primary
  addr:
    repo: https://github.com/galaxy-operators/postgresql-ha
    tag: v15.5.0
  model: x86-ubt22-k8s
  enable: true


- name: postgres_readonly
  addr:
    repo: https://github.com/galaxy-operators/postgresql-ha
    tag: v15.5.0
  model: x86-ubt22-k8s
  enable: true


# 缓存模块
- name: redis_cache
  addr:
    repo: https://github.com/galaxy-operators/redis-ha
    tag: v7.2.4
  model: x86-ubt22-k8s
  enable: true


# 外部服务模块
- name: external_payment_gateway
  addr:
    path: ./external-gateways/payment-gateway
  model: x86-ubt22-k8s


# 监控模块
- name: monitoring_stack
  addr:
    repo: https://github.com/galaxy-operators/enterprise-monitoring
    tag: v2.5.0
  model: x86-ubt22-k8s
  enable: true

</code></pre>
<h3 id="3-系统变量配置-sysvarsyml"><a class="header" href="#3-系统变量配置-sysvarsyml">3. 系统变量配置 (<code>sys/vars.yml</code>)</a></h3>
<pre><code class="language-yaml"># 系统配置
vars:
# 环境配置
- name: ENVIRONMENT
  value: "production"
  description: "部署环境"

- name: CLUSTER_NAME
  value: "${CLUSTER_NAME:production-cluster}"
  description: "Kubernetes集群名称"


- name: NAMESPACE
  value: "${NAMESPACE:microservices}"
  description: "Kubernetes命名空间"


# 应用配置
- name: APP_VERSION
  value: "2.3.0"
  description: "应用版本"


- name: DOMAIN_NAME
  value: "${DOMAIN_NAME:platform.techcorp.com}"
  description: "系统域名"


- name: BASE_URL
  value: "https://${DOMAIN_NAME}"
  description: "基础URL"


# 安全配置
- name: ENABLE_MTLS
  value: "${ENABLE_MTLS:true}"
  description: "启用双向TLS"
  type: boolean
  group: security

- name: API_RATE_LIMIT
  value: "${API_RATE_LIMIT:1000}"
  description: "API速率限制"
  type: integer
  min: 1
  max: 10000
  group: security

- name: SESSION_TIMEOUT_MINUTES
  value: "${SESSION_TIMEOUT_MINUTES:30}"
  description: "会话超时时间"
  type: integer
  min: 5
  max: 1440


# 数据库配置
- name: DATABASE_BACKUP_SCHEDULE
  value: "${DATABASE_BACKUP_SCHEDULE:0 1 * * *}"
  description: "数据库备份计划"


- name: DATABASE_RETENTION_DAYS
  value: "${DATABASE_RETENTION_DAYS:30}"
  description: "数据保留天数"
  type: integer
  min: 7
  max: 365


- name: CONNECTION_POOL_SIZE
  value: "${CONNECTION_POOL_SIZE:20}"
  description: "连接池大小"
  type: integer
  min: 1
  max: 100


# 缓存配置
- name: CACHE_DEFAULT_TTL
  value: "${CACHE_DEFAULT_TTL:3600}"
  description: "默认缓存TTL（秒）"
  type: integer
  min: 60
  max: 86400


- name: CACHE_MAX_SIZE
  value: "${CACHE_MAX_SIZE:10000}"
  description: "缓存最大条目数"
  type: integer
  min: 100
  max: 100000


- name: CACHE_REFRESH_INTERVAL
  value: "${CACHE_REFRESH_INTERVAL:300}"
  description: "缓存刷新间隔（秒）"
  type: integer
  min: 60
  max: 3600
  group: cache

# 消息队列配置
- name: MESSAGE_QUEUE_MAX_RETRIES
  value: "${MESSAGE_QUEUE_MAX_RETRIES:3}"
  description: "消息队列最大重试次数"
  type: integer
  min: 1
  max: 10
  group: messaging

- name: MESSAGE_QUEUE_DELAY_SECONDS
  value: "${MESSAGE_QUEUE_DELAY_SECONDS:60}"
  description: "消息队列重试延迟"
  type: integer
  min: 10
  max: 3600


# 高可用配置
- name: HIGH_AVAILABILITY_ENABLED
  value: "${HIGH_AVAILABILITY_ENABLED:true}"
  description: "启用高可用"
  type: boolean
  group: ha

- name: HEALTH_CHECK_INTERVAL_SECONDS
  value: "${HEALTH_CHECK_INTERVAL_SECONDS:30}"
  description: "健康检查间隔"
  type: integer
  min: 10
  max: 300

- name: FAILURE_DETECTION_SECONDS
  value: "${FAILURE_DETECTION_SECONDS:60}"
  description: "故障检测时间"
  type: integer
  min: 30
  max: 300
  group: ha

- name: AUTO_FAILOVER_ENABLED
  value: "${AUTO_FAILOVER_ENABLED:true}"
  description: "启用自动故障转移"
  type: boolean


# 性能配置
- name: DEFAULT_REPLICAS
  value: "${DEFAULT_REPLICAS:2}"
  description: "默认副本数"
  type: integer
  min: 1
  max: 10


- name: MAX_REPLICAS
  value: "${MAX_REPLICAS:10}"
  description: "最大副本数"
  type: integer
  min: 1
  max: 100


- name: CPU_REQUEST
  value: "${CPU_REQUEST:100m}"
  description: "CPU请求值"


- name: MEMORY_REQUEST
  value: "${MEMORY_REQUEST:256Mi}"
  description: "内存请求值"


- name: CPU_LIMIT
  value: "${CPU_LIMIT:2000m}"
  description: "CPU限制值"


- name: MEMORY_LIMIT
  value: "${MEMORY_LIMIT:4Gi}"
  description: "内存限制值"


# 监控配置
- name: MONITORING_ENABLED
  value: "${MONITORING_ENABLED:true}"
  description: "启用监控"
  type: boolean
  group: monitoring

- name: ALERT_EMAIL_RECIPIENTS
  value: "${ALERT_EMAIL_RECIPIENTS:devops-alerts@techcorp.com}"
  description: "告警邮件接收者"


- name: SLACK_WEBHOOK_URL
  value: "${SLACK_WEBHOOK_URL}"
  description: "Slack Webhook URL"


- name: PAGERDUTY_SERVICE_KEY
  value: "${PAGERDUTY_SERVICE_KEY}"
  description: "PagerDuty服务密钥"


# 业务配置
- name: BUSINESS_HOURS_START
  value: "${BUSINESS_HOURS_START:09:00}"
  description: "业务开始时间"


- name: BUSINESS_HOURS_END
  value: "${BUSINESS_HOURS_END:18:00}"
  description: "业务结束时间"


- name: MAINTENANCE_WINDOW_START
  value: "${MAINTENANCE_WINDOW_START:02:00}"
  description: "维护窗口开始时间"


- name: MAINTENANCE_WINDOW_END
  value: "${MAINTENANCE_WINDOW_END:04:00}"
  description: "维护窗口结束时间"


- name: FEATURE_FLAGS
  value: "${FEATURE_FLAGS:new-dashboard,advanced-analytics}"
  description: "功能开关"

</code></pre>
<h3 id="4-系统工作流配置-sysworkflowsoperatorsgxl"><a class="header" href="#4-系统工作流配置-sysworkflowsoperatorsgxl">4. 系统工作流配置 (<code>sys/workflows/operators.gxl</code>)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TODO
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sys-operator-目录结构"><a class="header" href="#sys-operator-目录结构">Sys-Operator 目录结构</a></h1>
<h2 id="概述-5"><a class="header" href="#概述-5">概述</a></h2>
<p>本文档详细说明了 Sys-Operator 的目录结构，帮助你理解系统组织和文件规范。</p>
<h2 id="完整的目录结构"><a class="header" href="#完整的目录结构">完整的目录结构</a></h2>
<pre><code>system_name/
├── _gal/                              # 项目配置目录
│   ├── adm.gxl                       # 系统管理配置
│   ├── work.gxl                      # 工作流环境配置
│   └── project.toml                  # 项目元数据配置
├── sys/                              # 系统定义目录
│   ├── sys_model.yml                 # 系统模型定义
│   ├── mod_list.yml                  # 模块列表定义
│   ├── vars.yml                      # 系统变量定义
│   ├── mods/                         # 模块本地化副本
│   │   ├── module1_name/
│   │   │   └── arm-mac14-host/       # 特定平台配置
│   │   │       ├── spec/             # 规范文件
│   │   │       ├── local/            # 本地化配置
│   │   │       ├── values/           # 值文件
│   │   │       ├── vars.yml          # 模块变量
│   │   │       ├── setting.yml       # 本地化设置
│   │   │       └── workflows/        # 模块工作流
│   │   └── module2_name/
│   │       └── x86-ubt22-k8s/        # 不同平台配置
│   │           └── [相同结构]
│   └── workflows/                    # 系统工作流定义
│       └── operators.gxl             # 系统操作符工作流
├── sys-prj.yml                       # 系统项目配置
├── version.txt                       # 系统版本信息
├── .gitignore                        # Git 忽略文件
└── test_res/                         # 测试资源目录
</code></pre>
<h2 id="目录说明"><a class="header" href="#目录说明">目录说明</a></h2>
<h3 id="_gal---项目配置目录"><a class="header" href="#_gal---项目配置目录"><code>_gal/</code> - 项目配置目录</a></h3>
<p>存储 Galaxy 项目的配置文件，包括版本管理、工作流定义和项目元数据。</p>
<p><strong>关键文件：</strong></p>
<ul>
<li><strong><code>adm.gxl</code></strong>: 系统管理配置，定义版本管理和发布流程</li>
<li><strong><code>work.gxl</code></strong>: 工作流环境配置，定义执行环境和参数</li>
<li><strong><code>project.toml</code></strong>: 项目元数据配置，包含项目基本信息</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>集中管理项目级别的配置</li>
<li>提供版本控制和发布管理</li>
<li>定义多环境执行配置</li>
</ul>
<h3 id="sys---系统定义目录"><a class="header" href="#sys---系统定义目录"><code>sys/</code> - 系统定义目录</a></h3>
<p>包含系统的核心定义文件和模块的本地化副本，是 Sys-Operator 的核心目录。</p>
<p><strong>关键文件：</strong></p>
<ul>
<li><strong><code>sys_model.yml</code></strong>: 系统模型定义，包含系统基本信息和目标环境</li>
<li><strong><code>mod_list.yml</code></strong>: 模块列表定义，包含系统包含的所有模块配置</li>
<li><strong><code>vars.yml</code></strong>: 系统变量定义，定义环境变量和配置参数</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>定义系统的基础架构</li>
<li>管理模块组合和依赖</li>
<li>配置系统级变量和参数</li>
</ul>
<h3 id="mods---模块本地化副本"><a class="header" href="#mods---模块本地化副本"><code>mods/</code> - 模块本地化副本</a></h3>
<p>存储系统中包含的各个模块的本地化配置和文件，这些是从模块源地址复制或下载而来的。</p>
<p><strong>子目录结构：</strong></p>
<pre><code>mods/
├── module_name/
│   └── platform_model/               # 平台特定配置
│       ├── spec/                    # 规范文件
│       ├── local/                   # 本地化配置
│       ├── values/                  # 值文件
│       ├── vars.yml                 # 模块变量
│       ├── setting.yml              # 本地化设置
│       └── workflows/               # 模块工作流
</code></pre>
<p><strong>平台命名规范：</strong></p>
<ul>
<li><code>arm-mac14-host</code>: Apple M1/M2 芯片，macOS 系统，Host 模式</li>
<li><code>x86-ubt22-host</code>: Intel/AMD x86，Ubuntu 22.04，Host 模式</li>
<li><code>x86-ubt22-k8s</code>: Intel/AMD x86，Ubuntu 22.04，Kubernetes 模式</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>存储模块的本地化配置</li>
<li>支持多平台部署</li>
<li>提供模块的定制化配置</li>
</ul>
<h3 id="workflows---系统工作流目录"><a class="header" href="#workflows---系统工作流目录"><code>workflows/</code> - 系统工作流目录</a></h3>
<p>包含系统级别的操作流程定义，使用 GXL 语言编写。</p>
<p><strong>关键文件：</strong></p>
<ul>
<li><strong><code>operators.gxl</code></strong>: 系统操作符工作流，定义系统的生命周期管理</li>
</ul>
<p><strong>工作流类型：</strong></p>
<ul>
<li><strong><code>init</code></strong>: 系统初始化</li>
<li><strong><code>update</code></strong>: 系统更新</li>
<li><strong><code>localize</code></strong>: 系统本地化</li>
<li><strong><code>install</code></strong>: 系统安装</li>
<li><strong><code>start</code></strong>: 系统启动</li>
<li><strong><code>stop</code></strong>: 系统停止</li>
<li><strong><code>status</code></strong>: 系统状态检查</li>
</ul>
<h3 id="其他重要文件"><a class="header" href="#其他重要文件">其他重要文件</a></h3>
<h4 id="sys-prjyml---系统项目配置"><a class="header" href="#sys-prjyml---系统项目配置"><code>sys-prj.yml</code> - 系统项目配置</a></h4>
<p>定义系统项目的完整配置，包括：</p>
<ul>
<li>测试环境配置</li>
<li>构建配置</li>
<li>发布配置</li>
<li>质量检查</li>
<li>安全配置</li>
<li>监控配置</li>
</ul>
<h4 id="versiontxt---系统版本信息"><a class="header" href="#versiontxt---系统版本信息"><code>version.txt</code> - 系统版本信息</a></h4>
<p>简单的文本文件，包含系统版本号：</p>
<pre><code>1.0.0
</code></pre>
<h2 id="文件组织原则"><a class="header" href="#文件组织原则">文件组织原则</a></h2>
<h3 id="1-按功能分类"><a class="header" href="#1-按功能分类">1. 按功能分类</a></h3>
<ul>
<li><strong>配置文件</strong>: 存储在项目根目录和 <code>_gal/</code> 目录</li>
<li><strong>系统定义</strong>: 存储在 <code>sys/</code> 目录</li>
<li><strong>模块文件</strong>: 存储在 <code>sys/mods/</code> 目录</li>
<li><strong>工作流文件</strong>: 存储在 <code>sys/workflows/</code> 目录</li>
<li><strong>测试资源</strong>: 存储在 <code>test_res/</code> 目录</li>
</ul>
<h3 id="3-层次结构"><a class="header" href="#3-层次结构">3. 层次结构</a></h3>
<ul>
<li><strong>项目级</strong>: 系统整体配置和元数据</li>
<li><strong>系统级</strong>: 系统定义和配置</li>
<li><strong>模块级</strong>: 模块具体配置和文件</li>
<li><strong>平台级</strong>: 特定平台的配置</li>
</ul>
<h2 id="最佳实践-3"><a class="header" href="#最佳实践-3">最佳实践</a></h2>
<h3 id="1-目录创建"><a class="header" href="#1-目录创建">1. 目录创建</a></h3>
<p>使用 <code>gsys new </code> 命令创建标准化的目录结构：</p>
<h3 id="2-目录维护"><a class="header" href="#2-目录维护">2. 目录维护</a></h3>
<ul>
<li>保持目录结构的标准化</li>
<li>遵循命名规范</li>
<li>定期清理无用文件</li>
<li>保持 .gitignore 文件的更新</li>
</ul>
<h3 id="3-文件组织"><a class="header" href="#3-文件组织">3. 文件组织</a></h3>
<ul>
<li>相关文件放在同一目录下</li>
<li>避免文件重复</li>
<li>使用合适的文件名</li>
<li>保持文件的版本控制</li>
</ul>
<h3 id="4-平台管理"><a class="header" href="#4-平台管理">4. 平台管理</a></h3>
<ul>
<li>为每个支持的创建相应平台目录</li>
<li>保持平台间配置的一致性</li>
<li>明确标记平台特定的配置</li>
</ul>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>Sys-Operator 的目录结构设计遵循了模块化、可维护性、可扩展性的原则。通过标准化的目录结构，可以有效地组织系统配置，管理模块依赖，并支持多平台部署。理解和遵循这个目录结构对于使用 Sys-Operator 至关重要。</p>
<hr />
<p><em>更多详情请参考 <a href="operator/sys/structure/./file-organization.html">文件组织方式</a> 和 <a href="operator/sys/structure/./naming-conventions.html">命名规范</a>。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件组织方式"><a class="header" href="#文件组织方式">文件组织方式</a></h1>
<h2 id="概述-6"><a class="header" href="#概述-6">概述</a></h2>
<p>本文档详细说明 Sys-Operator 中的文件组织方式，包括配置文件的结构、模块文件的存储、工作流文件的编排等，帮助你理解如何有效地组织和管理系统文件。</p>
<h2 id="配置文件组织"><a class="header" href="#配置文件组织">配置文件组织</a></h2>
<h3 id="1-系统级配置文件"><a class="header" href="#1-系统级配置文件">1. 系统级配置文件</a></h3>
<p>系统级配置文件存储在 <code>sys/</code> 目录下，定义整个系统的基础架构和配置。</p>
<h4 id="sys_modelyml---系统模型定义"><a class="header" href="#sys_modelyml---系统模型定义"><code>sys_model.yml</code> - 系统模型定义</a></h4>
<p><strong>文件作用</strong>: 定义系统的基本信息和目标运行环境</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础系统定义
name: system_name                    # 系统名称（必需）
model: arm-mac14-host               # 目标平台模型（必需）
vender: "Galaxy-Ops"                # 厂商信息（可选）
</code></pre>
<p><strong>命名规范</strong>:</p>
<ul>
<li>文件名必须为 <code>sys_model.yml</code></li>
<li>系统名称必须唯一且有意义</li>
<li>模型名称遵循 <code>arch-os-spc</code> 格式</li>
<li>版本号遵循语义化版本规范</li>
</ul>
<h4 id="mod_listyml---模块列表定义"><a class="header" href="#mod_listyml---模块列表定义"><code>mod_list.yml</code> - 模块列表定义</a></h4>
<p><strong>文件作用</strong>: 定义系统包含的所有模块及其配置</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础模块列表
- name: module_name                     # 模块名称（必需）
  addr:                                  # 模块地址（必需）
    repo: "https://github.com/user/repo" # Git 仓库（可选）
    tag: "v1.0.0"                        # 标签（可选）
    branch: "main"                       # 分支（可选）
    path: "./local/path"                 # 本地路径（可选）
  model: arm-mac14-host                 # 目标平台模型（必需）
  enable: true                           # 是否启用（可选，默认为 true）

# 高级模块配置
- name: advanced_module
  addr:
    repo: "https://github.com/user/module"
    tag: "v2.0.0"
  model: x86-ubt22-k8s
  enable: true
  setting:                              # 模块特定设置（可选）
    src: "${GXL_PRJ_ROOT}/sys/setting/module"
    dst: "${GXL_PRJ_ROOT}/sys/mods/module/local/"

</code></pre>
<p><strong>配置验证</strong>:</p>
<ul>
<li>模块名称不能重复</li>
<li>模块地址必须有效</li>
<li>模型必须存在</li>
<li>依赖关系不能形成循环</li>
</ul>
<h4 id="varsyml---系统变量定义"><a class="header" href="#varsyml---系统变量定义"><code>vars.yml</code> - 系统变量定义</a></h4>
<p><strong>文件作用</strong>: 定义系统级别的环境变量和配置参数</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础变量
vars:
- name: VARIABLE_NAME             # 变量名（必需）
  value: "default_value"          # 默认值（必需）
  desp: "变量描述"               # 描述（可选）

# 类型化变量
- name: INT_VAR
  type: integer                  # 数据类型（可选）
  min: 1                         # 最小值（可选）
  max: 100                       # 最大值（可选）
  value: 10

- name: BOOL_VAR
  type: boolean
  value: true

- name: ENUM_VAR
  type: enum                     # 枚举类型
  values: [opt1, opt2, opt3]     # 可选值（必需）
  value: opt1

- name: REGEX_VAR
  type: string
  pattern: "^[a-zA-Z]+$"         # 正则模式（必需）
  value: "valid_string"

# 分组变量
vars:
# 网络配置
- name: HTTP_PORT
  group: network
  value: 80

- name: HTTPS_PORT
  group: network
  value: 443

# 数据库配置
- name: DB_HOST
  group: database
  value: "localhost"

- name: DB_PORT
  group: database
  type: integer
  min: 1
  max: 65535
  value: 5432

# 环境变量替换
- name: CONFIG_PATH
  value: "${CONFIG_PATH:/etc/app/config}"

- name: DEBUG_MODE
  value: "${DEBUG_MODE:false}"

# 条件变量
- name: FEATURE_FLAG
  value: "${FEATURE_FLAG:default}"
</code></pre>
<h3 id="2-项目级配置文件"><a class="header" href="#2-项目级配置文件">2. 项目级配置文件</a></h3>
<p>项目级配置文件存储在 <code>_gal/</code> 目录下，定义项目级别的管理配置。</p>
<h4 id="_galadmgxl---系统管理配置"><a class="header" href="#_galadmgxl---系统管理配置"><code>_gal/adm.gxl</code> - 系统管理配置</a></h4>
<p><strong>文件作用</strong>: 定义系统的版本管理和发布配置</p>
<p><strong>配置结构</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 引入版本管理模块
extern mod ver,git,ver_adm {
    git = "https://github.com/galaxy-operators/cfm-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 环境定义
mod envs {
    env default {
        PKG_NAME = "your_system";        // 系统包名
        VERSION = "1.0.0";              // 系统版本
        MAINTAINER = "devops@example.com";
        DESCRIPTION = "System description";
    }

    env production {
        PKG_NAME = "production-system";
        VERSION = "1.0.0";
        MAINTAINER = "prod-team@example.com";
    }
}

// 主模块继承版本管理功能
mod main : ver_adm {
    // 版本信息任务
    #[task(name="version")]
    flow version {
        gx.echo("System version: ${VERSION}");
        gx.echo("Package name: ${PKG_NAME}");
        gx.echo("Maintainer: ${MAINTAINER}");
    }

    // 发布任务（可选）
    #[task(name="publish")]
    flow publish {
        gx.echo("Publishing system to registry...");
        // 发布逻辑
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="_galworkgxl---工作流环境配置"><a class="header" href="#_galworkgxl---工作流环境配置"><code>_gal/work.gxl</code> - 工作流环境配置</a></h4>
<p><strong>文件作用</strong>: 定义系统的工作流环境和执行配置</p>
<p><strong>配置结构</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 引入操作符和版本管理模块
extern mod operators { path = "./sys/workflows"; }
extern mod ver,git {
    git = "https://github.com/galaxy-operators/cfm-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 环境定义
mod envs {
    // 默认环境
    env default : _common {
        FORCE_FLAG = "";                // 强制标志
        LOG_LEVEL = "";                 // 日志级别
        SYS_BIN = "gsys";              // 系统管理器
        MOD_BIN = "gmod";              // 模块管理器
        SYS = "sys";                    // 系统标识
        MODULE_ENV = "default";         // 模块环境
    }

    // 强制执行环境
    env force {
        FORCE_FLAG = "-f 3";
        LOG_LEVEL = "--log debug";
    }

    // 生产环境
    env production {
        FORCE_FLAG = "-f 2";
        LOG_LEVEL = "--log info";
        MODULE_ENV = "production";
    }

    // 通用配置
    env _common {
        BUILD_PATH = "${GXL_PRJ_ROOT}/build";    // 构建路径
        DEPLOY_PATH = "${GXL_PRJ_ROOT}/deploy";   // 部署路径
    }
}

// 主模块继承操作符功能
mod main : operators {
    BUILD_PATH = "${GXL_PRJ_ROOT}/build";

    // 自动加载入口
    #[auto_load(entry)]
    flow ver.use | @_into_main {
        ENV_SYS_MODEL = ${DEFINE.MODEL};          // 设置系统模型
        ENV_PKG_NAME = ${DEFINE.NAME};             // 设置包名
    }

    // 主配置任务
    #[task(name="main conf")]
    flow conf {
        gx.echo("=== 开始系统配置 ===");

        // 更新系统配置
        gx.cmd ("${ENV_SYS_BIN} update ${ENV_LOG_LEVEL} ${ENV_FORCE_FLAG}");

        // 本地化系统配置
        gx.cmd ("${ENV_SYS_BIN} localize ${ENV_LOG_LEVEL}");

        gx.echo("=== 系统配置完成 ===");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-模块文件组织"><a class="header" href="#3-模块文件组织">3. 模块文件组织</a></h3>
<p>模块文件存储在 <code>sys/mods/</code> 目录下，每个模块有自己的本地化副本。</p>
<h4 id="模块目录结构-1"><a class="header" href="#模块目录结构-1">模块目录结构</a></h4>
<pre><code>sys/mods/
├── module_name/
│   └── platform_model/
│       ├── spec/                    # 规范文件
│       │   ├── module_spec.yml      # 模块规范
│       │   └── interfaces.yml       # 接口定义
│       ├── local/                   # 本地化配置
│       │   ├── config.yml           # 本地配置
│       │   ├── templates/            # 模板文件
│       │   └── scripts/             # 脚本文件
│       ├── values/                  # 值文件
│       │   ├── production.yml       # 生产环境值
│       │   ├── staging.yml          # 测试环境值
│       │   └── development.yml      # 开发环境值
│       ├── vars.yml                 # 模块变量
│       ├── setting.yml              # 本地化设置
│       └── workflows/               # 模块工作流
│           ├── install.gxl          # 安装工作流
│           ├── configure.gxl        # 配置工作流
│           └── start.gxl             # 启动工作流
</code></pre>
<h4 id="模块配置文件"><a class="header" href="#模块配置文件">模块配置文件</a></h4>
<p><strong><code>vars.yml</code> - 模块变量</strong>:</p>
<pre><code class="language-yaml"># 模块特定变量
vars:
- name: MODULE_VERSION
  value: "1.0.0"
  description: "模块版本"

- name: MODULE_TYPE
  value: "service"
  description: "模块类型"

- name: MODULE_PORT
  type: integer
  min: 1
  max: 65535
  value: 8080
  description: "服务端口"

</code></pre>
<p><strong><code>setting.yml</code> - 本地化设置</strong>:</p>
<pre><code class="language-yaml">TODO
</code></pre>
<h4 id="模块工作流文件"><a class="header" href="#模块工作流文件">模块工作流文件</a></h4>
<p><strong><code>workflows/install.gxl</code> - 安装工作流</strong>:</p>
<pre><code class="language-gxl">// 模块安装工作流
mod install {
    // 安装任务
    #[task(name="module_install")]
    flow install {
        gx.echo("=== 开始模块安装 ===");
        gx.echo("模块名称: ${MODULE.NAME}");
        gx.echo("模块版本: ${MODULE.VERSION}");

        // 预检查
        gx.echo("1. 执行预检查...");
        gx.pre_check();

        // 依赖安装
        gx.echo("2. 安装依赖...");
        gx.install_dependencies();

        // 配置文件
        gx.echo("3. 配置文件...");
        gx.configure();

        // 验证安装
        gx.echo("4. 验证安装...");
        gx.validate();

        gx.echo("=== 模块安装完成 ===");
    }
}
</code></pre>
<h3 id="4-工作流文件组织"><a class="header" href="#4-工作流文件组织">4. 工作流文件组织</a></h3>
<p>系统工作流文件存储在 <code>sys/workflows/</code> 目录下。</p>
<h4 id="operatorsgxl---系统操作符工作流"><a class="header" href="#operatorsgxl---系统操作符工作流"><code>operators.gxl</code> - 系统操作符工作流</a></h4>
<p><strong>文件作用</strong>: 定义系统级别的操作流程</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-gxl">TODO
</code></pre>
<h3 id="5-项目配置文件"><a class="header" href="#5-项目配置文件">5. 项目配置文件</a></h3>
<p><code>sys-prj.yml</code> - 系统项目配置</p>
<p><strong>文件作用</strong>: 定义系统项目的完整配置</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础项目配置
name: "Production Web System"               # 系统项目名称
version: "1.0.0"                           # 项目版本
description: "Production web application system with monitoring"

# 测试环境配置
test_envs:
  dep_root: "./test_deps"                   # 依赖根目录
  deps:
    - addr:
        repo: https://github.com/galaxy-operators/bitnami-common.git
      local: ./test_res/bit-common          # 本地路径
      rename: bit-common                    # 重命名
      enable: true                          # 是否启用




</code></pre>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>Sys-Operator 的文件组织方式遵循了模块化、标准化、可维护性的原则。通过合理的文件结构和配置组织，可以有效管理系统配置，提高开发效率，降低维护成本。理解并遵循这些文件组织方式对于有效使用 Sys-Operator 至关重要。</p>
<hr />
<p><em>更多详情请参考 <a href="operator/sys/structure/./directory.html">目录结构</a> 和 <a href="operator/sys/structure/./naming-conventions.html">命名规范</a>。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h1>
<h2 id="概述-7"><a class="header" href="#概述-7">概述</a></h2>
<p>本文档详细说明 Sys-Operator 中的命名规范，包括文件名、变量名、模块名、系统名等的命名约定，帮助你保持命名的一致性和可读性。</p>
<h2 id="命名原则"><a class="header" href="#命名原则">命名原则</a></h2>
<h3 id="1-可读性原则"><a class="header" href="#1-可读性原则">1. 可读性原则</a></h3>
<p><strong>目标</strong>: 命名应该清晰表达其用途，便于理解和维护。</p>
<p><strong>规则</strong>:</p>
<ul>
<li>使用有意义的名称，避免缩写和模糊的词汇</li>
<li>名称应该自解释，减少额外的注释需求</li>
<li>保持名称的简洁性，不过度冗长</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的命名
name: "production_web_system"
name: "user_management_service"
name: "database_connection_pool"

# 不好的命名
name: "prod_sys"         # 缩写不清晰
name: "system_1"         # 无意义
name: "usermgmt_service" # 缩写不规范
</code></pre>
<h3 id="2-一致性原则"><a class="header" href="#2-一致性原则">2. 一致性原则</a></h3>
<p><strong>目标</strong>: 保持整个项目命名风格的一致性。</p>
<p><strong>规则</strong>:</p>
<ul>
<li>统一的命名风格（全小写、驼峰、下划线等）</li>
<li>相同概念使用相同的术语</li>
<li>遵循项目的现有命名约定</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 一致的命名风格
vars:
  - name: database_host           # 下划线分隔
  - name: database_port
  - name: database_name

# 不一致的命名风格
vars:
  - name: databaseHost           # 混合风格
  - name: DB_PORT                # 大写缩写
  - name: databaseName           # 驼峰命名
</code></pre>
<h3 id="3-可扩展性原则"><a class="header" href="#3-可扩展性原则">3. 可扩展性原则</a></h3>
<p><strong>目标</strong>: 命名应该支持项目的扩展和演进。</p>
<p><strong>规则</strong>:</p>
<ul>
<li>避免硬编码的数字和版本</li>
<li>使用通用的术语，便于复用</li>
<li>支持多环境和多部署</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 可扩展的命名
name: "web_application_system"    # 通用的名称
name: "microservice_platform"      # 可扩展的平台名称

# 不可扩展的命名
name: "system_v2_1_production   # 硬编码版本
name: "legacy_app_deprecated     # 硬编码状态
</code></pre>
<h2 id="文件命名规范"><a class="header" href="#文件命名规范">文件命名规范</a></h2>
<h3 id="1-配置文件"><a class="header" href="#1-配置文件">1. 配置文件</a></h3>
<p><strong>YAML 配置文件</strong>:</p>
<pre><code>sys_model.yml           # 系统模型定义（必需）
mod_list.yml            # 模块列表定义（必需）
vars.yml               # 系统变量定义（必需）
admin-config.gxl       # 系统管理配置（推荐）
work-config.gxl        # 工作流环境配置（推荐）
project-config.toml    # 项目配置（推荐）
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>多个单词用下划线分隔</li>
<li>扩展名表示文件格式（.yml, .gxl, .toml）</li>
<li>文件名应该反映文件内容</li>
</ul>
<p><strong>错误示例</strong>:</p>
<pre><code>SysModel.yaml          # 大写字母和错误扩展名
model_list.yml         # 缩写不清晰
config.yml             # 过于通用
system_configs.yml     # 复数形式不必要
</code></pre>
<h3 id="2-工作流文件"><a class="header" href="#2-工作流文件">2. 工作流文件</a></h3>
<p><strong>GXL 工作流文件</strong>:</p>
<pre><code>operators.gxl          # 系统操作符工作流（必需）
system-workflows.gxl   # 系统工作流（可选）
module-workflows.gxl   # 模块工作流（可选）
custom-workflows.gxl   # 自定义工作流（可选）
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>工作流文件应该以 <code>-workflows.gxl</code> 结尾</li>
<li>自定义工作流应该有明确的前缀</li>
<li>系统级和模块级工作流应该区分</li>
</ul>
<h3 id="3-模块文件"><a class="header" href="#3-模块文件">3. 模块文件</a></h3>
<p><strong>模块目录名</strong>:</p>
<pre><code>sys/mods/
├── web_server/
├── database_server/
├── cache_manager/
├── message_queue/
├── load_balancer/
└── monitoring_agent/
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>多个单词用下划线分隔</li>
<li>描述性名称，明确模块功能</li>
<li>避免缩写和简写</li>
</ul>
<h3 id="4-平台目录名"><a class="header" href="#4-平台目录名">4. 平台目录名</a></h3>
<p><strong>平台模型目录</strong>:</p>
<pre><code>arm-mac14-host
x86-ubt22-host
x86-ubt22-k8s
x86-centos8-host
arm-linux-k8s
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>格式：<code>arch-os-spc</code></li>
<li>架构：<code>arm</code>, <code>x86</code>, <code>amd64</code></li>
<li>操作系统：<code>mac14</code>, <code>ubt22</code>, <code>centos8</code>, <code>linux</code></li>
<li>环境：<code>host</code>, <code>k8s</code>, <code>docker</code></li>
</ul>
<h2 id="变量命名规范"><a class="header" href="#变量命名规范">变量命名规范</a></h2>
<h3 id="1-系统变量"><a class="header" href="#1-系统变量">1. 系统变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用全大写字母</li>
<li>单词间用下划线分隔</li>
<li>前缀标识变量类型</li>
<li>包含适当的命名空间</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 系统配置
- name: SYSTEM_NAME
  value: "production_system"

- name: SYSTEM_VERSION
  value: "1.0.0"

- name: SYSTEM_ENVIRONMENT
  value: "production"

# 网络配置
- name: NETWORK_HOST
  value: "localhost"

- name: NETWORK_PORT
  value: 8080

- name: NETWORK_PROTOCOL
  value: "https"

# 数据库配置
- name: DATABASE_HOST
  value: "postgres-primary"

- name: DATABASE_PORT
  value: 5432

- name: DATABASE_NAME
  value: "production_db"

# 安全配置
- name: SECURITY_ENCRYPTION_KEY
  value: "generated_key_here"

- name: SECURITY_SSL_CERT_PATH
  value: "/etc/ssl/certs/server.crt"

# 性能配置
- name: PERFORMANCE_MAX_THREADS
  value: 100

- name: PERFORMANCE_MEMORY_LIMIT
  value: "4GB"
</code></pre>
<h3 id="2-模块变量"><a class="header" href="#2-模块变量">2. 模块变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>模块名作为前缀</li>
<li>跟随具体的配置项</li>
<li>使用统一的术语</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># web_server 模块变量
vars:
  - name: WEB_SERVER_PORT
    value: 80

  - name: WEB_SERVER_SSL_PORT
    value: 443

  - name: WEB_SERVER_WORKERS
    value: 4

  - name: WEB_SERVER_KEEP_ALIVE
    value: "75s"

# database_server 模块变量
vars:
  - name: DATABASE_SERVER_HOST
    value: "db-primary"

  - name: DATABASE_SERVER_PORT
    value: 5432

  - name: DATABASE_SERVER_MAX_CONNECTIONS
    value: 100

  - name: DATABASE_SERVER_TIMEOUT
    value: "30s"
</code></pre>
<h3 id="3-环境变量"><a class="header" href="#3-环境变量">3. 环境变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>支持环境变量替换</li>
<li>使用默认值语法</li>
<li>变量名与配置名对应</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 环境变量替换
vars:
  - name: DATABASE_HOST
    value: "${DATABASE_HOST:localhost}"

  - name: DATABASE_PORT
    value: "${DATABASE_PORT:5432}"

  - name: ENABLE_DEBUG
    value: "${ENABLE_DEBUG:false}"

  - name: LOG_LEVEL
    value: "${LOG_LEVEL:info}"

  - name: CONFIG_PATH
    value: "${CONFIG_PATH:/etc/app/config}"

  - name: API_KEY
    value: "${API_KEY}"
</code></pre>
<h3 id="4-分组变量"><a class="header" href="#4-分组变量">4. 分组变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用 <code>group</code> 字段进行分类</li>
<li>组名与功能相关</li>
<li>组内变量命名保持一致</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 按功能分组的变量
vars:
# 网络配置组
- name: HTTP_PORT
  group: network
  value: 80

- name: HTTPS_PORT
  group: network
  value: 443

- name: DOMAIN_NAME
  group: network
  value: "example.com"

# 数据库配置组
- name: DB_HOST
  group: database
  value: "postgres"

- name: DB_PORT
  group: database
  value: 5432

- name: DB_NAME
  group: database
  value: "app_db"

# 安全配置组
- name: ENABLE_SSL
  group: security
  value: true

- name: SSL_CERT_PATH
  group: security
  value: "/etc/ssl/certs/server.crt"

- name: SSL_KEY_PATH
  group: security
  value: "/etc/ssl/private/server.key"

# 监控配置组
- name: ENABLE_MONITORING
  group: monitoring
  value: true

- name: METRICS_PORT
  group: monitoring
  value: 9090

- name: LOG_LEVEL
  group: monitoring
  value: "info"
</code></pre>
<h2 id="模块命名规范"><a class="header" href="#模块命名规范">模块命名规范</a></h2>
<h3 id="1-模块名"><a class="header" href="#1-模块名">1. 模块名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>描述性名称</li>
<li>避免缩写</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的模块名
- name: web_server
- name: database_server
- name: cache_manager
- name: message_queue
- name: load_balancer
- name: monitoring_agent
- name: file_storage
- name: authentication_service

# 不好的模块名
- name: web
- name: db
- name: cache
- name: mq
- name: lb
- name: monitor
- name: storage
- name: auth
</code></pre>
<h3 id="2-模块类型"><a class="header" href="#2-模块类型">2. 模块类型</a></h3>
<p><strong>常用模块类型</strong>:</p>
<pre><code>server      # 服务器服务
client      # 客户端服务
proxy       # 代理服务
gateway     # 网关服务
cache       # 缓存服务
storage     # 存储服务
queue       # 消息队列
monitor     # 监控服务
security    # 安全服务
network     # 网络服务
</code></pre>
<p><strong>命名模式</strong>:</p>
<ul>
<li><code>{function}_{type}</code>: <code>web_server</code>, <code>database_server</code></li>
<li><code>{type}_{service}</code>: <code>cache_redis</code>, <code>queue_rabbitmq</code></li>
<li><code>{service}_{tool}</code>: <code>monitor_grafana</code>, <code>security_consul</code></li>
</ul>
<h2 id="系统命名规范"><a class="header" href="#系统命名规范">系统命名规范</a></h2>
<h3 id="1-系统名"><a class="header" href="#1-系统名">1. 系统名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>描述性名称</li>
<li>包含环境标识（可选）</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 生产环境
name: production_web_system
name: staging_api_gateway
name: development_database_cluster

# 开发环境
name: dev_web_system
name: test_user_service
name: local_message_queue

# 通用环境
name: microservice_platform
name: data_processing_system
name: enterprise_application
</code></pre>
<h3 id="2-系统标识"><a class="header" href="#2-系统标识">2. 系统标识</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>系统名作为基础</li>
<li>添加环境前缀（可选）</li>
<li>添加版本标识（可选）</li>
</ul>
<p><strong>标识格式</strong>:</p>
<pre><code>{environment}_{system_name}_{version}
</code></pre>
<p><strong>示例</strong>:</p>
<pre><code>prod_web_system_v1.0.0
staging_api_gateway_v2.1.0
dev_database_cluster_v0.9.0
</code></pre>
<h2 id="工作流命名规范"><a class="header" href="#工作流命名规范">工作流命名规范</a></h2>
<h3 id="1-任务名"><a class="header" href="#1-任务名">1. 任务名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用动词开头</li>
<li>描述具体操作</li>
<li>动词+名词结构</li>
</ul>
<p><strong>常用动词</strong>:</p>
<pre><code>install     # 安装
start       # 启动
stop        # 停止
restart     # 重启
update      # 更新
configure   # 配置
deploy      # 部署
backup      # 备份
restore     # 恢复
validate    # 验证
check       # 检查
monitor     # 监控
</code></pre>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl"># 好的任务名
#[task(name="install_service")]
#[task(name="start_application")]
#[task(name="stop_database")]
#[task(name="update_config")]
#[task(name="deploy_system")]
#[task(name="validate_environment")]

# 不好的任务名
#[task(name="install")]        # 过于简单
#[task(name="do_start")]        # 冗余
#[task(name="run_installer")]   # 间接
</code></pre>
<h3 id="2-流程名"><a class="header" href="#2-流程名">2. 流程名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用多个单词</li>
<li>描述完整流程</li>
<li>包含系统标识</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl"># 系统操作流程
flow system_installation
flow system_configuration
flow system_deployment
flow system_monitoring

# 模块操作流程
flow module_initialization
flow module_configuration
flow module_deployment
flow module_validation
</code></pre>
<h2 id="gxl-元素命名规范"><a class="header" href="#gxl-元素命名规范">GXL 元素命名规范</a></h2>
<h3 id="1-变量名"><a class="header" href="#1-变量名">1. 变量名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用大写字母</li>
<li>单词间用下划线分隔</li>
<li>描述变量内容</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl">// 系统配置变量
let SYSTEM_NAME = "web_system"
let SYSTEM_MODEL = "arm-mac14-host"
let MODULE_COUNT = 5

// 环境变量
let ENVIRONMENT = "production"
let LOG_LEVEL = "info"
let FORCE_FLAG = ""

// 路径变量
let PROJECT_ROOT = "${GXL_PRJ_ROOT}"
let CONFIG_PATH = "${PROJECT_ROOT}/config"
let DEPLOY_PATH = "${PROJECT_ROOT}/deploy"
</code></pre>
<h3 id="2-函数名"><a class="header" href="#2-函数名">2. 函数名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用动词+名词结构</li>
<li>动词用现在时</li>
<li>描述函数功能</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl">// 检查函数
function check_environment()
function check_dependencies()
function check_health()

// 安装函数
function install_system()
function install_module(module_name)
function install_dependencies()

// 配置函数
function configure_system()
function configure_module(module)
function apply_settings()

// 工具函数
function read_file(file_path)
function write_file(file_path, content)
function validate_config()
</code></pre>
<h3 id="3-标签名"><a class="header" href="#3-标签名">3. 标签名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>标签语义明确</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl">// 系统标签
label system_initialized
label system_running
label system_stopped
label system_error

// 模块标签
label module_installed
label module_started
label module_stopped
label module_failed

// 流程标签
label installation_complete
label deployment_successful
label validation_passed
label configuration_applied
</code></pre>
<h2 id="避免的命名模式"><a class="header" href="#避免的命名模式">避免的命名模式</a></h2>
<h3 id="1-不推荐的命名"><a class="header" href="#1-不推荐的命名">1. 不推荐的命名</a></h3>
<p><strong>避免使用</strong>:</p>
<ul>
<li>单字符变量名（a, b, c）</li>
<li>缩写不明确的名称（cfg, tmp, var）</li>
<li>硬编码数字和版本</li>
<li>保留关键字和特殊字符</li>
<li>过于通用的名称</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 不推荐的命名
- name: a                    # 单字符
- name: cfg                  # 缩写不明确
- name: v1                  # 硬编码版本
- name: temp_123             # 临时编号
- name: system               # 过于通用
- name: config               # 过于通用
- name: data                 # 过于通用
</code></pre>
<h3 id="2-特殊字符和保留字"><a class="header" href="#2-特殊字符和保留字">2. 特殊字符和保留字</a></h3>
<p><strong>避免使用的字符</strong>:</p>
<ul>
<li>空格和特殊字符</li>
<li>连字符（-）</li>
<li>斜杠（/）</li>
<li>点号（.）开头或结尾</li>
<li>保留关键字</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 错误的命名
- name: web server          # 包含空格
- name: api-gateway        # 使用连字符
- name: config/backup       # 包含斜杠
- name: .hidden            # 以点号开头
- name: system$            # 包含特殊字符
- name: null               # 保留关键字
</code></pre>
<h2 id="命名验证工具"><a class="header" href="#命名验证工具">命名验证工具</a></h2>
<h3 id="1-自动验证脚本"><a class="header" href="#1-自动验证脚本">1. 自动验证脚本</a></h3>
<p><strong>bash 脚本示例</strong>:</p>
<pre><code class="language-bash">#!/bin/bash

# 验证 YAML 配置文件
validate_naming_conventions() {
    local file=$1
    local errors=0
    
    # 检查变量名
    if [[ $file == *"vars.yml" ]]; then
        local invalid_vars=$(yq eval '.vars[] | select(.name | ascii_downcase != .name)' "$file")
        if [[ -n "$invalid_vars" ]]; then
            echo "错误: 变量名必须全小写"
            echo "$invalid_vars"
            errors=$((errors + 1))
        fi
    fi
    
    # 检查模块名
    if [[ $file == *"mod_list.yml" ]]; then
        local invalid_modules=$(yq eval '.[] | select(.name | ascii_downcase != .name)' "$file")
        if [[ -n "$invalid_modules" ]]; then
            echo "错误: 模块名必须全小写"
            echo "$invalid_modules"
            errors=$((errors + 1))
        fi
    fi
    
    return $errors
}

# 验证所有配置文件
for file in sys/*.yml; do
    if [[ -f "$file" ]]; then
        echo "验证文件: $file"
        validate_naming_conventions "$file"
        if [[ $? -eq 0 ]]; then
            echo "✓ 通过验证"
        else
            echo "✗ 验证失败"
        fi
    fi
done
</code></pre>
<h3 id="2-集成验证"><a class="header" href="#2-集成验证">2. 集成验证</a></h3>
<p><strong>Git 钩子示例</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

# 检查提交的文件是否包含配置文件
changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(yml|gxl)$')

if [[ -n "$changed_files" ]]; then
    echo "验证命名规范..."
    
    for file in $changed_files; do
        echo "检查文件: $file"
        
        # 执行命名规范检查
        if ! validate_naming_conventions "$file"; then
            echo "错误: $file 不符合命名规范"
            exit 1
        fi
    done
fi

echo "命名规范验证通过"
</code></pre>
<h2 id="最佳实践-4"><a class="header" href="#最佳实践-4">最佳实践</a></h2>
<h3 id="1-创建命名规范文档"><a class="header" href="#1-创建命名规范文档">1. 创建命名规范文档</a></h3>
<p><strong>内容建议</strong>:</p>
<ul>
<li>项目特定的命名规则</li>
<li>术语表和缩写定义</li>
<li>示例和反例</li>
<li>验证工具使用方法</li>
<li>维护更新策略</li>
</ul>
<h3 id="2-自动化验证"><a class="header" href="#2-自动化验证">2. 自动化验证</a></h3>
<p><strong>工具集成</strong>:</p>
<ul>
<li>CI/CD 流水线集成</li>
<li>代码审查工具集成</li>
<li>文档生成工具集成</li>
<li>开发环境配置集成</li>
</ul>
<h3 id="3-定期审查"><a class="header" href="#3-定期审查">3. 定期审查</a></h3>
<p><strong>审查频率</strong>:</p>
<ul>
<li>新功能开发时</li>
<li>代码审查阶段</li>
<li>版本发布前</li>
<li>定期维护更新</li>
</ul>
<h3 id="4-团队协作"><a class="header" href="#4-团队协作">4. 团队协作</a></h3>
<p><strong>团队实践</strong>:</p>
<ul>
<li>命名规范培训</li>
<li>代码审查重点</li>
<li>示例代码库</li>
<li>常见问题解答</li>
</ul>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>良好的命名规范是项目成功的重要因素。Sys-Operator 的命名规范注重可读性、一致性和可扩展性，通过清晰的命名约定可以：</p>
<ul>
<li>提高代码可读性和维护性</li>
<li>减少沟通成本和理解误差</li>
<li>支持项目的长期演进</li>
<li>便于团队协作和代码审查</li>
<li>提供更好的开发体验</li>
</ul>
<p>遵循这些命名规范，并与团队保持一致的命名约定，将有助于建立高质量、可维护的系统配置。</p>
<hr />
<p><em>更多详情请参考 <a href="operator/sys/structure/./directory.html">目录结构</a> 和 <a href="operator/sys/structure/./file-organization.html">文件组织方式</a>。</em></p>
<div style="break-before: page; page-break-before: always;"></div><p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-开发指南"><a class="header" href="#mod-operator-开发指南">Mod-Operator 开发指南</a></h1>
<h2 id="概述-8"><a class="header" href="#概述-8">概述</a></h2>
<p>Mod-Operator 是 Galaxy Ops 框架的核心组件，用于定义和管理可复用的运维模块。每个 Mod-Operator 代表一个独立的软件组件或服务，包含完整的生命周期管理能力，包括安装、配置、启动、停止、监控等操作。</p>
<h3 id="核心特性"><a class="header" href="#核心特性">核心特性</a></h3>
<ul>
<li><strong>多平台支持</strong>: 支持不同的 CPU 架构、操作系统和运行环境组合</li>
<li><strong>模块化设计</strong>: 每个模块都是独立的，可单独开发和版本管理</li>
<li><strong>工作流驱动</strong>: 使用 GXL 语言定义复杂的运维操作流程</li>
<li><strong>模板本地化</strong>: 支持配置模板渲染和环境适配</li>
<li><strong>依赖管理</strong>: 处理模块间的依赖关系</li>
<li><strong>构件管理</strong>: 统一的软件包下载、缓存和分发机制</li>
</ul>
<h3 id="在-galaxy-ops-生态系统中的位置"><a class="header" href="#在-galaxy-ops-生态系统中的位置">在 Galaxy Ops 生态系统中的位置</a></h3>
<pre><code>gmod (创建模块) → gsys (组合系统) → gops (工程管理) → gflow (执行工作流)
</code></pre>
<p>Mod-Operator 是整个运维体系的基础构建块，由 <code>gmod</code> 工具创建和管理，最终通过 <code>gflow</code> 执行具体的运维操作。</p>
<h2 id="文档索引"><a class="header" href="#文档索引">文档索引</a></h2>
<p>本指南被拆分为以下文档以便于维护：</p>
<ul>
<li><strong><a href="operator/mod/./CONFIGURATION.html">配置说明</a></strong> - 核心配置文件详细说明</li>
<li><strong><a href="operator/mod/./DEVELOPMENT.html">开发指南</a></strong> - 开发工作流和最佳实践</li>
<li><strong><a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a></strong> - 调试和故障排除</li>
<li><strong><a href="operator/mod/./REFERENCE.html">API 参考</a></strong> - API 和枚举参考</li>
</ul>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<h3 id="创建新模块"><a class="header" href="#创建新模块">创建新模块</a></h3>
<pre><code class="language-bash"># 创建基础模块
gmod new postgresql

# 创建带目标的模块
gmod new postgresql --targets arm-mac14-host,x86-ubt22-k8s

# 从模板创建
gmod new postgresql --template database
</code></pre>
<h3 id="基本文件结构"><a class="header" href="#基本文件结构">基本文件结构</a></h3>
<pre><code>module_name/
├── mod/                              # 模块定义目录
│   ├── arm-mac14-host/              # ARM + macOS14 + Host 环境
│   │   ├── _gal/                    # 项目配置目录
│   │   ├── local/                   # 本地化生成的配置
│   │   ├── spec/                    # 规范文件目录
│   │   ├── values/                  # 值文件目录
│   │   ├── vars.yml                 # 变量定义
│   │   ├── setting.yml              # 本地化设置
│   │   └── workflows/               # 工作流定义
│   └── x86-ubt22-k8s/              # x86 + Ubuntu22 + K8s 环境
│       └── [相同的子目录结构]
├── mod-prj.yml                      # 模块项目配置
├── version.txt                      # 版本文件
├── .gitignore                       # Git 忽略文件
└── test_res/                        # 测试资源目录
</code></pre>
<h3 id="支持的目标平台"><a class="header" href="#支持的目标平台">支持的目标平台</a></h3>
<div class="table-wrapper"><table><thead><tr><th>组合</th><th>CPU架构</th><th>操作系统</th><th>运行环境</th><th>适用场景</th></tr></thead><tbody>
<tr><td><code>arm-mac14-host</code></td><td>ARM</td><td>macOS 14+</td><td>Host 宿主机</td><td>Apple Silicon Mac 本地开发</td></tr>
<tr><td><code>x86-ubt22-host</code></td><td>x86_64</td><td>Ubuntu 22.04</td><td>Host 宿主机</td><td>Linux 服务器本地部署</td></tr>
<tr><td><code>x86-ubt22-k8s</code></td><td>x86_64</td><td>Ubuntu 22.04</td><td>Kubernetes</td><td>K8s 集群容器化部署</td></tr>
</tbody></table>
</div>
<h2 id="开发工作流"><a class="header" href="#开发工作流">开发工作流</a></h2>
<h3 id="1-定义模块规范"><a class="header" href="#1-定义模块规范">1. 定义模块规范</a></h3>
<ul>
<li>编辑 <code>spec/artifact.yml</code> - 构件定义</li>
<li>编辑 <code>spec/depends.yml</code> - 依赖定义</li>
</ul>
<h3 id="2-配置变量"><a class="header" href="#2-配置变量">2. 配置变量</a></h3>
<ul>
<li>编辑 <code>vars.yml</code> - 变量定义</li>
<li>编辑 <code>values/_value.yml</code> - 默认值</li>
</ul>
<h3 id="3-编写工作流"><a class="header" href="#3-编写工作流">3. 编写工作流</a></h3>
<ul>
<li>编辑 <code>workflows/operators.gxl</code> - 使用 GXL 定义工作流</li>
</ul>
<h3 id="4-测试和验证"><a class="header" href="#4-测试和验证">4. 测试和验证</a></h3>
<ul>
<li>使用 <code>gflow</code> 测试工作流</li>
<li>使用 <code>gmod validate</code> 验证配置</li>
</ul>
<h3 id="5-本地化模块"><a class="header" href="#5-本地化模块">5. 本地化模块</a></h3>
<ul>
<li>使用 <code>gmod localize</code> 生成特定环境配置</li>
</ul>
<h2 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h2>
<h3 id="modelstd-标准型号"><a class="header" href="#modelstd-标准型号">ModelSTD 标准型号</a></h3>
<p>Mod-Operator 使用 <code>ModelSTD</code> 标准型号来定义目标平台，格式为 <code>arch-os-spc</code>：</p>
<ul>
<li><strong>CPU 架构</strong>: X86 (x86_64), ARM</li>
<li><strong>操作系统</strong>: MAC14 (macOS 14+), UBT22 (Ubuntu 22.04), WIN10 (Windows 10+), COS7 (CentOS 7)</li>
<li><strong>运行空间</strong>: Host (宿主机环境), K8S (Kubernetes 环境)</li>
</ul>
<h3 id="构件管理"><a class="header" href="#构件管理">构件管理</a></h3>
<p>构件定义了模块所需的软件包和下载资源，包括：</p>
<ul>
<li>名称 (name)</li>
<li>版本 (version)</li>
<li>原始地址 (origin_addr)</li>
<li>缓存地址 (cache_addr)</li>
<li>缓存启用 (cache_enable)</li>
<li>本地文件名 (local)</li>
</ul>
<h3 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h3>
<p>模块可以依赖其他模块或资源，支持：</p>
<ul>
<li>本地路径依赖</li>
<li>Git 仓库依赖</li>
<li>条件依赖（根据变量启用/禁用）</li>
<li>版本约束</li>
</ul>
<h3 id="工作流引擎"><a class="header" href="#工作流引擎">工作流引擎</a></h3>
<p>使用 GXL (Galaxy eXecution Language) 定义运维操作：</p>
<ul>
<li>支持任务定义和执行</li>
<li>变量模板渲染</li>
<li>条件分支和循环</li>
<li>外部命令执行</li>
<li>错误处理和重试机制</li>
</ul>
<h2 id="相关工具"><a class="header" href="#相关工具">相关工具</a></h2>
<ul>
<li><strong>gmod</strong>: 模块创建和管理工具</li>
<li><strong>gops</strong>: 工程管理工具</li>
<li><strong>gflow</strong>: 工作流执行工具</li>
<li><strong>gsys</strong>: 系统组合工具</li>
</ul>
<h2 id="更多信息"><a class="header" href="#更多信息">更多信息</a></h2>
<p>查看详细文档：</p>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./DEVELOPMENT.html">开发指南</a> - 开发最佳实践</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>📖 <a href="operator/mod/./EXAMPLES.html">示例参考</a> - 完整的模块示例</li>
<li>📖 <a href="operator/mod/./REFERENCE.html">API 参考</a> - API 和枚举定义</li>
</ul>
<hr />
<p><em>Mod-Operator 是 Galaxy Ops 框架的核心构建块，通过标准化的文件结构、配置管理和工作流定义，实现了软件组件的模块化运维管理。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-开发指南-1"><a class="header" href="#mod-operator-开发指南-1">Mod-Operator 开发指南</a></h1>
<p>本文档详细介绍 Mod-Operator 的开发工作流程、最佳实践和技巧，帮助开发者高效地创建高质量的运维模块。</p>
<h2 id="开发工作流-1"><a class="header" href="#开发工作流-1">开发工作流</a></h2>
<h3 id="1-创建新模块"><a class="header" href="#1-创建新模块">1. 创建新模块</a></h3>
<p>使用 <code>gmod</code> 工具快速创建新模块的骨架结构。</p>
<h4 id="基础模块创建"><a class="header" href="#基础模块创建">基础模块创建</a></h4>
<pre><code class="language-bash"># 创建基础模块
//fix: use gmod cmd and args

</code></pre>
<h4 id="生成的模块结构"><a class="header" href="#生成的模块结构">生成的模块结构</a></h4>
<pre><code class="language-bash">postgresql/
├── mod/
│   ├── arm-mac14-host/
│   │   ├── spec/
│   │   │   ├── artifact.yml
│   │   │   └── depends.yml
│   │   ├── vars.yml
│   │   ├── setting.yml
│   │   ├── values/
│   │   │   ├── _value.yml
│   │   │   └── _used.yml
│   │   ├── workflows/
│   │   │   └── operators.gxl
│   │   └── _gal/
│   │       ├── work.gxl
│   │       └── project.toml
│   └── x86-ubt22-k8s/
│       └── [相同结构]
├── mod-prj.yml
├── version.txt
├── .gitignore
└── README.md
</code></pre>
<h3 id="2-模块开发步骤"><a class="header" href="#2-模块开发步骤">2. 模块开发步骤</a></h3>
<h4 id="步骤-1定义构件和依赖"><a class="header" href="#步骤-1定义构件和依赖">步骤 1：定义构件和依赖</a></h4>
<p>编辑 <code>spec/artifact.yml</code> 和 <code>spec/depends.yml</code>：</p>
<pre><code class="language-bash"># 编辑构件配置
vim mod/arm-mac14-host/spec/artifact.yml

# 编辑依赖配置
vim mod/arm-mac14-host/spec/depends.yml
</code></pre>
<p><strong>artifact.yml 示例：</strong></p>
<pre><code class="language-yaml">- name: postgresql
  version: 17.4
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz

- name: pcre
  version: 8.45
  origin_addr:
    url: https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz
  local: pcre-8.45.tar.gz
</code></pre>
<p><strong>depends.yml 示例：</strong></p>
<pre><code class="language-yaml">dep_root: ./depends

deps:
- addr:
    path: ./common_libs
  local: common_libs
  enable: true

- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "3.0.0"
  local: openssl
  enable: true
</code></pre>
<h4 id="步骤-2配置变量和默认值"><a class="header" href="#步骤-2配置变量和默认值">步骤 2：配置变量和默认值</a></h4>
<p>编辑变量配置文件：</p>
<pre><code class="language-bash"># 定义环境变量
vim mod/arm-mac14-host/vars.yml

</code></pre>
<p><strong>vars.yml 示例：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  desp: "数据库端口号"
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: MAX_CONNECTIONS
  type: integer
  min: 1
  max: 1000
  value: 100

- name: DATA_DIR
  value: "/var/lib/postgresql"

- name: ENABLE_SSL
  type: boolean
  value: false
</code></pre>
<h4 id="步骤-3编写工作流"><a class="header" href="#步骤-3编写工作流">步骤 3：编写工作流</a></h4>
<p>编辑 <code>workflows/operators.gxl</code> 定义运维操作：</p>
<pre><code class="language-bash"># 编写操作工作流
vim mod/arm-mac14-host/workflows/operators.gxl
</code></pre>
<h4 id="步骤-4配置本地化设置按需"><a class="header" href="#步骤-4配置本地化设置按需">步骤 4：配置本地化设置[按需]</a></h4>
<p>编辑 <code>setting.yml</code> 配置模板渲染：</p>
<pre><code class="language-bash"># 配置本地化设置
vim mod/arm-mac14-host/setting.yml
</code></pre>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - LICENSE
    - "*.log"

  templatize_cust:
    label_beg: '{{'
    label_end: '}}'
</code></pre>
<h4 id="步骤-5验证和测试"><a class="header" href="#步骤-5验证和测试">步骤 5：验证和测试</a></h4>
<pre><code class="language-bash">
# 生成本地化配置
gmod localize

# 测试工作流
gflow install --dry-run
</code></pre>
<h3 id="3-开发工具使用"><a class="header" href="#3-开发工具使用">3. 开发工具使用</a></h3>
<h4 id="gmod---模块管理工具"><a class="header" href="#gmod---模块管理工具">gmod - 模块管理工具</a></h4>
<pre><code class="language-bash"># 创建模块
gmod new module_name


# 生成本地化配置
gmod localize

</code></pre>
<h4 id="gflow---工作流执行工具"><a class="header" href="#gflow---工作流执行工具">gflow - 工作流执行工具</a></h4>
<pre><code class="language-bash"># 执行工作流
gflow install
gflow start
gflow stop
gflow restart

# 调试模式
gflow install -d 1  # 详细输出
gflow install -d 2  # 更详细输出
gflow install -d 3  # 最详细输出

# 试运行模式
gflow install --dry-run

</code></pre>
<h2 id="最佳实践-5"><a class="header" href="#最佳实践-5">最佳实践</a></h2>
<h3 id="1-模块设计原则"><a class="header" href="#1-模块设计原则">1. 模块设计原则</a></h3>
<h4 id="单一职责原则"><a class="header" href="#单一职责原则">单一职责原则</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 专注单一组件
name: postgresql
description: "PostgreSQL 数据库管理模块"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 职责混乱
name: database_stack
description: "数据库、缓存、消息队列管理模块"
</code></pre>
<h4 id="接口一致性"><a class="header" href="#接口一致性">接口一致性</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 统一的任务命名
#[task(name="gops@install")]
flow install { ... }

#[task(name="gops@start")]
flow start { ... }

#[task(name="gops@stop")]
flow stop { ... }

#[task(name="gops@restart")]
flow restart { ... }
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 不一致的命名
#[task(name="install")]
flow install { ... }

#[task(name="startup")]
flow start { ... }

#[task(name="halt")]
flow stop { ... }
</code></pre>
<h4 id="配置外部化"><a class="header" href="#配置外部化">配置外部化</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 所有配置参数提取到变量
vars:
- name: DATABASE_PORT
  value: 5432

- name: MAX_CONNECTIONS
  value: 100

- name: DATA_DIR
  value: "/var/lib/postgresql"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 硬编码配置
flow install {
    gx.cmd("postgres -p 5432 -d /var/lib/postgresql");
}
</code></pre>
<h3 id="2-工作流设计"><a class="header" href="#2-工作流设计">2. 工作流设计</a></h3>
<h4 id="幂等性设计"><a class="header" href="#幂等性设计">幂等性设计</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-gxl">flow install {
    // 检查是否已安装
    if gx.defined("/usr/local/bin/postgres") {
        gx.echo("PostgreSQL 已安装，跳过安装步骤");
        return;
    }

    // 执行安装
    gx.cmd("./install.sh");

    // 验证安装
    gx.assert(gx.path_exists("/usr/local/bin/postgres"));
}
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-gxl">flow install {
    // 没有检查，可能重复安装
    gx.cmd("./install.sh");
}
</code></pre>
<h3 id="3-变量管理"><a class="header" href="#3-变量管理">3. 变量管理</a></h3>
<h4 id="命名规范-1"><a class="header" href="#命名规范-1">命名规范</a></h4>
<p><strong>✅ 好的命名：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: 5432

- name: MAX_CONNECTIONS
  value: 100

- name: DATA_DIRECTORY
  value: "/var/lib/postgresql"
</code></pre>
<p><strong>❌ 不好的命名：</strong></p>
<pre><code class="language-yaml">vars:
- name: port
  value: 5432

- name: max_conn
  value: 100

- name: data_dir
  value: "/var/lib/postgresql"
</code></pre>
<h4 id="类型安全"><a class="header" href="#类型安全">类型安全</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: ENABLE_SSL
  type: boolean
  value: false

- name: LOG_LEVEL
  type: enum
  values: [debug, info, warn, error]
  value: info
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: "5432"  # 字符串而不是数字

- name: ENABLE_SSL
  value: "false"  # 字符串而不是布尔值
</code></pre>
<h4 id="环境变量支持"><a class="header" href="#环境变量支持">环境变量支持</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: "${POSTGRES_PORT:5432}"  # 默认值 5432

- name: INSTALL_PREFIX
  value: "${PREFIX:/usr/local}"  # 默认 /usr/local

- name: DEBUG_MODE
  type: boolean
  value: "${DEBUG:false}"  # 默认 false
</code></pre>
<h3 id="4-依赖管理"><a class="header" href="#4-依赖管理">4. 依赖管理</a></h3>
<h4 id="版本约束"><a class="header" href="#版本约束">版本约束</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "3.0.0"  # 语义化版本
  enable: true

- addr:
    repo: https://github.com/pcre/pcre.git
    tag: "8.45"
  enable: true
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "latest"  # 不稳定的版本
  enable: true
</code></pre>
<h4 id="条件依赖"><a class="header" href="#条件依赖">条件依赖</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: "${USE_FEATURES:true}"

- addr:
    repo: https://github.com/debug/tools.git
    branch: main
  local: debug_tools
  enable: "${BUILD_MODE:debug}" == "debug"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: true  # 应该根据条件启用
</code></pre>
<h4 id="本地依赖优先"><a class="header" href="#本地依赖优先">本地依赖优先</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
# 本地依赖优先
- addr:
    path: ./local_libs
  local: common_libs
  enable: true

# 外部依赖作为后备
- addr:
    repo: https://github.com/external/lib.git
    tag: "1.0.0"
  local: common_libs
  enable: false  # 默认禁用
</code></pre>
<h3 id="5-文档和维护"><a class="header" href="#5-文档和维护">5. 文档和维护</a></h3>
<h4 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># mod-prj.yml
name: postgresql
version: "17.4.0"
description: "PostgreSQL 数据库管理模块"

# version.txt
17.4.0
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 没有版本管理
name: postgresql
version: "latest"
description: "PostgreSQL 数据库管理模块"
</code></pre>
<h2 id="调试和故障排除"><a class="header" href="#调试和故障排除">调试和故障排除</a></h2>
<h3 id="常见问题诊断"><a class="header" href="#常见问题诊断">常见问题诊断</a></h3>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<p>遵循本开发指南，可以创建出高质量、可维护、可扩展的 Mod-Operator 模块。关键要点：</p>
<ol>
<li><strong>标准化开发流程</strong>：遵循一致的模块创建和开发流程</li>
<li><strong>最佳实践设计</strong>：采用单一职责、幂等性、错误处理等设计原则</li>
<li><strong>有效的调试策略</strong>：使用详细的日志、断言和分步调试</li>
<li><strong>性能优化</strong>：利用并行执行和缓存机制</li>
<li><strong>高级功能</strong>：掌握条件工作流、模板系统</li>
</ol>
<p>通过合理应用这些技巧和最佳实践，可以显著提升模块开发效率和质量，为复杂的系统运维提供坚实的基础。</p>
<h2 id="相关资源"><a class="header" href="#相关资源">相关资源</a></h2>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>📖 <a href="operator/mod/./EXAMPLES.html">示例参考</a> - 完整的模块示例</li>
<li>📖 <a href="operator/mod/./REFERENCE.html">API 参考</a> - API 和枚举定义</li>
<li>🛠️ <a href="operator/mod/../gmod/">gmod 工具文档</a> - 模块管理工具使用指南</li>
<li>🛠️ <a href="operator/mod/../gflow/">gflow 工具文档</a> - 工作流执行工具使用指南</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-配置文件详解"><a class="header" href="#mod-operator-配置文件详解">Mod-Operator 配置文件详解</a></h1>
<p>本文档详细介绍 Mod-Operator 的各个配置文件及其使用方法。</p>
<h2 id="配置文件概览"><a class="header" href="#配置文件概览">配置文件概览</a></h2>
<p>Mod-Operator 使用多种配置文件来定义模块的行为和属性：</p>
<div class="table-wrapper"><table><thead><tr><th>文件</th><th>位置</th><th>作用</th><th>格式</th></tr></thead><tbody>
<tr><td><code>spec/artifact.yml</code></td><td><code>mod/{platform}/spec/</code></td><td>定义软件包和资源</td><td>YAML</td></tr>
<tr><td><code>spec/depends.yml</code></td><td><code>mod/{platform}/spec/</code></td><td>定义依赖关系</td><td>YAML</td></tr>
<tr><td><code>vars.yml</code></td><td><code>mod/{platform}/</code></td><td>定义环境变量</td><td>YAML</td></tr>
<tr><td><code>setting.yml</code></td><td><code>mod/{platform}/</code></td><td>配置本地化行为</td><td>YAML</td></tr>
<tr><td><code>workflows/operators.gxl</code></td><td><code>mod/{platform}/workflows/</code></td><td>工作流定义</td><td>GXL</td></tr>
<tr><td><code>mod-prj.yml</code></td><td>根目录</td><td>项目配置</td><td>YAML</td></tr>
</tbody></table>
</div>
<h2 id="specartifactyml---构件定义"><a class="header" href="#specartifactyml---构件定义">spec/artifact.yml - 构件定义</a></h2>
<p><code>artifact.yml</code> 是 Mod-Operator 中最重要的配置文件之一，它定义了模块所需的软件包、资源及其下载配置。</p>
<h3 id="基本格式"><a class="header" href="#基本格式">基本格式</a></h3>
<pre><code class="language-yaml"># 单个构件定义
- name: postgresql
  version: 0.1.0
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz
</code></pre>
<h3 id="字段说明"><a class="header" href="#字段说明">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>是</td><td>构件名称</td></tr>
<tr><td><code>version</code></td><td>String</td><td>是</td><td>构件版本</td></tr>
<tr><td><code>origin_addr</code></td><td>Object</td><td>是</td><td>原始下载地址</td></tr>
<tr><td><code>cache_addr</code></td><td>Object</td><td>否</td><td>缓存地址（可选）</td></tr>
<tr><td><code>cache_enable</code></td><td>Boolean</td><td>否</td><td>是否启用缓存（默认 false）</td></tr>
<tr><td><code>local</code></td><td>String</td><td>是</td><td>本地存储文件名</td></tr>
</tbody></table>
</div>
<h3 id="地址类型支持"><a class="header" href="#地址类型支持">地址类型支持</a></h3>
<h4 id="http-地址"><a class="header" href="#http-地址">HTTP 地址</a></h4>
<pre><code class="language-yaml">- name: nginx
  version: 1.25.3
  origin_addr:
    url: https://nginx.org/download/nginx-1.25.3.tar.gz
  local: nginx-1.25.3.tar.gz
</code></pre>
<h4 id="git-仓库"><a class="header" href="#git-仓库">Git 仓库</a></h4>
<pre><code class="language-yaml">- name: galaxy-flow
  version: 0.1.0
  origin_addr:
    repo: https://github.com/galaxy-sec/galaxy-flow.git
    branch: main
  local: galaxy-flow
</code></pre>
<h4 id="本地路径"><a class="header" href="#本地路径">本地路径</a></h4>
<pre><code class="language-yaml">- name: custom-library
  version: 1.0.0
  origin_addr:
    path: /path/to/local/library.tar.gz
  local: custom-library.tar.gz
</code></pre>
<h3 id="多构件定义"><a class="header" href="#多构件定义">多构件定义</a></h3>
<pre><code class="language-yaml">- name: postgresql
  version: 17.4
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz

- name: pcre
  version: 8.45
  origin_addr:
    url: https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz
  local: pcre-8.45.tar.gz

- name: openssl
  version: 3.0.0
  origin_addr:
    repo: https://github.com/openssl/openssl.git
    tag: openssl-3.0.0
  local: openssl-3.0.0
</code></pre>
<h2 id="specdependsyml---依赖定义"><a class="header" href="#specdependsyml---依赖定义">spec/depends.yml - 依赖定义</a></h2>
<p><code>depends.yml</code> 定义模块依赖的其他模块或资源，支持多种依赖类型和条件依赖。</p>
<h3 id="基本格式-1"><a class="header" href="#基本格式-1">基本格式</a></h3>
<pre><code class="language-yaml">dep_root: ./depends

deps:
- addr:
    path: ./data
  local: data_resources
  enable: true
</code></pre>
<h3 id="字段说明-1"><a class="header" href="#字段说明-1">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>dep_root</code></td><td>String</td><td>是</td><td>依赖根目录</td></tr>
<tr><td><code>deps</code></td><td>Array</td><td>是</td><td>依赖列表</td></tr>
<tr><td><code>addr</code></td><td>Object</td><td>是</td><td>依赖地址配置</td></tr>
<tr><td><code>local</code></td><td>String</td><td>是</td><td>本地化名称</td></tr>
<tr><td><code>enable</code></td><td>Boolean</td><td>是</td><td>是否启用</td></tr>
</tbody></table>
</div>
<h3 id="依赖地址类型"><a class="header" href="#依赖地址类型">依赖地址类型</a></h3>
<h4 id="本地路径依赖"><a class="header" href="#本地路径依赖">本地路径依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    path: ./common_libs          # 相对路径
  local: common_libs
  enable: true

- addr:
    path: /usr/local/lib        # 绝对路径
  local: system_libs
  enable: false
</code></pre>
<h4 id="git-仓库依赖"><a class="header" href="#git-仓库依赖">Git 仓库依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/user/module.git
    tag: "1.0.0"                # 版本标签
  local: external_module
  enable: true
</code></pre>
<h4 id="条件依赖-1"><a class="header" href="#条件依赖-1">条件依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: "${ENABLE_FEATURES:false}"  # 条件启用

- addr:
    repo: https://github.com/debug/debug-tools.git
    branch: main
  local: debug_tools
  enable: "${BUILD_MODE:debug}" == "debug"
</code></pre>
<h4 id="http-url-依赖"><a class="header" href="#http-url-依赖">HTTP URL 依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    url: https://example.com/dependencies.zip
  local: external_deps
  enable: true
</code></pre>
<h2 id="varsyml---变量定义"><a class="header" href="#varsyml---变量定义">vars.yml - 变量定义</a></h2>
<p><code>vars.yml</code> 定义模块使用的环境变量和配置参数，支持类型安全和验证规则。</p>
<h3 id="基本格式-2"><a class="header" href="#基本格式-2">基本格式</a></h3>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  desp: "数据库端口号"
  value: 5432

- name: MAX_CONNECTIONS
  value: 100
</code></pre>
<h3 id="字段说明-2"><a class="header" href="#字段说明-2">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>是</td><td>变量名</td></tr>
<tr><td><code>desp</code></td><td>String</td><td>否</td><td>描述（可选）</td></tr>
<tr><td><code>value</code></td><td>String</td><td>是</td><td>默认值</td></tr>
<tr><td><code>type</code></td><td>String</td><td>否</td><td>类型（string, integer, boolean, enum）</td></tr>
<tr><td><code>min</code></td><td>Number</td><td>否</td><td>最小值（数字类型）</td></tr>
<tr><td><code>max</code></td><td>Number</td><td>否</td><td>最大值（数字类型）</td></tr>
<tr><td><code>values</code></td><td>Array</td><td>否</td><td>枚举值（枚举类型）</td></tr>
</tbody></table>
</div>
<h3 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h3>
<h4 id="字符串变量"><a class="header" href="#字符串变量">字符串变量</a></h4>
<pre><code class="language-yaml">vars:
- name: MODULE_NAME
  desp: "模块名称"
  value: postgresql

- name: DATA_DIR
  value: "/var/lib/postgresql"
</code></pre>
<h4 id="整数变量"><a class="header" href="#整数变量">整数变量</a></h4>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: MAX_CONNECTIONS
  type: integer
  min: 1
  max: 1000
  value: 100
</code></pre>
<h4 id="布尔变量"><a class="header" href="#布尔变量">布尔变量</a></h4>
<pre><code class="language-yaml">vars:
- name: ENABLE_SSL
  type: boolean
  value: false

- name: ENABLE_DEBUG
  type: boolean
  value: true
</code></pre>
<h3 id="变量引用和模板"><a class="header" href="#变量引用和模板">变量引用和模板</a></h3>
<pre><code class="language-yaml"># 支持变量间引用
vars:
- name: INSTALL_PREFIX
  value: "/usr/local"

- name: MODULE_PATH
  value: "${INSTALL_PREFIX}/{{MODULE_NAME}}"

- name: CONFIG_FILE
  value: "${MODULE_PATH}/config.conf"
</code></pre>
<h3 id="环境变量支持-1"><a class="header" href="#环境变量支持-1">环境变量支持</a></h3>
<pre><code class="language-yaml"># 支持通过环境变量覆盖默认值
vars:
- name: DATABASE_PORT
  value: "${POSTGRES_PORT:5432}"    # 默认 5432，可被 POSTGRES_PORT 环境变量覆盖

- name: INSTALL_PREFIX
  value: "${PREFIX:/usr/local}"     # 默认 /usr/local，可被 PREFIX 环境变量覆盖

- name: DEBUG_MODE
  type: boolean
  value: "${DEBUG:false}"           # 默认 false，可被 DEBUG 环境变量覆盖
</code></pre>
<h2 id="settingyml---本地化设置"><a class="header" href="#settingyml---本地化设置">setting.yml - 本地化设置</a></h2>
<p><code>setting.yml</code> 配置模板渲染和本地化行为，定义哪些文件需要模板化以及模板标记格式。</p>
<h3 id="基本格式-3"><a class="header" href="#基本格式-3">基本格式</a></h3>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - LICENSE
    - "*.log"

  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h3 id="字段说明-3"><a class="header" href="#字段说明-3">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>templatize_path</code></td><td>Object</td><td>否</td><td>模板路径配置</td></tr>
<tr><td><code>templatize_cust</code></td><td>Object</td><td>否</td><td>自定义模板标记</td></tr>
<tr><td><code>excludes</code></td><td>Array</td><td>否</td><td>排除的文件列表</td></tr>
<tr><td><code>includes</code></td><td>Array</td><td>否</td><td>包含的文件列表（优先级高于 excludes）</td></tr>
<tr><td><code>label_beg</code></td><td>String</td><td>否</td><td>模板开始标记</td></tr>
<tr><td><code>label_end</code></td><td>String</td><td>否</td><td>模板结束标记</td></tr>
</tbody></table>
</div>
<h3 id="文件选择策略"><a class="header" href="#文件选择策略">文件选择策略</a></h3>
<h4 id="排除特定文件"><a class="header" href="#排除特定文件">排除特定文件</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - CHANGELOG.md
    - "*.log"
    - "*.tmp"
</code></pre>
<h4 id="仅包含特定类型文件"><a class="header" href="#仅包含特定类型文件">仅包含特定类型文件</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    includes:
    - "*.conf"
    - "*.yml"
    - "*.yaml"
    - "templates/*"
</code></pre>
<h4 id="混合使用"><a class="header" href="#混合使用">混合使用</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    includes:
    - "*.conf"
    - "*.template"
    excludes:
    - "examples/*"
    - "test/*"
</code></pre>
<h3 id="模板标记配置"><a class="header" href="#模板标记配置">模板标记配置</a></h3>
<h4 id="默认标记jinja2-风格"><a class="header" href="#默认标记jinja2-风格">默认标记（Jinja2 风格）</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '{{'
    label_end: '}}'
</code></pre>
<h4 id="自定义标记"><a class="header" href="#自定义标记">自定义标记</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h4 id="多种标记支持"><a class="header" href="#多种标记支持">多种标记支持</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '${'
    label_end: '}'
</code></pre>
<h3 id="本地化规则"><a class="header" href="#本地化规则">本地化规则</a></h3>
<pre><code class="language-yaml"># 为不同环境配置不同的本地化规则
localize:
  # 生产环境配置
  templatize_path:
    excludes:
    - "*.dev"
    - "*.test"

  templatize_cust:
    label_beg: '{{'
    label_end: '}}'

# 开发环境配置
localize:
  templatize_path:
    includes:
    - "*.dev"
    - "config.dev/*"

  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h2 id="values_valueyml---默认值定义"><a class="header" href="#values_valueyml---默认值定义">values/_value.yml - 默认值定义</a></h2>
<p><code>_value.yml</code> 存储模块的默认配置值，为模块提供合理的默认行为。</p>
<h2 id="values_usedyml---使用的值定义"><a class="header" href="#values_usedyml---使用的值定义">values/_used.yml - 使用的值定义</a></h2>
<p><code>_used.yml</code> 记录实际使用的配置值及其来源，便于配置审计和问题排查。</p>
<h3 id="基本格式-4"><a class="header" href="#基本格式-4">基本格式</a></h3>
<pre><code class="language-yaml">SPEED_LIMIT:
  origin: mod-default
  value: 1000
  source_file: "values/_value.yml"

MODULE_NAME:
  origin: mod-default
  value: postgresql

PORT:
  origin: user-override
  value: 5433
  source_file: "user-config.yml"

MAX_CONNECTIONS:
  origin: env-override
  value: 200
  environment_var: "MAX_CONNECTIONS"
</code></pre>
<h3 id="值来源类型"><a class="header" href="#值来源类型">值来源类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>来源类型</th><th>说明</th><th>示例</th></tr></thead><tbody>
<tr><td><code>mod-default</code></td><td>模块默认值</td><td>来自 <code>values/_value.yml</code></td></tr>
<tr><td><code>user-override</code></td><td>用户覆盖值</td><td>来自用户配置文件</td></tr>
<tr><td><code>env-override</code></td><td>环境变量覆盖</td><td>来自环境变量</td></tr>
<tr><td><code>cmd-line</code></td><td>命令行参数</td><td>来自命令行选项</td></tr>
<tr><td><code>template-render</code></td><td>模板渲染结果</td><td>运行时计算值</td></tr>
</tbody></table>
</div>
<h2 id="工作流配置"><a class="header" href="#工作流配置">工作流配置</a></h2>
<h3 id="workflowsoperatorsgxl---工作流定义"><a class="header" href="#workflowsoperatorsgxl---工作流定义">workflows/operators.gxl - 工作流定义</a></h3>
<p><code>operators.gxl</code> 使用 GXL 语言定义模块的运维操作流程，包括安装、配置、启动、停止等任务。</p>
<h4 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h4>
<pre><code class="language-gxl">// 引入外部模块
extern mod mod_ops {
    git = "https://github.com/galaxy-operators/ops-gxl.git",
    channel = "${GXL_CHANNEL_OPS:main}"
}

// 定义操作符模块
mod operators : empty_operators {
    // 自动加载入口
    #[auto_load(entry)]
    flow __into {
        // 加载配置文件
        gx.read_file(
            file : "./values/_used.json",
            name : "SETTING"
        );
    }

    // 任务定义...
}
</code></pre>
<pre><code>
#### 常见任务示例

##### 安装任务
```gxl
#[task(name="gops@install")]
flow install {
    };
}
</code></pre>
<h5 id="启动任务"><a class="header" href="#启动任务">启动任务</a></h5>
<pre><code class="language-gxl">#[task(name="gops@start")]
flow start {
}
</code></pre>
<h5 id="停止任务"><a class="header" href="#停止任务">停止任务</a></h5>
<pre><code class="language-gxl">#[task(name="gops@stop")]
flow stop {
}
</code></pre>
<h2 id="mod-prjyml---项目配置"><a class="header" href="#mod-prjyml---项目配置">mod-prj.yml - 项目配置</a></h2>
<p><code>mod-prj.yml</code> 定义模块的项目级别配置，包括模块信息、构建目标和发布配置。</p>
<h3 id="基本格式-5"><a class="header" href="#基本格式-5">基本格式</a></h3>
<pre><code class="language-yaml"># 模块项目配置
name: postgresql
version: 0.1.0
description: "PostgreSQL 数据库管理模块"
maintainer: "PostgreSQL Team &lt;team@example.com&gt;"
license: "Apache-2.0"

# 测试环境配置
test_envs:
  dep_root: "./test-deps"
  deps: []





## 总结

通过合理配置这些配置文件，可以实现：

1. **标准化管理**：统一的配置结构和命名规范
2. **灵活适配**：多平台和环境支持
3. **版本控制**：完整的版本管理和依赖追踪
4. **自动化**：工作流驱动的运维操作
5. **可维护性**：清晰的配置分层和验证机制

遵循本配置指南，可以开发出高质量、可维护、可扩展的 Mod-Operator 模块。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-api-和枚举参考"><a class="header" href="#mod-operator-api-和枚举参考">Mod-Operator API 和枚举参考</a></h1>
<p>本文档提供 Mod-Operator 的 API 接口、枚举定义和数据结构参考，是开发者进行二次开发和功能扩展的重要指南。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="operator/mod/REFERENCE.html#%E6%A8%A1%E5%9D%97-api">模块 API</a></li>
<li><a href="operator/mod/REFERENCE.html#%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89">枚举定义</a></li>
<li><a href="operator/mod/REFERENCE.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="operator/mod/REFERENCE.html#%E5%B7%A5%E4%BD%9C%E6%B5%81-api">工作流 API</a></li>
<li><a href="operator/mod/REFERENCE.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">配置文件格式</a></li>
<li><a href="operator/mod/REFERENCE.html#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81">错误代码</a></li>
<li><a href="operator/mod/REFERENCE.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li>
<li><a href="operator/mod/REFERENCE.html#api-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">API 使用示例</a></li>
</ul>
<h2 id="模块-api"><a class="header" href="#模块-api">模块 API</a></h2>
<h3 id="modulespec-接口"><a class="header" href="#modulespec-接口">ModuleSpec 接口</a></h3>
<p>模块的核心数据结构，定义了模块的基本信息和支持的目标平台。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Getters)]
pub struct ModuleSpec {
    /// 模块名称
    name: String,

    /// 目标平台配置映射
    targets: IndexMap&lt;ModelSTD, ModModelSpec&gt;,

    /// 本地化路径
    local: Option&lt;PathBuf&gt;,
}

impl ModuleSpec {
    /// 创建新模块
    pub fn init&lt;S: Into&lt;String&gt;&gt;(name: S, target_vec: Vec&lt;ModModelSpec&gt;) -&gt; Self

    /// 清理其他平台配置
    pub fn clean_other(&amp;mut self, node: &amp;ModelSTD) -&gt; MainResult&lt;()&gt;

    /// 保存主要配置
    pub fn save_main(&amp;self, path: &amp;Path, name: Option&lt;String&gt;) -&gt; MainResult&lt;()&gt;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="方法详解"><a class="header" href="#方法详解">方法详解</a></h4>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>参数</th><th>返回值</th><th>说明</th></tr></thead><tbody>
<tr><td><code>init</code></td><td><code>name: String</code>, <code>target_vec: Vec&lt;ModModelSpec&gt;</code></td><td><code>ModuleSpec</code></td><td>创建新的模块实例</td></tr>
<tr><td><code>clean_other</code></td><td><code>node: &amp;ModelSTD</code></td><td><code>MainResult&lt;()&gt;</code></td><td>清理指定平台外的其他平台配置</td></tr>
<tr><td><code>save_main</code></td><td><code>path: &amp;Path</code>, <code>name: Option&lt;String&gt;</code></td><td><code>MainResult&lt;()&gt;</code></td><td>保存模块主要配置文件</td></tr>
</tbody></table>
</div>
<h4 id="使用示例-1"><a class="header" href="#使用示例-1">使用示例</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建模块
let targets = vec![
    ModModelSpec::init(
        ModelSTD::x86_ubt22_k8s(),
        ArtifactPackage::default(),
        ModWorkflows::mod_k8s_tpl_init(),
        GxlProject::spec_k8s_tpl(),
        VarCollection::default(),
        None,
    ),
    ModModelSpec::init(
        ModelSTD::arm_mac14_host(),
        ArtifactPackage::default(),
        ModWorkflows::mod_host_tpl_init(),
        GxlProject::spec_host_tpl(),
        VarCollection::default(),
        None,
    ),
];

let module_spec = ModuleSpec::init("postgresql", targets);

// 清理其他平台
module_spec.clean_other(&amp;ModelSTD::x86_ubt22_k8s());
<span class="boring">}</span></code></pre></pre>
<h3 id="modmodelspec-接口"><a class="header" href="#modmodelspec-接口">ModModelSpec 接口</a></h3>
<p>模型规格定义，包含模块的具体实现配置。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Getters)]
pub struct ModModelSpec {
    /// 模型标准
    model: ModelSTD,

    /// 构件包定义
    artifact_pkg: ArtifactPackage,

    /// 工作流定义
    workflows: ModWorkflows,

    /// GXL 项目配置
    prj: GxlProject,

    /// 变量集合
    vars: VarCollection,

    /// 设置配置
    setting: Option&lt;Setting&gt;,
}

impl ModModelSpec {
    /// 创建新的模型规格
    pub fn init(
        model: ModelSTD,
        artifact_pkg: ArtifactPackage,
        workflows: ModWorkflows,
        prj: GxlProject,
        vars: VarCollection,
        setting: Option&lt;Setting&gt;,
    ) -&gt; Self

    /// 更新本地配置
    pub async fn update_local(
        &amp;self,
        accessor: Accessor,
        path: &amp;Path,
        options: &amp;DownloadOptions,
    ) -&gt; MainResult&lt;UpdateUnit&gt;

    /// 本地化处理
    pub async fn localize(
        &amp;self,
        dst_path: Option&lt;ValuePath&gt;,
        options: LocalizeOptions,
    ) -&gt; MainResult&lt;()&gt;

    /// 保存配置
    pub fn save_to(&amp;self, path: &amp;Path, name: Option&lt;String&gt;) -&gt; SerdeResult&lt;()&gt;

    /// 从文件加载
    pub fn load_from(path: &amp;Path) -&gt; SerdeResult&lt;Self&gt;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="主要方法"><a class="header" href="#主要方法">主要方法</a></h4>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td><code>init</code></td><td><code>model</code>, <code>artifact_pkg</code>, <code>workflows</code>, <code>prj</code>, <code>vars</code>, <code>setting</code></td><td>创建模型规格实例</td></tr>
<tr><td><code>update_local</code></td><td><code>accessor</code>, <code>path</code>, <code>options</code></td><td>更新本地构件配置</td></tr>
<tr><td><code>localize</code></td><td><code>dst_path</code>, <code>options</code></td><td>执行本地化处理</td></tr>
<tr><td><code>save_to</code></td><td><code>path</code>, <code>name</code></td><td>保存配置到文件</td></tr>
<tr><td><code>load_from</code></td><td><code>path</code></td><td>从文件加载配置</td></tr>
</tbody></table>
</div>
<h2 id="枚举定义"><a class="header" href="#枚举定义">枚举定义</a></h2>
<h3 id="modelstd-标准型号-1"><a class="header" href="#modelstd-标准型号-1">ModelSTD 标准型号</a></h3>
<p>模型标准定义，包含 CPU 架构、操作系统和运行环境。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// CPU 架构枚举
pub enum CpuArch {
    /// x86_64 架构
    X86,
    /// ARM 架构
    Arm,
}

/// 操作系统枚举
pub enum OsCPE {
    /// macOS 14+
    MAC14,
    /// Windows 10+
    WIN10,
    /// Ubuntu 22.04
    UBT22,
    /// CentOS 7
    COS7,
}

/// 运行环境枚举
pub enum RunSPC {
    /// 宿主机环境
    Host,
    /// Kubernetes 环境
    K8S,
}

/// 模型标准结构
#[derive(Debug, Clone, PartialEq, Eq, Hash, Getters)]
pub struct ModelSTD {
    /// CPU 架构
    arch: CpuArch,
    /// 操作系统
    os: OsCPE,
    /// 运行环境
    spc: RunSPC,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="常用预定义实例"><a class="header" href="#常用预定义实例">常用预定义实例</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 主流平台组合
impl ModelSTD {
    /// x86 + Ubuntu 22.04 + Kubernetes
    pub fn x86_ubt22_k8s() -&gt; Self

    /// x86 + Ubuntu 22.04 + Host
    pub fn x86_ubt22_host() -&gt; Self

    /// ARM + macOS 14 + Host
    pub fn arm_mac14_host() -&gt; Self

    /// ARM + Ubuntu 22.04 + Host
    pub fn arm_ubt22_host() -&gt; Self
}
<span class="boring">}</span></code></pre></pre>
<h3 id="artifact-枚举"><a class="header" href="#artifact-枚举">Artifact 枚举</a></h3>
<p>构件类型和状态枚举。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 构件类型
pub enum ArtifactType {
    /// HTTP/HTTPS 下载
    Http,
    /// Git 仓库
    Git,
    /// 本地文件
    Local,
    /// 容器镜像
    Container,
}

/// 构件状态
pub enum ArtifactStatus {
    /// 待下载
    Pending,
    /// 下载中
    Downloading,
    /// 已下载
    Downloaded,
    /// 解压中
    Extracting,
    /// 已解压
    Extracted,
    /// 已安装
    Installed,
    /// 错误
    Error,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="枚举比较和转换"><a class="header" href="#枚举比较和转换">枚举比较和转换</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 枚举比较
impl PartialEq for CpuArch {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (CpuArch::X86, CpuArch::X86) =&gt; true,
            (CpuArch::Arm, CpuArch::Arm) =&gt; true,
            _ =&gt; false,
        }
    }
}

// 枚举转字符串
impl ToString for CpuArch {
    fn to_string(&amp;self) -&gt; String {
        match self {
            CpuArch::X86 =&gt; "x86".to_string(),
            CpuArch::Arm =&gt; "arm".to_string(),
        }
    }
}

// 字符串转枚举
impl FromStr for CpuArch {
    type Err = ParseError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.to_lowercase().as_str() {
            "x86" | "x86_64" | "amd64" =&gt; Ok(CpuArch::X86),
            "arm" | "aarch64" =&gt; Ok(CpuArch::Arm),
            _ =&gt; Err(ParseError::InvalidCpuArch(s.to_string())),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h2>
<h3 id="artifactpackage-构件包"><a class="header" href="#artifactpackage-构件包">ArtifactPackage 构件包</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct ArtifactPackage {
    /// 构件列表
    artifacts: Vec&lt;Artifact&gt;,
}

impl ArtifactPackage {
    /// 创建默认构件包
    pub fn default() -&gt; Self

    /// 从构件列表创建
    pub fn from(artifacts: Vec&lt;Artifact&gt;) -&gt; Self

    /// 获取所有构件
    pub fn artifacts(&amp;self) -&gt; &amp;Vec&lt;Artifact&gt;

    /// 添加构件
    pub fn add_artifact(&amp;mut self, artifact: Artifact)

    /// 移除构件
    pub fn remove_artifact(&amp;mut self, name: &amp;str) -&gt; Option&lt;Artifact&gt;

    /// 查找构件
    pub fn find_artifact(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Artifact&gt;

    /// 验证构件包
    pub fn validate(&amp;self) -&gt; Result&lt;(), ValidationError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="varcollection-变量集合"><a class="header" href="#varcollection-变量集合">VarCollection 变量集合</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct VarCollection {
    /// 变量定义列表
    vars: Vec&lt;VarDefinition&gt;,
}

impl VarCollection {
    /// 定义变量
    pub fn define(vars: Vec&lt;VarDefinition&gt;) -&gt; Self

    /// 添加变量
    pub fn add_var(&amp;mut self, var: VarDefinition)

    /// 获取变量
    pub fn get_var(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;VarDefinition&gt;

    /// 设置变量值
    pub fn set_value(&amp;mut self, name: &amp;str, value: String) -&gt; Result&lt;(), VarError&gt;

    /// 解析变量值
    pub fn resolve_value(&amp;self, name: &amp;str, context: &amp;Context) -&gt; Result&lt;String, VarError&gt;

    /// 验证变量
    pub fn validate(&amp;self) -&gt; Result&lt;(), VarError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gxlproject-gxl-项目"><a class="header" href="#gxlproject-gxl-项目">GxlProject GXL 项目</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct GxlProject {
    /// 项目名称
    name: String,

    /// 工作流定义
    workflows: HashMap&lt;String, GxlWorkflow&gt;,

    /// 项目配置
    config: HashMap&lt;String, Value&gt;,
}

impl GxlProject {
    /// 创建项目配置模板
    pub fn spec_k8s_tpl() -&gt; Self

    /// 创建主机配置模板
    pub fn spec_host_tpl() -&gt; Self

    /// 添加工作流
    pub fn add_workflow(&amp;mut self, name: String, workflow: GxlWorkflow)

    /// 获取工作流
    pub fn get_workflow(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;GxlWorkflow&gt;

    /// 执行工作流
    pub async fn execute_workflow(
        &amp;self,
        name: &amp;str,
        context: &amp;Context,
    ) -&gt; Result&lt;WorkflowResult, WorkflowError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="工作流-api"><a class="header" href="#工作流-api">工作流 API</a></h2>
<h3 id="gxlworkflow-gxl-工作流"><a class="header" href="#gxlworkflow-gxl-工作流">GxlWorkflow GXL 工作流</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GxlWorkflow {
    /// 工作流名称
    name: String,

    /// 工作流描述
    description: Option&lt;String&gt;,

    /// 任务列表
    tasks: Vec&lt;GxlTask&gt;,

    /// 变量定义
    variables: HashMap&lt;String, GxlVariable&gt;,

    /// 条件分支
    conditions: Vec&lt;GxlCondition&gt;,

    /// 错误处理
    error_handler: Option&lt;GxlErrorHandler&gt;,
}

impl GxlWorkflow {
    /// 创建工作流
    pub fn new(name: String) -&gt; Self

    /// 添加任务
    pub fn add_task(&amp;mut self, task: GxlTask)

    /// 添加条件分支
    pub fn add_condition(&amp;mut self, condition: GxlCondition)

    /// 设置错误处理器
    pub fn set_error_handler(&amp;mut self, handler: GxlErrorHandler)

    /// 验证工作流
    pub fn validate(&amp;self) -&gt; Result&lt;(), WorkflowError&gt;

    /// 执行工作流
    pub async fn execute(&amp;self, context: &amp;mut Context) -&gt; Result&lt;WorkflowResult, WorkflowError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gxltask-gxl-任务"><a class="header" href="#gxltask-gxl-任务">GxlTask GXL 任务</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GxlTask {
    /// 命令任务
    Command(GxlCommandTask),

    /// 脚本任务
    Script(GxlScriptTask),

    /// 模板渲染任务
    Template(GxlTemplateTask),

    /// 下载任务
    Download(GxlDownloadTask),

    /// 并行任务
    Parallel(GxlParallelTask),

    /// 条件任务
    Conditional(GxlConditionalTask),

    /// 循环任务
    Loop(GxlLoopTask),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="任务执行上下文"><a class="header" href="#任务执行上下文">任务执行上下文</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct Context {
    /// 变量存储
    variables: HashMap&lt;String, Value&gt;,

    /// 工作目录
    working_dir: PathBuf,

    /// 执行状态
    status: ExecutionStatus,

    /// 错误收集
    errors: Vec&lt;ExecutionError&gt;,

    /// 日志输出
    logs: Vec&lt;LogEntry&gt;,
}

impl Context {
    /// 创建新上下文
    pub fn new() -&gt; Self

    /// 设置变量
    pub fn set_var(&amp;mut self, name: String, value: Value)

    /// 获取变量
    pub fn get_var(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Value&gt;

    /// 执行命令
    pub async fn execute_command(&amp;mut self, cmd: &amp;str) -&gt; Result&lt;CommandResult, CommandError&gt;

    /// 添加日志
    pub fn add_log(&amp;mut self, level: LogLevel, message: String)

    /// 保存状态
    pub fn save_state(&amp;self) -&gt; Result&lt;StateSnapshot, StateError&gt;

    /// 恢复状态
    pub fn restore_state(&amp;mut self, state: &amp;StateSnapshot) -&gt; Result&lt;(), StateError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="配置文件格式"><a class="header" href="#配置文件格式">配置文件格式</a></h2>
<h3 id="yaml-配置验证"><a class="header" href="#yaml-配置验证">YAML 配置验证</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 配置验证器
pub struct ConfigValidator;

impl ConfigValidator {
    /// 验证 artifact.yml
    pub fn validate_artifact(yaml_content: &amp;str) -&gt; Result&lt;Vec&lt;Artifact&gt;, ConfigError&gt;

    /// 验证 depends.yml
    pub fn validate_depends(yaml_content: &amp;str) -&gt; Result&lt;DependsConfig, ConfigError&gt;

    /// 验证 vars.yml
    pub fn validate_vars(yaml_content: &amp;str) -&gt; Result&lt;VarCollection, ConfigError&gt;

    /// 验证 setting.yml
    pub fn validate_setting(yaml_content: &amp;str) -&gt; Result&lt;Setting, ConfigError&gt;

    /// 验证 mod-prj.yml
    pub fn validate_project(yaml_content: &amp;str) -&gt; Result&lt;ProjectConfig, ConfigError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="配置生成器"><a class="header" href="#配置生成器">配置生成器</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 配置文件生成器
pub struct ConfigGenerator;

impl ConfigGenerator {
    /// 生成 artifact.yml
    pub fn generate_artifact(artifacts: &amp;[Artifact]) -&gt; String

    /// 生成 depends.yml
    pub fn generate_depends(deps: &amp;[Dependency]) -&gt; String

    /// 生成 vars.yml
    pub fn generate_vars(vars: &amp;[VarDefinition]) -&gt; String

    /// 生成 setting.yml
    pub fn generate_setting(setting: &amp;Setting) -&gt; String

    /// 生成 mod-prj.yml
    pub fn generate_project(project: &amp;ProjectConfig) -&gt; String
}
<span class="boring">}</span></code></pre></pre>
<h2 id="错误代码"><a class="header" href="#错误代码">错误代码</a></h2>
<h3 id="错误类型定义"><a class="header" href="#错误类型定义">错误类型定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 系统错误
#[derive(Debug, Error)]
pub enum SystemError {
    #[error("配置解析错误: {0}")]
    ConfigParse(String),

    #[error("文件操作错误: {0}")]
    FileOperation(String),

    #[error("网络错误: {0}")]
    Network(String),

    #[error("进程错误: {0}")]
    Process(String),

    #[error("权限错误: {0}")]
    Permission(String),

    #[error("资源不足: {0}")]
    Resource(String),
}

/// 业务错误
#[derive(Debug, Error)]
pub enum BusinessError {
    #[error("模块不存在: {0}")]
    ModuleNotFound(String),

    #[error("任务执行失败: {0}")]
    TaskFailed(String),

    #[error("验证失败: {0}")]
    ValidationFailed(String),

    #[error("状态错误: {0}")]
    InvalidState(String),

    #[error("依赖冲突: {0}")]
    DependencyConflict(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="错误处理模式"><a class="header" href="#错误处理模式">错误处理模式</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 错误处理结果
pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;

/// 错误处理工具
pub struct ErrorHandler;

impl ErrorHandler {
    /// 记录错误
    pub fn log_error(error: &amp;Error) {
        // 记录错误日志
    }

    /// 错误恢复
    pub fn recover(context: &amp;mut Context, error: &amp;Error) -&gt; Result&lt;()&gt; {
        // 执行错误恢复操作
        Ok(())
    }

    /// 错误通知
    pub fn notify(error: &amp;Error) -&gt; Result&lt;()&gt; {
        // 发送错误通知
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="环境变量-3"><a class="header" href="#环境变量-3">环境变量</a></h2>
<h2 id="api-使用示例"><a class="header" href="#api-使用示例">API 使用示例</a></h2>
<h3 id="创建自定义模块"><a class="header" href="#创建自定义模块">创建自定义模块</a></h3>
<pre><pre class="playground"><code class="language-rust">use galaxy_ops::{
    artifact::{Artifact, ArtifactPackage},
    model::{ModelSTD, CpuArch, OsCPE, RunSPC},
    module::ModuleSpec,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 定义目标平台
    let target_platforms = vec![
        ModelSTD::x86_ubt22_k8s(),
        ModelSTD::arm_mac14_host(),
    ];

    // 创建构件包
    let artifacts = vec![
        Artifact::new(
            "nginx",
            "1.25.3",
            "https://nginx.org/download/nginx-1.25.3.tar.gz".parse()?,
            "nginx-1.25.3.tar.gz",
        ),
        Artifact::new(
            "openssl",
            "3.0.0",
            "https://github.com/openssl/openssl.git".parse()?,
            "openssl-3.0.0",
        ),
    ];

    let artifact_pkg = ArtifactPackage::from(artifacts);

    // 为每个平台创建模型规格
    let mut target_specs = Vec::new();
    for platform in target_platforms {
        let model_spec = ModModelSpec::init(
            platform.clone(),
            artifact_pkg.clone(),
            ModWorkflows::mod_k8s_tpl_init(),
            GxlProject::spec_k8s_tpl(),
            VarCollection::define(vec![
                VarDefinition::new("MODULE_NAME", "nginx"),
                VarDefinition::new("VERSION", "1.25.3"),
            ]),
            None,
        );

        target_specs.push(model_spec);
    }

    // 创建模块规格
    let module_spec = ModuleSpec::init("nginx-server", target_specs);

    // 保存模块配置
    module_spec.save_main(&amp;std::path::Path::new("./nginx"), Some("nginx".to_string()))?;

    println!("自定义模块创建成功");
    Ok(())
}</code></pre></pre>
<h3 id="错误处理示例"><a class="header" href="#错误处理示例">错误处理示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use galaxy_ops::{error::{SystemError, BusinessError}, workflow::Context};

fn handle_error(context: &amp;mut Context, error: &amp;dyn std::error::Error) {
    match error.downcast_ref::&lt;SystemError&gt;() {
        Some(sys_error) =&gt; {
            match sys_error {
                SystemError::ConfigParse(msg) =&gt; {
                    eprintln!("配置解析错误: {}", msg);
                    // 执行配置错误恢复
                    ConfigErrorHandler::recover(context, msg);
                }
                SystemError::FileOperation(msg) =&gt; {
                    eprintln!("文件操作错误: {}", msg);
                    // 执行文件错误恢复
                    FileErrorHandler::recover(context, msg);
                }
                SystemError::Network(msg) =&gt; {
                    eprintln!("网络错误: {}", msg);
                    // 执行网络错误恢复
                    NetworkErrorHandler::recover(context, msg);
                }
                _ =&gt; {
                    eprintln!("未知系统错误: {}", msg);
                }
            }
        }
        None =&gt; {
            match error.downcast_ref::&lt;BusinessError&gt;() {
                Some(biz_error) =&gt; {
                    match biz_error {
                        BusinessError::ModuleNotFound(msg) =&gt; {
                            eprintln!("模块不存在: {}", msg);
                            ModuleErrorHandler::recover(context, msg);
                        }
                        BusinessError::TaskFailed(msg) =&gt; {
                            eprintln!("任务执行失败: {}", msg);
                            TaskErrorHandler::recover(context, msg);
                        }
                        BusinessError::ValidationFailed(msg) =&gt; {
                            eprintln!("验证失败: {}", msg);
                            ValidationErrorHandler::recover(context, msg);
                        }
                        _ =&gt; {
                            eprintln!("未知业务错误: {}", msg);
                        }
                    }
                }
                None =&gt; {
                    eprintln!("未分类错误: {}", error);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<p>本 API 参考文档提供了 Mod-Operator 框架的完整接口和功能说明，包括：</p>
<ol>
<li><strong>模块管理 API</strong> - 用于创建和管理模块实例</li>
<li><strong>枚举定义</strong> - 标准化的平台和类型定义</li>
<li><strong>数据结构</strong> - 核心配置和数据类型</li>
<li><strong>工作流 API</strong> - 任务执行和流程控制</li>
<li><strong>配置处理</strong> - 配置文件的验证和生成</li>
<li><strong>错误处理</strong> - 完善的错误处理机制</li>
<li><strong>环境变量</strong> - 系统和用户配置变量</li>
<li><strong>实用示例</strong> - 常见场景的实现示例</li>
</ol>
<p>通过这些 API，开发者可以：</p>
<ul>
<li>创建自定义模块类型</li>
<li>扩展工作流功能</li>
<li>自定义配置验证</li>
<li>实现高级监控功能</li>
<li>集成第三方系统</li>
</ul>
<p>建议开发者在使用前仔细阅读相关章节，并根据实际需求选择合适的 API 接口。</p>
<h2 id="相关资源-1"><a class="header" href="#相关资源-1">相关资源</a></h2>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./DEVELOPMENT.html">开发指南</a> - 开发工作流和最佳实践</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>🛠️ <a href="operator/mod/../gmod/">gmod 工具文档</a> - 模块管理工具使用指南</li>
<li>🛠️ <a href="operator/mod/../gflow/">gflow 工具文档</a> - 工作流执行工具使用指南</li>
</ul>
<hr />
<p><em>本文档会根据框架发展持续更新，请关注最新版本。如需帮助，请参考示例代码或提交 Issue。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-故障排除指南"><a class="header" href="#mod-operator-故障排除指南">Mod-Operator 故障排除指南</a></h1>
<p>本文档提供 Mod-Operator 常见问题的诊断步骤、解决方案和调试技巧，帮助开发者快速定位和解决问题。</p>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<ul>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD">常见问题诊断</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%92%8C%E6%96%B9%E6%B3%95">调试工具和方法</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">错误代码解析</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">性能问题分析</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE">最佳实践建议</a></li>
</ul>
<h2 id="常见问题诊断-1"><a class="header" href="#常见问题诊断-1">常见问题诊断</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-netaccessctrl-简约配置指南非开发者版"><a class="header" href="#-netaccessctrl-简约配置指南非开发者版">📖 NetAccessCtrl 简约配置指南（非开发者版）</a></h1>
<h2 id="什么是-netaccessctrl"><a class="header" href="#什么是-netaccessctrl">什么是 NetAccessCtrl？</a></h2>
<p>NetAccessCtrl 是一个网络访问控制模块，可以在使用orino_variate 时自动将您的网络请求重定向到更快的镜像服务器，支持认证、超时设置和代理配置。它可以帮助您：</p>
<ul>
<li>🚀 加速 GitHub、GitLab 等国外服务访问</li>
<li>🔐 安全管理认证信息</li>
<li>⏱️ 控制网络请求超时时间</li>
<li>🌐 配置代理服务器</li>
<li>📝 使用环境变量动态配置</li>
</ul>
<h2 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h2>
<h3 id="1-创建配置文件"><a class="header" href="#1-创建配置文件">1. 创建配置文件</a></h3>
<p>在您的项目根目录创建 <code>net-accessor_ctrl.yaml</code> 文件：</p>
<pre><code class="language-yaml"># 基础配置示例
enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror.ghproxy.com/"
    # 可选：添加认证信息
    auth:
      username: "your_username"
      password: "your_token"
</code></pre>
<h3 id="2-常用场景配置"><a class="header" href="#2-常用场景配置">2. 常用场景配置</a></h3>
<h4 id="github-加速访问"><a class="header" href="#github-加速访问">GitHub 加速访问</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror.ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
</code></pre>
<h4 id="gitlab-镜像"><a class="header" href="#gitlab-镜像">GitLab 镜像</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://gitlab.com/*"
        target: "https://gitlab-mirror.com/"
</code></pre>
<h4 id="npm-包管理器加速"><a class="header" href="#npm-包管理器加速">NPM 包管理器加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://registry.npmjs.org/*"
        target: "https://registry.npmmirror.com/"
</code></pre>
<h3 id="3-完整配置示例"><a class="header" href="#3-完整配置示例">3. 完整配置示例</a></h3>
<pre><code class="language-yaml">enable: true
units:
  # GitHub 配置
  - rules:
      - pattern: "https://github.com/*"
        target: "https://ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
    auth:
      username: "${GITHUB_USER}"
      password: "${GITHUB_TOKEN}"
    timeout:
      connect-timeout: 30
      read-timeout: 60
      total-timeout: 300
    proxy:
      url: "http://proxy.company.com:8080"

  # 其他服务配置
  - rules:
      - pattern: "https://api.example.com/*"
        target: "https://internal-api.example.com/"
</code></pre>
<h2 id="配置参数说明"><a class="header" href="#配置参数说明">配置参数说明</a></h2>
<h3 id="基本参数"><a class="header" href="#基本参数">基本参数</a></h3>
<ul>
<li><code>enable</code>: <code>true</code> 或 <code>false</code>，是否启用网络访问控制</li>
<li><code>units</code>: 配置单元列表，每个单元包含重定向规则和配置</li>
</ul>
<h3 id="单元配置-units"><a class="header" href="#单元配置-units">单元配置 (units)</a></h3>
<p>每个 <code>unit</code> 包含：</p>
<ul>
<li><code>rules</code>: 重定向规则列表</li>
<li><code>auth</code>: 可选的认证信息（用户名和密码）</li>
<li><code>timeout</code>: 可选的超时设置</li>
<li><code>proxy</code>: 可选的代理配置</li>
</ul>
<h3 id="规则配置-rules"><a class="header" href="#规则配置-rules">规则配置 (rules)</a></h3>
<p>每个 <code>rule</code> 包含：</p>
<ul>
<li><code>pattern</code>: 要匹配的URL模式（支持 <code>*</code> 通配符）</li>
<li><code>target</code>: 重定向的目标地址</li>
</ul>
<h3 id="环境变量支持-2"><a class="header" href="#环境变量支持-2">环境变量支持</a></h3>
<p>您可以使用环境变量来动态配置，避免硬编码敏感信息：</p>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://${GITHUB_DOMAIN:github.com}/*"
        target: "https://${MIRROR_DOMAIN:ghproxy.com}/"
    auth:
      username: "${GITHUB_USER}"
      password: "${GITHUB_TOKEN}"
    proxy:
      url: "${PROXY_URL:http://proxy.default:8080}"
</code></pre>
<p>环境变量语法：</p>
<ul>
<li><code>${VARIABLE_NAME}</code>: 使用环境变量</li>
<li><code>${VARIABLE_NAME:default_value}</code>: 使用环境变量，如果不存在则使用默认值</li>
</ul>
<h2 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h2>
<h3 id="1-设置环境变量可选"><a class="header" href="#1-设置环境变量可选">1. 设置环境变量（可选）</a></h3>
<pre><code class="language-bash"># Linux/Mac
export GITHUB_USER="your_username"
export GITHUB_TOKEN="your_token"
export PROXY_URL="http://proxy.company.com:8080"

# Windows
set GITHUB_USER=your_username
set GITHUB_TOKEN=your_token
set PROXY_URL=http://proxy.company.com:8080
</code></pre>
<h3 id="2-将配置文件放在正确位置"><a class="header" href="#2-将配置文件放在正确位置">2. 将配置文件放在正确位置</a></h3>
<ul>
<li>系统级配置：<code>/etc/net-access.yaml</code></li>
<li>用户级配置：<code>~/.config/net-access.yaml</code></li>
<li>项目级配置：<code>项目根目录/net-access.yaml</code></li>
</ul>
<h3 id="3-验证配置"><a class="header" href="#3-验证配置">3. 验证配置</a></h3>
<p>配置完成后，您可以通过以下方式验证是否生效：</p>
<pre><code class="language-bash"># 测试 GitHub 访问
curl -I "https://github.com/user/repo/releases"

# 查看是否重定向到镜像服务器
</code></pre>
<h2 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h2>
<h3 id="q-如何添加多个镜像服务器"><a class="header" href="#q-如何添加多个镜像服务器">Q: 如何添加多个镜像服务器？</a></h3>
<p>A: 在 <code>units</code> 中添加多个配置单元，系统会按顺序尝试：</p>
<pre><code class="language-yaml">enable: true
units:
  # 第一个镜像
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror1.github.com/"

  # 备用镜像
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror2.github.com/"
</code></pre>
<h3 id="q-如何设置不同的超时时间"><a class="header" href="#q-如何设置不同的超时时间">Q: 如何设置不同的超时时间？</a></h3>
<p>A: 在 <code>timeout</code> 部分配置：</p>
<pre><code class="language-yaml">timeout:
  connect-timeout: 30    # 连接超时（秒）
  read-timeout: 60       # 读取超时（秒）
  total-timeout: 300     # 总超时（秒）
</code></pre>
<h3 id="q-如何处理认证"><a class="header" href="#q-如何处理认证">Q: 如何处理认证？</a></h3>
<p>A: 在 <code>auth</code> 部分配置用户名和密码，推荐使用环境变量：</p>
<pre><code class="language-yaml">auth:
  username: "${YOUR_USERNAME}"
  password: "${YOUR_PASSWORD}"
</code></pre>
<h3 id="q-配置不生效怎么办"><a class="header" href="#q-配置不生效怎么办">Q: 配置不生效怎么办？</a></h3>
<p>A: 检查以下几点：</p>
<ol>
<li>确保 <code>enable: true</code></li>
<li>检查配置文件路径是否正确</li>
<li>验证 YAML 语法是否正确</li>
<li>检查 URL 模式是否匹配</li>
</ol>
<h3 id="q-如何配置代理"><a class="header" href="#q-如何配置代理">Q: 如何配置代理？</a></h3>
<p>A: 在 <code>proxy</code> 部分配置：</p>
<pre><code class="language-yaml">proxy:
  url: "http://proxy.example.com:8080"
</code></pre>
<h3 id="q-支持哪些通配符"><a class="header" href="#q-支持哪些通配符">Q: 支持哪些通配符？</a></h3>
<p>A: 目前支持 <code>*</code> 通配符，可以匹配任意字符序列。例如：</p>
<ul>
<li><code>https://github.com/*</code> 匹配所有 GitHub 地址</li>
<li><code>https://raw.githubusercontent.com/*</code> 匹配所有 GitHub 原始文件地址</li>
</ul>
<h2 id="配置示例合集"><a class="header" href="#配置示例合集">配置示例合集</a></h2>
<h3 id="常用镜像服务"><a class="header" href="#常用镜像服务">常用镜像服务</a></h3>
<h4 id="github-全家桶加速"><a class="header" href="#github-全家桶加速">GitHub 全家桶加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
      - pattern: "https://gist.github.com/*"
        target: "https://gist.ghproxy.com/"
</code></pre>
<h4 id="python-包管理器-pypi"><a class="header" href="#python-包管理器-pypi">Python 包管理器 (PyPI)</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://pypi.org/*"
        target: "https://pypi.doubanio.com/"
</code></pre>
<h4 id="docker-镜像加速"><a class="header" href="#docker-镜像加速">Docker 镜像加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://registry-1.docker.io/*"
        target: "https://dockerhub.azk8s.cn/"
</code></pre>
<h4 id="rubygems-加速"><a class="header" href="#rubygems-加速">RubyGems 加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://rubygems.org/*"
        target: "https://gems.ruby-china.com/"
</code></pre>
<h3 id="企业内部配置"><a class="header" href="#企业内部配置">企业内部配置</a></h3>
<h4 id="内部服务映射"><a class="header" href="#内部服务映射">内部服务映射</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://external-api.company.com/*"
        target: "https://internal-api.company.com/"
    auth:
      username: "${INTERNAL_API_USER}"
      password: "${INTERNAL_API_PASSWORD}"
    timeout:
      connect-timeout: 10
      read-timeout: 30
      total-timeout: 60
</code></pre>
<h4 id="多环境配置"><a class="header" href="#多环境配置">多环境配置</a></h4>
<pre><code class="language-yaml"># 开发环境配置
enable: ${ENABLE_NET_ACCESS:true}
units:
  - rules:
      - pattern: "https://api.${ENV:dev}.company.com/*"
        target: "http://localhost:8080/"
    timeout:
      connect-timeout: 5
      read-timeout: 15
      total-timeout: 30
</code></pre>
<h2 id="故障排除-2"><a class="header" href="#故障排除-2">故障排除</a></h2>
<h3 id="检查配置文件语法"><a class="header" href="#检查配置文件语法">检查配置文件语法</a></h3>
<p>使用在线 YAML 验证工具检查配置文件语法：</p>
<ol>
<li>访问 https://www.yamllint.com/</li>
<li>粘贴您的配置文件内容</li>
<li>检查是否有语法错误</li>
</ol>
<h3 id="常见错误及解决方案-1"><a class="header" href="#常见错误及解决方案-1">常见错误及解决方案</a></h3>
<h4 id="1-配置文件不生效"><a class="header" href="#1-配置文件不生效">1. 配置文件不生效</a></h4>
<p><strong>症状</strong>: 配置修改后没有效果
<strong>解决方案</strong>:</p>
<ul>
<li>检查配置文件路径是否正确</li>
<li>确认 <code>enable: true</code></li>
<li>重启应用程序</li>
<li>检查文件权限</li>
</ul>
<h4 id="2-环境变量未生效"><a class="header" href="#2-环境变量未生效">2. 环境变量未生效</a></h4>
<p><strong>症状</strong>: 环境变量没有正确替换
<strong>解决方案</strong>:</p>
<ul>
<li>确认环境变量已正确设置</li>
<li>检查环境变量名称是否正确</li>
<li>使用 <code>echo $VARIABLE_NAME</code> 验证环境变量</li>
<li>重新启动终端或应用程序</li>
</ul>
<h4 id="3-网络连接超时"><a class="header" href="#3-网络连接超时">3. 网络连接超时</a></h4>
<p><strong>症状</strong>: 请求经常超时
<strong>解决方案</strong>:</p>
<ul>
<li>增加 <code>timeout</code> 配置中的时间值</li>
<li>检查网络连接状态</li>
<li>尝试更换镜像服务器</li>
</ul>
<h4 id="4-认证失败"><a class="header" href="#4-认证失败">4. 认证失败</a></h4>
<p><strong>症状</strong>: 401 或 403 错误
<strong>解决方案</strong>:</p>
<ul>
<li>检查用户名和密码是否正确</li>
<li>确认认证信息是否有权限访问目标服务</li>
<li>检查 token 是否已过期</li>
</ul>
<h3 id="调试技巧-1"><a class="header" href="#调试技巧-1">调试技巧</a></h3>
<h4 id="启用详细日志"><a class="header" href="#启用详细日志">启用详细日志</a></h4>
<p>如果应用程序支持日志，可以启用详细日志来查看重定向过程：</p>
<pre><code class="language-bash"># 示例：启用调试日志
export RUST_LOG=debug
your_application
</code></pre>
<h4 id="手动测试重定向"><a class="header" href="#手动测试重定向">手动测试重定向</a></h4>
<p>使用 <code>curl</code> 命令手动测试重定向是否工作：</p>
<pre><code class="language-bash"># 测试重定向
curl -v "https://github.com/user/repo"

# 查看是否被重定向到镜像服务器
</code></pre>
<h4 id="检查配置加载"><a class="header" href="#检查配置加载">检查配置加载</a></h4>
<p>如果可能，查看应用程序启动时的日志，确认配置文件是否正确加载。</p>
<h2 id="最佳实践-6"><a class="header" href="#最佳实践-6">最佳实践</a></h2>
<h3 id="安全性建议"><a class="header" href="#安全性建议">安全性建议</a></h3>
<ol>
<li><strong>使用环境变量</strong>: 避免在配置文件中硬编码敏感信息</li>
<li><strong>设置文件权限</strong>: 确保配置文件只有授权用户可读
<pre><code class="language-bash">chmod 600 net-access.yaml
</code></pre>
</li>
<li><strong>定期更新认证信息</strong>: 定期更换密码和访问令牌</li>
<li><strong>使用 HTTPS</strong>: 确保所有目标地址使用 HTTPS 协议</li>
</ol>
<h3 id="性能优化建议"><a class="header" href="#性能优化建议">性能优化建议</a></h3>
<ol>
<li><strong>规则排序</strong>: 将最常用的规则放在前面</li>
<li><strong>合理设置超时</strong>: 根据网络环境调整超时时间</li>
<li><strong>使用就近镜像</strong>: 选择地理位置较近的镜像服务器</li>
<li><strong>避免过度重定向</strong>: 不要配置过多的重定向层级</li>
</ol>
<h3 id="维护建议"><a class="header" href="#维护建议">维护建议</a></h3>
<ol>
<li><strong>版本控制</strong>: 将配置文件纳入版本控制（排除敏感信息）</li>
<li><strong>文档记录</strong>: 记录配置文件的用途和变更历史</li>
<li><strong>定期测试</strong>: 定期测试配置是否仍然有效</li>
<li><strong>备份配置</strong>: 保留配置文件的备份</li>
</ol>
<h2 id="获取帮助"><a class="header" href="#获取帮助">获取帮助</a></h2>
<p>如果遇到问题，可以通过以下方式获取帮助：</p>
<h3 id="检查清单"><a class="header" href="#检查清单">检查清单</a></h3>
<p>在寻求帮助前，请先检查：</p>
<ul>
<li><input disabled="" type="checkbox"/>
配置文件语法是否正确</li>
<li><input disabled="" type="checkbox"/>
环境变量是否正确设置</li>
<li><input disabled="" type="checkbox"/>
网络连接是否正常</li>
<li><input disabled="" type="checkbox"/>
认证信息是否有效</li>
<li><input disabled="" type="checkbox"/>
目标服务器是否可访问</li>
</ul>
<h3 id="常见资源"><a class="header" href="#常见资源">常见资源</a></h3>
<ul>
<li><strong>YAML 语法验证</strong>: https://www.yamllint.com/</li>
<li><strong>环境变量设置指南</strong>: 搜索 "环境变量设置 [您的操作系统]"</li>
<li><strong>网络连接测试</strong>: 使用 <code>ping</code> 和 <code>curl</code> 命令测试</li>
<li><strong>镜像服务状态</strong>: 查看镜像服务的官方状态页面</li>
</ul>
<h3 id="联系支持"><a class="header" href="#联系支持">联系支持</a></h3>
<p>如果以上方法都无法解决问题，请联系技术支持并提供以下信息：</p>
<ol>
<li>操作系统和版本</li>
<li>配置文件内容（去除敏感信息）</li>
<li>错误信息或日志</li>
<li>重现问题的步骤</li>
</ol>
<hr />
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="配置文件模板"><a class="header" href="#配置文件模板">配置文件模板</a></h3>
<h4 id="基础模板"><a class="header" href="#基础模板">基础模板</a></h4>
<pre><code class="language-yaml"># NetAccessCtrl 基础配置模板
enable: true
units:
  - rules:
      - pattern: "https://example.com/*"
        target: "https://mirror.example.com/"
</code></pre>
<h4 id="完整模板"><a class="header" href="#完整模板">完整模板</a></h4>
<pre><code class="language-yaml"># NetAccessCtrl 完整配置模板
enable: true
units:
  - rules:
      - pattern: "https://service1.com/*"
        target: "https://mirror1.service1.com/"
      - pattern: "https://service2.com/*"
        target: "https://mirror2.service2.com/"
    auth:
      username: "${SERVICE1_USER}"
      password: "${SERVICE1_PASSWORD}"
    timeout:
      connect-timeout: 30
      read-timeout: 60
      total-timeout: 300
    proxy:
      url: "${PROXY_URL:http://proxy.default:8080}"

  - rules:
      - pattern: "https://another-service.com/*"
        target: "https://internal.another-service.com/"
    # 此单元无认证、超时和代理配置
</code></pre>
<h3 id="常用镜像服务器列表"><a class="header" href="#常用镜像服务器列表">常用镜像服务器列表</a></h3>
<div class="table-wrapper"><table><thead><tr><th>服务类型</th><th>原地址</th><th>推荐镜像地址</th></tr></thead><tbody>
<tr><td>GitHub</td><td><code>https://github.com/*</code></td><td><code>https://ghproxy.com/</code></td></tr>
<tr><td>GitHub Raw</td><td><code>https://raw.githubusercontent.com/*</code></td><td><code>https://raw.ghproxy.com/</code></td></tr>
<tr><td>PyPI</td><td><code>https://pypi.org/*</code></td><td><code>https://pypi.doubanio.com/</code></td></tr>
<tr><td>NPM</td><td><code>https://registry.npmjs.org/*</code></td><td><code>https://registry.npmmirror.com/</code></td></tr>
<tr><td>Docker Hub</td><td><code>https://registry-1.docker.io/*</code></td><td><code>https://dockerhub.azk8s.cn/</code></td></tr>
<tr><td>RubyGems</td><td><code>https://rubygems.org/*</code></td><td><code>https://gems.ruby-china.com/</code></td></tr>
</tbody></table>
</div>
<p><em>注意：镜像服务地址可能会发生变化，请以最新信息为准。</em></p>
<hr />
<p><strong>快速开始总结</strong>：</p>
<ol>
<li>创建 <code>net-access.yaml</code> 文件</li>
<li>复制相应场景的配置示例</li>
<li>设置环境变量（可选）</li>
<li>放置配置文件到正确位置</li>
<li>验证配置是否生效</li>
</ol>
<p>祝您使用愉快！🎉</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl-介绍"><a class="header" href="#gxl-介绍">GXL 介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl-语法帮助文档"><a class="header" href="#gxl-语法帮助文档">GXL 语法帮助文档</a></h1>
<h2 id="概述-9"><a class="header" href="#概述-9">概述</a></h2>
<p>GXL（Galaxy Flow Language）是一种为 DevSecOps 自动化工作流设计的领域特定语言。它采用模块化、层次化的结构设计，支持环境配置、流程编排、函数定义和活动重用等核心功能。</p>
<h2 id="语言结构"><a class="header" href="#语言结构">语言结构</a></h2>
<h3 id="顶层结构"><a class="header" href="#顶层结构">顶层结构</a></h3>
<p>GXL 文件由一系列模块定义组成，每个模块包含环境、流程、函数和活动等组件：</p>
<pre><code class="language-gxl">// 外部模块引用
extern mod mod_a { path = "@{PATH}"; }

// 模块定义
mod my_module : mod_a, mod_b {
    // 模块属性
    author = "John Doe";
    version = "1.0";
    
    // 环境定义
    env dev {
        root = "${HOME}/project";
    }
    
    // 流程定义
    flow main {
        gx.echo(value: "Hello World");
    }
    
    // 函数定义
    fn greet(name) {
        gx.echo(value: "Hello, ${name}!");
    }
    
    // 活动定义
    activity task_runner {
        timeout = "30s";
        retry_count = 3;
    }
}
</code></pre>
<h3 id="核心组件"><a class="header" href="#核心组件">核心组件</a></h3>
<h4 id="1-模块modules"><a class="header" href="#1-模块modules">1. 模块（Modules）</a></h4>
<p>模块是 GXL 的顶层组织单元，用于组织相关的环境、流程、函数和活动。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">[Annotation] mod ModuleName [: ModuleRefList] {
    ModuleContent
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">#[author("John Doe")]
#[version("1.0")]
mod main : utils, common {
    author = "John Doe";
    version = "1.0";
    
    env production {
        root = "/app/production";
    }
}
</code></pre>
<h4 id="2-环境environments"><a class="header" href="#2-环境environments">2. 环境（Environments）</a></h4>
<p>环境用于配置不同的执行上下文，支持环境继承和变量定义。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">[Annotation] env EnvName [: EnvRefList] {
    EnvContent
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">env base {
    log_level = "info";
}

env development : base {
    root = "${HOME}/dev";
    debug = true;
    
    gx.read_cmd(
        name: "DEV_PATH",
        cmd: "pwd"
    );
}
</code></pre>
<p><strong>环境专用命令：</strong></p>
<ul>
<li><code>gx.vars</code> - 定义变量</li>
<li><code>gx.read_cmd</code> - 从命令输出读取变量</li>
<li><code>gx.read_stdin</code> - 从标准输入读取变量</li>
<li><code>gx.read_file</code> - 从文件读取变量</li>
</ul>
<h4 id="3-流程flows"><a class="header" href="#3-流程flows">3. 流程（Flows）</a></h4>
<p>流程表示工作流程序，支持定义形式。</p>
<p><strong>定义流程语法：</strong></p>
<pre><code class="language-gxl">[Annotation] flow [FlowRefList |] @FlowName [| FlowRefList] {
    FlowContent
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">// 定义流程
#[usage("主流程")]
flow setup | @main | cleanup {
    gx.echo(value: "Starting main process");
    
    // 条件分支
    if ${DEBUG} == "true" {
        gx.echo(value: "Debug mode enabled");
    } else {
        gx.echo(value: "Production mode");
    }
    
    // 通配符比较
    if ${VERSION} =* "1.*" {
        gx.echo(value: "Version 1.x detected");
    }
}
</code></pre>
<p><strong>流程编排：</strong></p>
<pre><code class="language-gxl">flow prepare {
    gx.echo(value: "Preparing environment");
}

flow process {
    gx.echo(value: "Processing data");
}

flow finalize {
    gx.echo(value: "Finalizing process");
}

// 执行顺序: prepare -&gt; process -&gt; finalize
flow @main | process | finalize {
    gx.echo(value: "Main process");
}

// 执行顺序: prepare -&gt; main -&gt; finalize
flow prepare | @main | finalize {
    gx.echo(value: "Main process with preparation");
}
</code></pre>
<h4 id="4-函数functions"><a class="header" href="#4-函数functions">4. 函数（Functions）</a></h4>
<p>函数是可重用的代码单元，支持参数传递和返回值。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">[Annotation] fn FunctionName([FunctionParams]) {
    FunctionContent
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">fn greet(name, message = "Hello") {
    gx.echo(value: "${message}, ${name}!");
}

fn deploy_service(service, *env) {
    gx.echo(value: "Deploying ${service} to ${env}");
    gx.cmd(cmd: "kubectl apply -f ${service}.yaml");
}
</code></pre>
<h4 id="5-活动activities"><a class="header" href="#5-活动activities">5. 活动（Activities）</a></h4>
<p>活动是可重用的操作单元，通常用于封装复杂的操作逻辑。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">[Annotation] activity ActivityName {
    ActivityContent
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">#[timeout("30s")]
activity file_copy {
    src = "";
    dst = "";
    log = "true";
    retry_count = 3;
    executor = "copy_act.sh";
}

// 活动调用
flow copy_files {
    file_copy(
        src: "/source/file.txt",
        dst: "/destination/file.txt"
    );
}
</code></pre>
<h2 id="内置命令"><a class="header" href="#内置命令">内置命令</a></h2>
<p>GXL 提供了丰富的内置命令，使用函数调用语法：</p>
<h3 id="1-gxecho"><a class="header" href="#1-gxecho">1. gx.echo</a></h3>
<p>输出消息到控制台。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.echo(value: "message");
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.echo(value: "Hello World");
gx.echo(value: "Variable value: ${VAR}");
</code></pre>
<h3 id="2-gxcmd"><a class="header" href="#2-gxcmd">2. gx.cmd</a></h3>
<p>执行系统命令。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.cmd(cmd: "command");
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.cmd(cmd: "ls -la");
gx.cmd(cmd: "kubectl get pods");
</code></pre>
<h3 id="3-gxvars"><a class="header" href="#3-gxvars">3. gx.vars</a></h3>
<p>定义变量。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.vars {
    name: "value"
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.vars {
    APP_NAME: "my-app",
    VERSION: "1.0.0"
}
</code></pre>
<h3 id="4-gxread"><a class="header" href="#4-gxread">4. gx.read</a></h3>
<p>读取文件内容。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.read(file: "path", name: "var_name");
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.read(file: "config.json", name: "config");
</code></pre>
<h3 id="5-gxtpl"><a class="header" href="#5-gxtpl">5. gx.tpl</a></h3>
<p>模板渲染。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.tpl(template: "template.tpl", output: "output.txt");
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.tpl(template: "deploy.yaml.tpl", output: "deploy.yaml");
</code></pre>
<h3 id="6-gxassert"><a class="header" href="#6-gxassert">6. gx.assert</a></h3>
<p>断言检查。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.assert(condition: "expression", message: "error message");
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.assert(condition: "${STATUS} == 'success'", message: "Operation failed");
</code></pre>
<h3 id="7-gxver"><a class="header" href="#7-gxver">7. gx.ver</a></h3>
<p>版本检查。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">gx.ver(version: "required_version");
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">gx.ver(version: "1.0.0");
</code></pre>
<h2 id="变量和引用"><a class="header" href="#变量和引用">变量和引用</a></h2>
<h3 id="变量定义"><a class="header" href="#变量定义">变量定义</a></h3>
<pre><code class="language-gxl">// 在环境中定义
env dev {
    app_name = "my-app";
    version = "1.0.0";
}

// 使用 gx.vars 定义
gx.vars {
    BUILD_ID: "12345",
    TIMESTAMP: "2023-01-01"
}
</code></pre>
<h3 id="变量引用"><a class="header" href="#变量引用">变量引用</a></h3>
<pre><code class="language-gxl">// 环境变量引用
${HOME}
${PATH}

// GXL 变量引用
${app_name}
${version}

// 嵌套引用
${${PREFIX}_name}
</code></pre>
<h3 id="外部模块引用"><a class="header" href="#外部模块引用">外部模块引用</a></h3>
<pre><code class="language-gxl">// 路径引用
extern mod utils { path = "@{PATH}/utils"; }

// Git 引用
extern mod common {
    git = "https://github.com/example/common.git",
    channel = "main"
}
</code></pre>
<h2 id="注解annotations"><a class="header" href="#注解annotations">注解（Annotations）</a></h2>
<p>注解用于为模块、环境、流程等添加元数据。</p>
<p><strong>语法：</strong></p>
<pre><code class="language-gxl">#[AnnotationName[(param: "value")]]
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-gxl">#[author("John Doe")]
#[version("1.0")]
#[usage("主流程")]
#[timeout("30s")]
mod main {
    // 内容
}
</code></pre>
<h2 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h2>
<h3 id="if-else-语句"><a class="header" href="#if-else-语句">if-else 语句</a></h3>
<pre><code class="language-gxl">flow check_version {
    if ${VERSION} == "1.0" {
        gx.echo(value: "Version 1.0 detected");
    } else {
        gx.echo(value: "Other version detected");
    }
}
</code></pre>
<h3 id="通配符比较"><a class="header" href="#通配符比较">通配符比较</a></h3>
<pre><code class="language-gxl">flow check_pattern {
    if ${VERSION} =* "1.*" {
        gx.echo(value: "Version 1.x detected");
    }
    
    if ${NAME} =* "test-*" {
        gx.echo(value: "Test environment detected");
    }
}
</code></pre>
<h2 id="最佳实践-7"><a class="header" href="#最佳实践-7">最佳实践</a></h2>
<h3 id="1-模块组织"><a class="header" href="#1-模块组织">1. 模块组织</a></h3>
<pre><code class="language-gxl">// 将相关功能组织到模块中
mod database {
    env production {
        host = "db.prod.example.com";
        port = 5432;
    }
    
    flow backup {
        gx.cmd(cmd: "pg_dump ${DB_NAME} &gt; backup.sql");
    }
}

mod deployment {
    env staging {
        k8s_context = "staging-cluster";
    }
    
    flow deploy {
        gx.cmd(cmd: "kubectl apply -f deployment.yaml");
    }
}
</code></pre>
<h3 id="2-环境继承"><a class="header" href="#2-环境继承">2. 环境继承</a></h3>
<pre><code class="language-gxl">// 基础环境
env base {
    log_level = "info";
    timeout = "30s";
}

// 继承基础环境
env development : base {
    debug = true;
    root = "${HOME}/dev";
}

env production : base {
    debug = false;
    root = "/app";
}
</code></pre>
<h3 id="3-错误处理"><a class="header" href="#3-错误处理">3. 错误处理</a></h3>
<pre><code class="language-gxl">flow safe_operation {
    gx.assert(condition: "${FILE_EXISTS} == 'true'", 
               message: "File does not exist");
    
    if ${STATUS} != "success" {
        gx.echo(value: "Operation failed, rolling back");
        // 回滚逻辑
    }
}
</code></pre>
<h3 id="4-参数化函数"><a class="header" href="#4-参数化函数">4. 参数化函数</a></h3>
<pre><code class="language-gxl">fn deploy(app, env, version = "latest") {
    gx.echo(value: "Deploying ${app} version ${version} to ${env}");
    
    if ${env} == "production" {
        gx.assert(condition: "${version} != 'latest'", 
                   message: "Cannot deploy latest to production");
    }
    
    gx.cmd(cmd: "kubectl set image deployment/${app} ${app}=${app}:${version}");
}

// 使用函数
flow main {
    deploy("my-app", "staging");
    deploy("my-app", "production", "1.2.3");
}
</code></pre>
<h2 id="执行方式"><a class="header" href="#执行方式">执行方式</a></h2>
<h3 id="命令行执行"><a class="header" href="#命令行执行">命令行执行</a></h3>
<pre><code class="language-bash"># 执行指定环境的流程
gflow -e dev main

# 执行多个流程
gflow -e prod setup,deploy,test

# 使用默认环境
gflow main
</code></pre>
<h3 id="模块加载"><a class="header" href="#模块加载">模块加载</a></h3>
<p>只有 <code>envs</code> 和 <code>main</code> 两个模块中的环境和流程可以直接通过 CLI 加载执行。</p>
<pre><code class="language-gxl">mod envs {
    env dev {}
    env prod {}
}

mod main {
    flow deploy {}
    flow test {}
}
</code></pre>
<h2 id="常见问题-3"><a class="header" href="#常见问题-3">常见问题</a></h2>
<h3 id="q-如何调试-gxl-脚本"><a class="header" href="#q-如何调试-gxl-脚本">Q: 如何调试 GXL 脚本？</a></h3>
<p>A: 使用 <code>gx.echo</code> 输出变量值和执行状态，在开发环境中设置 <code>debug = true</code>。</p>
<h3 id="q-如何处理敏感信息"><a class="header" href="#q-如何处理敏感信息">Q: 如何处理敏感信息？</a></h3>
<p>A: 使用环境变量或配置文件存储敏感信息，避免在 GXL 文件中硬编码密码等敏感数据。</p>
<h3 id="q-如何优化流程执行性能"><a class="header" href="#q-如何优化流程执行性能">Q: 如何优化流程执行性能？</a></h3>
<p>A: 合理使用流程编排，避免重复操作，使用函数封装常用逻辑，适当使用并行执行。</p>
<h3 id="q-如何处理依赖关系"><a class="header" href="#q-如何处理依赖关系">Q: 如何处理依赖关系？</a></h3>
<p>A: 使用模块引用和环境继承来管理依赖，确保执行顺序正确。</p>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<p>GXL 是一个功能强大的 DevSecOps 自动化语言，通过模块化设计、环境配置、流程编排和函数重用等特性，可以帮助用户构建复杂的自动化工作流。掌握 GXL 语法和最佳实践，可以显著提高工作效率和代码质量。</p>
<hr />
<p><em>本文档基于 GXL 语法定义和实现代码编写，如需了解更详细的技术实现，请参考相关源代码文件。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量定义-1"><a class="header" href="#变量定义-1">变量定义</a></h1>
<h2 id="示例-3"><a class="header" href="#示例-3">示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    one= "one";
    sys_a = { mod1 : "A", mod2 : "B" , mod3: 1 , mod4 : 2};
    sys_b =  [ "C", "D" ];
    sys_c = ${SYS_B[1]} ;
    sys_d = ${SYS_A.MOD1} ;
<span class="boring">}</span></code></pre></pre>
<h2 id="规则"><a class="header" href="#规则">规则</a></h2>
<p>在GXL内 变量名不区分大小写</p>
<h2 id="使用示例-2"><a class="header" href="#使用示例-2">使用示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
    env default   {
      data_list =  [ "JAVA", "RUST", "PYTHON"] ;
      data_obj =  { 
        JAVA : { NAME: "JAVA", SCORE: 80 }, 
        RUST : { NAME: "RUST", SCORE: 100 }, 
        PYTHON : { NAME: "PYTHON", SCORE: 200} 
        } ;
    }
}
mod main   {
  flow array_do{
    for ${CUR} in ${ENV_DATA_LIST} {
      gx.echo( "CUR:${CUR}" );
    }
  }
  flow obj_do{
    for ${CUR} in ${ENV_DATA_OBJ} {
      gx.echo( "CUR:${CUR.NAME} : ${CUR.SCORE}" );
    }
  }

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="内置常量"><a class="header" href="#内置常量">内置常量</a></h2>
<ul>
<li>GXL_PRJ_ROOT:   最近定义了 _gal/project.toml 的目录</li>
<li>GXL_START_ROOT:  GXL 启动处理的目录</li>
<li>GXL_CUR_DIR:  GXL 当前所在目录，在调用gx.run时，与GXL_START_ROOT可能不同</li>
<li>GXL_CMD_ARG:  gflow -- &lt;cmd_arg&gt;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl-文件语法"><a class="header" href="#gxl-文件语法">GXL 文件语法</a></h1>
<h2 id="gxl-语法定义"><a class="header" href="#gxl-语法定义">GXL 语法定义</a></h2>
<p>GXL（Galaxy Flow Language）是一种为 DevSecOps 自动化工作流设计的领域特定语言。根据代码库中的信息，GXL 的语法定义主要在 galaxy-sec/galaxy-flow 仓库的解析器模块中实现。</p>
<h3 id="gxl-语法结构"><a class="header" href="#gxl-语法结构">GXL 语法结构</a></h3>
<p>GXL 语言遵循模块化、层次化的结构，主要由以下核心组件组成：</p>
<ul>
<li>模块（Modules）：使用 mod 关键字定义，是 GXL 的顶层组织单元</li>
<li>环境（Environments）：使用 env 关键字定义，用于配置不同的执行上下文</li>
<li>流程（Flows）：使用 flow 关键字定义，表示工作流程序</li>
<li>函数（Functions）：使用 fn 关键字定义，可重用的函数单元</li>
<li>活动（Activities）：使用 activity 关键字定义，可重用的操作单元，在模块级别定义</li>
</ul>
<h2 id="ebnf-语法"><a class="header" href="#ebnf-语法">EBNF 语法</a></h2>
<pre><code class="language-EBNF">
(* GXL 文件由一系列模块定义组成 *)
GXL-File = {Module};

(* 模块定义 *)
Module = [Annotation], "mod", whitespace, ModuleName, [whitespace, ":", whitespace, ModuleRefList], whitespace, "{", whitespace, ModuleContent, whitespace, "}", whitespace, ";";
ModuleName = Identifier;
ModuleRefList = ModuleRef, {",", whitespace, ModuleRef};
ModuleRef = Identifier;
ModuleContent = {Property | Environment | Flow | Function | Activity};

(* 属性定义 (键值对) *)
Property = PropertyName, whitespace, "=", whitespace, PropertyValue, whitespace, ";";
PropertyName = Identifier;
PropertyValue = String;

(* 环境定义 *)
Environment = [Annotation], "env", whitespace, EnvName, [whitespace, ":", whitespace, EnvRefList], whitespace, "{", whitespace, EnvContent, whitespace, "}", whitespace, ";";
EnvName = Identifier;
EnvContent = {Property | EnvCommand};
EnvRefList = EnvRef, {",", whitespace, EnvRef};
EnvRef = Identifier;

(* 流程定义 - 定义形式 *)
Flow = [Annotation], (DefinitionFlow | ReferenceFlow);

(* 定义流程（管道分隔）*)
DefinitionFlow = "flow", whitespace, [FlowRefList, whitespace, "|"], whitespace, "@", FlowName, [whitespace, "|", whitespace, FlowRefList], whitespace, "{", whitespace, FlowContent, whitespace, "}", whitespace, ";";

(* 引用其他流程 *)
ReferenceFlow = "flow", whitespace, FlowName, whitespace, ":", whitespace, FlowRefList, whitespace, ";";
FlowName = Identifier;
FlowRefList = FlowRef, {",", whitespace, FlowRef};
FlowRef = Identifier;
FlowContent = {Command | Property};

(* 函数定义 *)
Function = [Annotation], "fn", whitespace, FunctionName, whitespace, "(", whitespace, [FunctionParams], whitespace, ")", whitespace, "{", whitespace, FunctionContent, whitespace, "}", whitespace, ";";
FunctionName = Identifier;
FunctionParams = FunctionParam, {",", whitespace, FunctionParam};
FunctionParam = ["*"], Identifier, [whitespace, "=", whitespace, String];
FunctionContent = {Command};

(* 活动定义 *)
Activity = [Annotation], "activity", whitespace, ActivityName, whitespace, "{", whitespace, ActivityContent, whitespace, "}", whitespace, ";";
ActivityName = Identifier;
ActivityContent = {Property};

(* 命令定义 *)
Command = (BuiltinCommand | ActivityCall), whitespace, ";";

(* 内置命令 - 使用函数调用语法 *)
BuiltinCommand = "gx.", CommandName, whitespace, "(", whitespace, CommandProps, whitespace, ")";
CommandName = "echo" | "vars" | "cmd" | "read" | "tpl" | "assert" | "ver";
CommandProps = {PropertyAssignment}, {",", whitespace, PropertyAssignment};
PropertyAssignment = PropertyName, whitespace, ":", whitespace, PropertyValue;

(* 环境专用命令 *)
EnvCommand = "gx.vars", whitespace, "{", whitespace, CommandProps, whitespace, "}"
           | "gx.read_cmd", whitespace, "(", whitespace, CommandProps, whitespace, ")"
           | "gx.read_stdin", whitespace, "(", whitespace, CommandProps, whitespace, ")"
           | "gx.read_file", whitespace, "(", whitespace, CommandProps, whitespace, ")";

(* 活动调用 *)
ActivityCall = ActivityName, whitespace, "(", whitespace, CommandProps, whitespace, ")";
ActivityName = Identifier, {".", Identifier};

(* 标识符 *)
Identifier = Alpha, {Alpha | Digit | "_"};
Alpha = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z";
Digit = "0" | "1" | ... | "9";

(* 字符串 *)
String = '"', {StringChar}, '"';
StringChar = UnescapedChar | EscapedChar;
UnescapedChar = ? 除了 " 和 \ 的任何字符 ?;
EscapedChar = "\\", ("\\" | '"');

(* 变量引用 *)
VariableRef = "${", VariableName, "}";
VariableName = Identifier;

(* 空白字符 *)
whitespace = {" " | "\t" | "\r" | "\n"};

(* 外部模块引用 *)
ExternModule = "extern", whitespace, "mod", whitespace, ModuleNameList, whitespace, "{", whitespace, ModuleSource, whitespace, "}", whitespace, ";";
ModuleNameList = ModuleName, {",", whitespace, ModuleName};
ModuleSource = PathSource | GitSource;
PathSource = "path", whitespace, "=", whitespace, String;
GitSource = "git", whitespace, "=", whitespace, String, whitespace, ",", whitespace, "channel", whitespace, "=", whitespace, String;

(* 注解 *)
Annotation = "#[", AnnotationName, ["(", AnnotationParams, ")"], "]";
AnnotationName = Identifier;
AnnotationParams = AnnotationParam, {",", whitespace, AnnotationParam};
AnnotationParam = Identifier, whitespace, "=", whitespace, String;
</code></pre>
<h2 id="实现代码对应关系"><a class="header" href="#实现代码对应关系">实现代码对应关系</a></h2>
<h3 id="1-模块解析实现"><a class="header" href="#1-模块解析实现">1. 模块解析实现</a></h3>
<p><strong>EBNF</strong>: <code>Module = [Annotation], "mod", ...</code>
<strong>实现位置</strong>: <mcfile name="stc_mod.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_mod.rs"></mcfile>
<strong>主要函数</strong>: <mcsymbol name="gal_stc_mod" filename="stc_mod.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_mod.rs" startline="40" type="function"></mcsymbol>
<strong>功能</strong>: 解析模块定义，支持注解、模块引用列表、属性和环境/流程/函数/活动内容</p>
<h3 id="2-环境解析实现"><a class="header" href="#2-环境解析实现">2. 环境解析实现</a></h3>
<p><strong>EBNF</strong>: <code>Environment = [Annotation], "env", ...</code>
<strong>实现位置</strong>: <mcfile name="stc_env.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_env.rs"></mcfile>
<strong>主要函数</strong>: <mcsymbol name="gal_stc_env" filename="stc_env.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_env.rs" startline="48" type="function"></mcsymbol>
<strong>功能</strong>: 解析环境定义，支持注解、环境引用列表、属性和环境专用命令</p>
<h3 id="3-流程解析实现"><a class="header" href="#3-流程解析实现">3. 流程解析实现</a></h3>
<p><strong>EBNF</strong>: <code>Flow = [Annotation], (DefinitionFlow | ReferenceFlow)</code>
<strong>实现位置</strong>: <mcfile name="stc_flow/head.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_flow/head.rs"></mcfile>
<strong>主要函数</strong>: <mcsymbol name="galaxy_flow_head" filename="head.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_flow/head.rs" startline="15" type="function"></mcsymbol>
<strong>功能</strong>: 解析流程头部，支持两种语法形式（定义、引用流程）
<strong>流程体解析</strong>: <mcsymbol name="gal_stc_flow_body" filename="body.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/stc_flow/body.rs" startline="11" type="function"></mcsymbol></p>
<h3 id="4-基础元素解析实现"><a class="header" href="#4-基础元素解析实现">4. 基础元素解析实现</a></h3>
<p><strong>EBNF</strong>: <code>Identifier</code>, <code>String</code>, <code>VariableRef</code>
<strong>实现位置</strong>: <mcfile name="atom.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/atom.rs"></mcfile>
<strong>主要函数</strong>:</p>
<ul>
<li><mcsymbol name="take_var_ref_name" filename="atom.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/atom.rs" startline="47" type="function"></mcsymbol> - 解析变量引用</li>
<li><mcsymbol name="take_dot_pair" filename="atom.rs" path="/Users/zuowenjian/devspace/galaxy/galaxy-flow/src/parser/atom.rs" startline="30" type="function"></mcsymbol> - 解析点分隔标识符</li>
</ul>
<h2 id="示例-4"><a class="header" href="#示例-4">示例</a></h2>
<pre><code class="language-gxl">env dev {
    root = "${HOME}/my_project";
    gx.read_cmd (
        name : "MY_PATH",
        cmd  : "pwd"
    );
}
</code></pre>
<pre><code class="language-gxl">#[author("John Doe")]
#[version("1.0")]
mod my_module : mod_a, mod_b {
    # 模块属性
    author = "John Doe";
    version = "1.0";

    # 环境定义
    env test {
        root = "${HOME}/test_project";
        gx.read_cmd (
            name : "TEST_PATH",
            cmd  : "ls"
        );
    }

    # 函数定义
    fn echo_message(msg) {
        gx.echo (value : msg);
    }

    # 活动定义
    activity task_runner {
        timeout = "30s";
        retry_count = 3;
    }

    # 流程定义 - 定义流程
    flow before_flow | @my_flow | after_flow {
        gx.echo (value : "Hello from my_flow");
        task_runner.run (
            param1 : "value1",
            param2 : "value2"
        );
    }

    # 流程定义 - 定义流程（管道分隔）
    flow before_flow | @main_flow | after_flow {
        gx.echo (value : "Pipeline flow execution");
    }

    # 引用流程
    flow reference_flow : my_flow, other_flow;
}
</code></pre>
<h3 id="外部模块引用示例"><a class="header" href="#外部模块引用示例">外部模块引用示例</a></h3>
<pre><code class="language-gxl">extern mod mod_a { path = "@{PATH}"; }
extern mod mod_b { 
    git = "https://github.com/example/repo.git", 
    channel = "main" 
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示例-5"><a class="header" href="#示例-5">示例</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-示例"><a class="header" href="#assert-示例">Assert 示例</a></h1>
<h2 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path= "../../_gal/mods"; }
mod base_env {
    env _common {
      gx.vars {
        DOMAIN    = "domain" ;
      }
    }
    env cli : _common {
      ROOT   = "./";

    }
    env unit_test : _common {
      ROOT   = "./example";
    }
}
mod envs : base_env {
    #[usage(desp="default")]
    env default : cli ;
    env empty {}
    env ut : unit_test  ;
}
mod base{
  mod_val = "1";
  flow define {
    base = "BASE";
  }
  #[auto_load(entry)]
  flow base_into  {
    base_begin = "BASE_INTO";
  }
  #[auto_load(exit)]
  flow base_exit {
    base_end = "BASE_EXIT";
  }
}
mod other {
  flow def1 {
    other_val = "OTHER_DEF";
  }
  flow def2{
    other_val = "OTHER_DEF2";
  }
}
mod main   {
  conf = "${ENV_ROOT}/conf" ;

  #[auto_load(entry)]
  flow __into  | other.def1  {
    other_val = "OTHER_DE1";
  }
  #[auto_load(exit)]
  flow __exit | other.def2 ;
  #[usage(desp="main")]
  flow assert_main {
    one= "one";
    sys_a = { mod1 : "A", mod2 : "B" };
    sys_b =  [ "C", "D" ];
    sys_c = ${SYS_B[1]} ;
    sys_d = ${SYS_A.MOD1} ;
    gx.assert ( value : "${MAIN_CONF}" , expect : "${ENV_ROOT}/conf" );
    gx.assert ( value : "${OTHER_VAL}" , expect : "OTHER_DEF" );
    gx.assert ( value : "${SYS_A.MOD1}" , expect : "A" );
    gx.assert ( value : "${sys_a.mod1}" , expect : "A" );
    gx.assert ( value : "${sys_b[0]}" , expect : "C" );
    gx.assert ( value : "${sys_d}" , expect : "A" );
  }

  flow base.define | @assert_parent   {
    gx.assert ( value : "${MAIN_CONF}" , expect : "${ENV_ROOT}/conf" );
    gx.assert ( value : "${BASE_MOD_VAL}" , expect : "1" );
    gx.assert ( value : "${OTHER_VAL}" , expect : "OTHER_DEF" );
    gx.assert ( value : "${BASE}" , expect : "BASE" );
    gx.assert ( value : "${BASE_BEGIN}" , expect : "BASE_INTO" );
  }

}
<span class="boring">}</span></code></pre></pre>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.assert</code> 命令进行断言检查。在 <code>assert_main</code> 流程中，多个 <code>gx.assert</code> 命令用于验证变量的值是否符合预期。在 <code>base.define</code> 流程中，也使用了 <code>gx.assert</code> 来验证环境变量和模块变量的值。</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load base_env]
    B --&gt; C[Load envs]
    C --&gt; D[Load base module]
    D --&gt; E[Load other module]
    E --&gt; F[Load main module]
    F --&gt; G[Execute __into flow]
    G --&gt; H[Execute assert_main flow]
    H --&gt; I[Execute gx.assert commands]
    I --&gt; J[Execute base.define flow]
    J --&gt; K[Execute more gx.assert commands]
    K --&gt; L[Execute __exit flow]
    L --&gt; M[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dryrun-example"><a class="header" href="#dryrun-example">Dryrun Example</a></h1>
<p>This example demonstrates the dryrun functionality in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {

env default {}

flow _step1 {
    gx.echo ("step1");
}

#[dryrun(_step3)]
flow _step2 {
    gx.echo ("step2");
    gx.assert ( value : "true" , expect : "false" );
}

flow _step3 {
    gx.echo ("dryrun setp2");
}

flow start | _step1 | _step2 ;

}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load main module]
    B --&gt; C[Execute start flow]
    C --&gt; D[Execute _step1 flow]
    D --&gt; E[Execute _step2 flow]
    E --&gt; F{Assertion fails?}
    F --&gt;|Yes| G[Execute _step3 flow]
    F --&gt;|No| H[End]
    G --&gt; I[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fun-example"><a class="header" href="#fun-example">Fun Example</a></h1>
<p>This example demonstrates how to define and use functions in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod sys {
    fun echo(name) {
        gx.echo("echo:${name}");
    }
    fun echo_obj(obj) {
        gx.echo("echo_obj:${obj}");
    }
    fun echo_list(list) {
        gx.echo("echo_list:${list}");
    }
}

mod envs {
    env default {
        DATA = [
            "JAVA",
            "RUST",
            "PYTHON",
        ];
        OBJ = {
            name: "test",
            value: "value",
        };
    }
}

mod main {
    flow conf {
        sys.echo("test");
        sys.echo_obj("${OBJ}");
        sys.echo_list("${DATA}");
    }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load sys module]
    B --&gt; C[Define echo functions]
    C --&gt; D[Load envs module]
    D --&gt; E[Load main module]
    E --&gt; F[Execute conf flow]
    F --&gt; G[Call sys.echo function]
    G --&gt; H[Call sys.echo_obj function]
    H --&gt; I[Call sys.echo_list function]
    I --&gt; J[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-示例"><a class="header" href="#read-示例">Read 示例</a></h1>
<h2 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path= "../../_gal/mods"; }
mod envs {
    env _dev_local {
        gx.read_file ( file : "./var.ini" );
    }
    env default : _dev_local ;
}
mod main   {
  flow conf  {
    gx.echo (  "${RUST}" );
    gx.echo (  "${JAVA}" );
    gx.assert ( value : "${JAVA}" , expect : "90"  );

    gx.read_cmd (
        //fail!
        //cmd  : r#"git branch --show-current |  sed -E "s/(feature|develop|ver-dev|release|master|issue)(\/\.*)?/_branch_\1/g" "# ,
        //suc!
        cmd  : "git branch --show-current | sed -E 's/release/rls/g'" ,
        name : "GIT_BRANCH" );

    gx.echo ( "what:${GIT_BRANCH}" );

    gx.read_file ( file : "./var2.ini" , name : "DATA");

    for ${CUR} in ${DATA} {
        gx.echo ( value : "${CUR}" );
    }
  }



}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Execute _dev_local env]
    C --&gt; D[Execute gx.read_file command]
    D --&gt; E[Load main module]
    E --&gt; F[Execute conf flow]
    F --&gt; G[Execute gx.echo commands]
    G --&gt; H[Execute gx.read_cmd command]
    H --&gt; I[Execute gx.echo command]
    I --&gt; J[Execute gx.read_file command]
    J --&gt; K[Loop through DATA]
    K --&gt; L[Execute gx.echo command for each item]
    L --&gt; M[End]
</pre>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.read</code> 命令从不同来源读取数据。在 <code>_dev_local</code> 环境中，使用 <code>gx.read_file</code> 从 <code>var.ini</code> 文件读取数据。在 <code>conf</code> 流程中，使用 <code>gx.read_cmd</code> 执行 Git 命令并捕获输出，以及使用 <code>gx.read_file</code> 从 <code>var2.ini</code> 文件读取数据。还展示了如何遍历读取的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-example"><a class="header" href="#shell-example">Shell Example</a></h1>
<p>This example demonstrates how to execute shell commands in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod envs {
    env _dev_local {}
    env default : _dev_local;
}

mod main {
    flow conf {
        gx.read_file(file: "./var.yml", name: "VAR");
        gx.echo("what:${VAR.MEMBER.JAVA}");

        gx.shell(
            arg_file: "./var.json",
            shell: "./demo.sh",
            out_var: "SYS_OUT");

        gx.echo("what:${SYS_OUT}");

        gx.read_file(file: "./var_list.yml", name: "DATA");
        for ${CUR} in ${DATA.DEV_LANG} {
            gx.shell(
                shell: "./demo_ex.sh ${CUR}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }

        gx.read_file(file: "./var_obj.yml", name: "DATA");
        for ${CUR} in ${DATA} {
            gx.shell(
                shell: "./demo_ex.sh ${CUR.SYS.NAME}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }
    }
    flow do_obj {
        gx.read_file(file: "./var_obj.yml", name: "DATA");
        for ${CUR} in ${DATA} {
            //gx.echo( "CUR:${CUR.SYS.NAME}" );
            gx.shell(
                shell: "./demo_ex.sh ${CUR.SYS.NAME}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="说明-2"><a class="header" href="#说明-2">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.shell</code> 命令执行 shell 脚本。在 <code>conf</code> 流程中，首先从 <code>var.yml</code> 文件读取数据，然后使用 <code>gx.shell</code> 执行 <code>demo.sh</code> 脚本，并通过 <code>arg_file</code> 参数传递 <code>var.json</code> 文件。还展示了如何在循环中执行 shell 脚本，并处理列表和对象数据。</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Load main module]
    C --&gt; D[Execute conf flow]
    D --&gt; E[Execute gx.read_file command]
    E --&gt; F[Execute gx.echo command]
    F --&gt; G[Execute gx.shell command]
    G --&gt; H[Execute gx.echo command]
    H --&gt; I[Execute gx.read_file command]
    I --&gt; J[Loop through DATA.DEV_LANG]
    J --&gt; K[Execute gx.shell command for each item]
    K --&gt; L[Execute gx.echo command]
    L --&gt; M[Execute gx.read_file command]
    M --&gt; N[Loop through DATA]
    N --&gt; O[Execute gx.shell command for each item]
    O --&gt; P[Execute gx.echo command]
    P --&gt; Q[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-example"><a class="header" href="#template-example">Template Example</a></h1>
<p>This example demonstrates how to use templates in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod base_env {
    env _common {
        gx.vars {
            DOMAIN = "domain";
            SOCK_FILE = "socket";
            GXL_PRJ_ROOT = "./";
        }
    }
    env cli : _common {
        ROOT = "./";
    }
    env unit_test : _common {
        ROOT = "./example";
    }
}

mod envs : base_env {
    #[usage(desp = "default")]
    env default : cli;
    env empty {}
    env ut : unit_test;
}

mod main {
    conf = "${ENV_ROOT}/conf";
    flow conf {
        os.path(dst: "${MAIN_CONF}/used", keep: "true");
        gx.tpl(
            tpl: "${MAIN_CONF}/tpls/",
            dst: "${MAIN_CONF}/used/",
            file: "${MAIN_CONF}/value.json");

        ```cmd
        echo "hello";
        cp ./conf/value.json ./conf/used/back.json;
        ```
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>This example shows how to use the <code>gx.tpl</code> command to process template files. In the <code>conf</code> flow, the <code>os.path</code> command is first used to create the target directory, then the <code>gx.tpl</code> command renders template files from the <code>tpls</code> directory based on values in the <code>value.json</code> file and outputs them to the <code>used</code> directory. Finally, an inline shell command block is shown to copy a file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-example"><a class="header" href="#transaction-example">Transaction Example</a></h1>
<p>This example demonstrates how to use transactions in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod base { path = "./_gal/"; }

mod envs {
    env default {};
}

mod main {
    flow trans1 | step1 | step2 | base.base_step1 | step3;
    flow trans2 | step1 | step3 | step2;

    #[transaction, undo(_undo_step1)]
    flow step1 {
        gx.echo(" step1 ");
    }
    #[undo(_undo_step2)]
    flow step2 {
        gx.echo(" step2 ");
    }
    #[undo(_undo_step3)]
    flow step3 {
        gx.echo(" step3 ");
        gx.assert(value: "true", expect: "false");
    }

    flow _undo_step1 {
        gx.echo(" undo step1 ");
    }
    flow _undo_step2 {
        gx.echo(" undo step2 ");
    }
    flow _undo_step3 {
        gx.echo(" undo step3 ");
    }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load base module]
    B --&gt; C[Load envs module]
    C --&gt; D[Load main module]
    D --&gt; E[Define flows]
    E --&gt; F[Execute trans1 flow]
    F --&gt; G[Execute step1 flow]
    G --&gt; H[Execute step2 flow]
    H --&gt; I[Execute base.base_step1 flow]
    I --&gt; J[Execute step3 flow]
    J --&gt; K[Execute trans2 flow]
    K --&gt; L[Execute step1 flow]
    L --&gt; M[Execute step3 flow]
    M --&gt; N[Execute step2 flow]
    N --&gt; O[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vars-example"><a class="header" href="#vars-example">Vars Example</a></h1>
<p>This example demonstrates how to define and use variables in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
    env default {
        data_list = [
            "JAVA",
            "RUST",
            "PYTHON",
        ];
        data_obj = {
            JAVA: { NAME: "JAVA", SCORE: 80 },
            RUST: { NAME: "RUST", SCORE: 100 },
            PYTHON: { NAME: "PYTHON", SCORE: 200 },
        };
    }
}

mod main {
    flow array_do {
        for ${CUR} in ${ENV.DATA_LIST} {
            gx.echo("CUR:${CUR}");
        }
    }
    flow obj_do {
        for ${CUR} in ${ENV.DATA_OBJ} {
            gx.echo("CUR:${CUR.NAME} : ${CUR.SCORE}");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>This example shows how to define variables in an environment and how to use these variables in flows. In the <code>default</code> environment, a list <code>data_list</code> and an object <code>data_obj</code> are defined. In the <code>array_do</code> flow, the <code>data_list</code> list is iterated over and each element is output. In the <code>obj_do</code> flow, the <code>data_obj</code> object is iterated over and the properties of each object are output.</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Define data_list and data_obj variables]
    C --&gt; D[Load main module]
    D --&gt; E[Execute array_do flow]
    E --&gt; F[Loop through ENV.DATA_LIST]
    F --&gt; G[Execute gx.echo command for each item]
    G --&gt; H[Execute obj_do flow]
    H --&gt; I[Loop through ENV.DATA_OBJ]
    I --&gt; J[Execute gx.echo command for each item]
    J --&gt; K[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="galaxy-flow-内置能力文档"><a class="header" href="#galaxy-flow-内置能力文档">Galaxy Flow 内置能力文档</a></h1>
<p>本文档详细描述了Galaxy Flow中所有内置能力的语法定义和使用示例。</p>
<h2 id="gxassert"><a class="header" href="#gxassert">gx.assert</a></h2>
<h3 id="功能描述"><a class="header" href="#功能描述">功能描述</a></h3>
<p>执行断言检查，验证表达式的值是否符合预期。</p>
<h3 id="语法定义"><a class="header" href="#语法定义">语法定义</a></h3>
<pre><code class="language-gxl">gx.assert {
  value: &lt;表达式&gt;,      // 要检查的值
  expect: &lt;期望值&gt;,     // 期望的值
  err: &lt;错误信息&gt;,      // 断言失败时的错误信息（可选）
  result: &lt;变量名&gt;      // 存储断言结果的变量名（可选）
}
</code></pre>
<h3 id="示例代码-2"><a class="header" href="#示例代码-2">示例代码</a></h3>
<pre><code class="language-gxl">// 检查变量值是否等于期望值
gx.assert {
  value: ${MY_VAR},
  expect: "expected_value",
  err: "MY_VAR值不正确"
}

// 检查表达式结果并存储结果
gx.assert {
  value: ${CALC_RESULT},
  expect: 42,
  result: "assert_result"
}
</code></pre>
<h2 id="gxcmd"><a class="header" href="#gxcmd">gx.cmd</a></h2>
<h3 id="功能描述-1"><a class="header" href="#功能描述-1">功能描述</a></h3>
<p>执行系统命令或脚本。</p>
<h3 id="语法定义-1"><a class="header" href="#语法定义-1">语法定义</a></h3>
<pre><code class="language-gxl">gx.cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  shell: &lt;Shell类型&gt;,    // 指定使用的Shell（可选）
  out: &lt;输出变量名&gt;,     // 捕获命令标准输出的变量名（可选）
  err: &lt;错误变量名&gt;,     // 捕获命令错误输出的变量名（可选）
  suc: &lt;成功标识&gt;,       // 命令执行成功的标识（可选）
  sudo: &lt;布尔值&gt;,        // 是否使用sudo权限执行（可选）
  log: &lt;日志级别&gt;,       // 日志记录级别（可选）
  silence: &lt;布尔值&gt;      // 是否静默执行（可选）
}
</code></pre>
<h3 id="示例代码-3"><a class="header" href="#示例代码-3">示例代码</a></h3>
<pre><code class="language-gxl">// 执行简单命令
gx.cmd {
  cmd: "ls -la"
}

// 执行命令并捕获输出
gx.cmd {
  cmd: "date",
  out: "current_date"
}

// 使用sudo权限执行命令
gx.cmd {
  cmd: "systemctl restart nginx",
  sudo: true
}
</code></pre>
<h2 id="gxecho"><a class="header" href="#gxecho">gx.echo</a></h2>
<h3 id="功能描述-2"><a class="header" href="#功能描述-2">功能描述</a></h3>
<p>输出文本信息到控制台。</p>
<h3 id="语法定义-2"><a class="header" href="#语法定义-2">语法定义</a></h3>
<pre><code class="language-gxl">gx.echo {
  value: &lt;文本内容&gt;,     // 要输出的文本内容
  file: &lt;文件路径&gt;,      // 输出到文件的路径（可选）
  export: &lt;变量名&gt;,      // 导出为环境变量的名称（可选）
  inc: &lt;布尔值&gt;          // 是否追加到文件末尾（可选）
}
</code></pre>
<h3 id="示例代码-4"><a class="header" href="#示例代码-4">示例代码</a></h3>
<pre><code class="language-gxl">// 输出简单文本
gx.echo {
  value: "Hello, Galaxy Flow!"
}

// 输出到文件
gx.echo {
  value: "This is a log entry",
  file: "app.log"
}

// 追加到文件
gx.echo {
  value: "Additional information",
  file: "app.log",
  inc: true
}

// 导出为环境变量
gx.echo {
  value: "production",
  export: "ENV_TYPE"
}
</code></pre>
<h2 id="gxread"><a class="header" href="#gxread">gx.read</a></h2>
<h3 id="功能描述-3"><a class="header" href="#功能描述-3">功能描述</a></h3>
<p>从不同来源读取数据并存储到变量中。</p>
<h3 id="语法定义-3"><a class="header" href="#语法定义-3">语法定义</a></h3>
<pre><code class="language-gxl">// 从文件读取
gx.read_file {
  file: &lt;文件路径&gt;,      // 要读取的文件路径
  name: &lt;变量名&gt;         // 存储文件内容的变量名
}

// 从标准输入读取
gx.read_stdin {
  name: &lt;变量名&gt;,        // 存储输入内容的变量名
  prompt: &lt;提示文本&gt;     // 输入提示文本（可选）
}

// 从命令输出读取
gx.read_cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  name: &lt;变量名&gt;,        // 存储命令输出的变量名
  shell: &lt;Shell类型&gt;     // 指定使用的Shell（可选）
}
</code></pre>
<h3 id="示例代码-5"><a class="header" href="#示例代码-5">示例代码</a></h3>
<pre><code class="language-gxl">// 从文件读取内容
gx.read_file {
  file: "config.json",
  name: "config_data"
}

// 从标准输入读取
gx.read_stdin {
  name: "user_input",
  prompt: "请输入您的姓名: "
}

// 从命令输出读取
gx.read_cmd {
  cmd: "git rev-parse HEAD",
  name: "commit_hash"
}
</code></pre>
<h2 id="gxvars"><a class="header" href="#gxvars">gx.vars</a></h2>
<h3 id="功能描述-4"><a class="header" href="#功能描述-4">功能描述</a></h3>
<p>定义和设置多个变量。</p>
<h3 id="语法定义-4"><a class="header" href="#语法定义-4">语法定义</a></h3>
<pre><code class="language-gxl">gx.vars {
  &lt;变量名1&gt;: &lt;值1&gt;,      // 变量名和对应的值
  &lt;变量名2&gt;: &lt;值2&gt;,      // 可以定义多个变量
  // ...
}
</code></pre>
<h3 id="示例代码-6"><a class="header" href="#示例代码-6">示例代码</a></h3>
<pre><code class="language-gxl">// 定义多个变量
gx.vars {
  app_name: "MyApp",
  version: "1.0.0",
  debug: true
}

// 使用变量引用
gx.vars {
  project_root: "${HOME}/projects",
  config_file: "${project_root}/config.yaml"
}
</code></pre>
<h2 id="gxtpl"><a class="header" href="#gxtpl">gx.tpl</a></h2>
<h3 id="功能描述-5"><a class="header" href="#功能描述-5">功能描述</a></h3>
<p>使用模板引擎处理文件模板。</p>
<h3 id="语法定义-5"><a class="header" href="#语法定义-5">语法定义</a></h3>
<pre><code class="language-gxl">gx.tpl {
  tpl: &lt;模板内容&gt;,       // 模板内容
  dst: &lt;目标文件路径&gt;,   // 生成文件的路径
  data: &lt;数据变量名&gt;,    // 模板数据变量名（可选）
  engine: &lt;引擎类型&gt;,    // 模板引擎类型（可选）
  file: &lt;模板文件路径&gt;   // 模板文件路径（可选，与tpl互斥）
}
</code></pre>
<h3 id="示例代码-7"><a class="header" href="#示例代码-7">示例代码</a></h3>
<pre><code class="language-gxl">// 使用内联模板
gx.tpl {
  tpl: "Hello, {{name}}! Welcome to {{app_name}}.",
  dst: "output.txt",
  data: "user_data"
}

// 使用模板文件
gx.tpl {
  file: "template.txt",
  dst: "output.txt",
  data: "template_data"
}
</code></pre>
<h2 id="gxver"><a class="header" href="#gxver">gx.ver</a></h2>
<h3 id="功能描述-6"><a class="header" href="#功能描述-6">功能描述</a></h3>
<p>管理和操作版本信息。</p>
<h3 id="语法定义-6"><a class="header" href="#语法定义-6">语法定义</a></h3>
<pre><code class="language-gxl">gx.ver {
  value: &lt;版本值&gt;,       // 版本值
  default: &lt;默认值&gt;,     // 默认版本值（可选）
  file: &lt;文件路径&gt;,      // 版本文件路径（可选）
  export: &lt;变量名&gt;,      // 导出版本信息的变量名（可选）
  inc: &lt;递增类型&gt;        // 版本递增类型（可选，可选值：build/bugfix/feature/main）
}
</code></pre>
<h3 id="示例代码-8"><a class="header" href="#示例代码-8">示例代码</a></h3>
<pre><code class="language-gxl">// 设置版本值
gx.ver {
  value: "1.2.3"
}

// 从文件读取版本并递增
gx.ver {
  file: "VERSION",
  inc: "feature"
}

// 导出版本信息
gx.ver {
  value: "2.0.0",
  export: "APP_VERSION"
}
</code></pre>
<h2 id="gxshell"><a class="header" href="#gxshell">gx.shell</a></h2>
<h3 id="功能描述-7"><a class="header" href="#功能描述-7">功能描述</a></h3>
<p>执行Shell脚本文件。</p>
<h3 id="语法定义-7"><a class="header" href="#语法定义-7">语法定义</a></h3>
<pre><code class="language-gxl">gx.shell {
  shell: &lt;脚本文件路径&gt;,  // 要执行的Shell脚本文件路径
  arg_file: &lt;参数文件&gt;,   // 参数文件路径（可选）
  out_var: &lt;输出变量名&gt;,  // 捕获脚本输出的变量名（可选）
  default: &lt;默认脚本&gt;     // 默认脚本文件路径（可选，与shell互斥）
}
</code></pre>
<h3 id="示例代码-9"><a class="header" href="#示例代码-9">示例代码</a></h3>
<pre><code class="language-gxl">// 执行Shell脚本
gx.shell {
  shell: "deploy.sh"
}

// 执行脚本并捕获输出
gx.shell {
  shell: "build.sh",
  out_var: "build_output"
}

// 使用参数文件
gx.shell {
  shell: "install.sh",
  arg_file: "install.args"
}
</code></pre>
<h2 id="gxdownload-和-gxupload"><a class="header" href="#gxdownload-和-gxupload">gx.download 和 gx.upload</a></h2>
<h3 id="功能描述-8"><a class="header" href="#功能描述-8">功能描述</a></h3>
<p>下载和上传文件。</p>
<h3 id="语法定义-8"><a class="header" href="#语法定义-8">语法定义</a></h3>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: &lt;下载URL&gt;,        // 文件下载URL
  local_file: &lt;本地路径&gt;, // 保存到本地的文件路径
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}

// 上传文件
gx.upload {
  url: &lt;上传URL&gt;,        // 文件上传URL
  local_file: &lt;本地路径&gt;, // 要上传的本地文件路径
  method: &lt;HTTP方法&gt;,     // HTTP方法（如POST、PUT等，默认POST）
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}
</code></pre>
<h3 id="示例代码-10"><a class="header" href="#示例代码-10">示例代码</a></h3>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: "https://example.com/file.zip",
  local_file: "downloaded_file.zip"
}

// 上传文件
gx.upload {
  url: "https://example.com/upload",
  local_file: "local_file.txt",
  method: "POST"
}
</code></pre>
<h2 id="gxtar-和-gxuntar"><a class="header" href="#gxtar-和-gxuntar">gx.tar 和 gx.untar</a></h2>
<h3 id="功能描述-9"><a class="header" href="#功能描述-9">功能描述</a></h3>
<p>创建和解压tar归档文件。</p>
<h3 id="语法定义-9"><a class="header" href="#语法定义-9">语法定义</a></h3>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: &lt;源文件/目录&gt;,     // 要归档的源文件或目录
  file: &lt;归档文件名&gt;      // 生成的归档文件名
}

// 解压tar归档
gx.untar {
  file: &lt;归档文件名&gt;,     // 要解压的归档文件
  dst: &lt;目标目录&gt;         // 解压到的目标目录
}
</code></pre>
<h3 id="示例代码-11"><a class="header" href="#示例代码-11">示例代码</a></h3>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: "src/",
  file: "source.tar"
}

// 解压tar归档
gx.untar {
  file: "source.tar",
  dst: "extracted/"
}
</code></pre>
<h2 id="gxartifact"><a class="header" href="#gxartifact">gx.artifact</a></h2>
<h3 id="功能描述-10"><a class="header" href="#功能描述-10">功能描述</a></h3>
<p>处理构建产物文件。</p>
<h3 id="语法定义-10"><a class="header" href="#语法定义-10">语法定义</a></h3>
<pre><code class="language-gxl">gx.artifact {
  file: &lt;文件路径&gt;,       // 构建产物文件路径
  dst_path: &lt;目标路径&gt;    // 目标存储路径
}
</code></pre>
<h3 id="示例代码-12"><a class="header" href="#示例代码-12">示例代码</a></h3>
<pre><code class="language-gxl">// 处理构建产物
gx.artifact {
  file: "target/release/myapp",
  dst_path: "artifacts/v1.0.0/"
}
</code></pre>
<h2 id="gxrun"><a class="header" href="#gxrun">gx.run</a></h2>
<h3 id="功能描述-11"><a class="header" href="#功能描述-11">功能描述</a></h3>
<p>运行其他GXL工作流文件。</p>
<h3 id="语法定义-11"><a class="header" href="#语法定义-11">语法定义</a></h3>
<pre><code class="language-gxl">gx.run {
  local: &lt;工作流路径&gt;,    // 要运行的工作流文件路径
  env: &lt;环境配置&gt;,        // 环境配置（可选）
  flow: &lt;流程列表&gt;,       // 要执行的流程列表（可选）
  conf: &lt;配置文件&gt;,       // 配置文件路径（可选）
  isolate: &lt;布尔值&gt;       // 是否隔离环境（可选）
}
</code></pre>
<h3 id="示例代码-13"><a class="header" href="#示例代码-13">示例代码</a></h3>
<pre><code class="language-gxl">// 运行其他工作流
gx.run {
  local: "./subflow.gxl"
}

// 在特定环境中运行工作流
gx.run {
  local: "./deploy.gxl",
  env: "production",
  flow: "build,deploy"
}

// 隔离环境运行
gx.run {
  local: "./test.gxl",
  isolate: true
}
</code></pre>
<h2 id="gxdefined"><a class="header" href="#gxdefined">gx.defined</a></h2>
<h3 id="功能描述-12"><a class="header" href="#功能描述-12">功能描述</a></h3>
<p>检查变量是否已定义。</p>
<h3 id="语法定义-12"><a class="header" href="#语法定义-12">语法定义</a></h3>
<pre><code class="language-gxl">gx.defined(${变量名})
</code></pre>
<h3 id="示例代码-14"><a class="header" href="#示例代码-14">示例代码</a></h3>
<pre><code class="language-gxl">// 检查变量是否已定义
if (gx.defined(${MY_VAR})) {
  gx.echo { value: "MY_VAR已定义，值为: ${MY_VAR}" }
} else {
  gx.echo { value: "MY_VAR未定义" }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxartifact-1"><a class="header" href="#gxartifact-1">gx.artifact</a></h1>
<h2 id="功能描述-13"><a class="header" href="#功能描述-13">功能描述</a></h2>
<p>处理构建产物文件。</p>
<h2 id="语法定义-13"><a class="header" href="#语法定义-13">语法定义</a></h2>
<pre><code class="language-gxl">gx.artifact {
  file: &lt;文件路径&gt;,       // 构建产物文件路径
  dst_path: &lt;目标路径&gt;    // 目标存储路径
}
</code></pre>
<h2 id="示例代码-15"><a class="header" href="#示例代码-15">示例代码</a></h2>
<pre><code class="language-gxl">// 处理构建产物
gx.artifact {
  file: "target/release/myapp",
  dst_path: "artifacts/v1.0.0/"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxassert-1"><a class="header" href="#gxassert-1">gx.assert</a></h1>
<h2 id="功能描述-14"><a class="header" href="#功能描述-14">功能描述</a></h2>
<p>执行断言检查，验证表达式的值是否符合预期。</p>
<h2 id="语法定义-14"><a class="header" href="#语法定义-14">语法定义</a></h2>
<pre><code class="language-gxl">gx.assert {
  value: &lt;表达式&gt;,      // 要检查的值
  expect: &lt;期望值&gt;,     // 期望的值
  err: &lt;错误信息&gt;,      // 断言失败时的错误信息（可选）
  result: &lt;变量名&gt;      // 存储断言结果的变量名（可选）
}
</code></pre>
<h2 id="示例代码-16"><a class="header" href="#示例代码-16">示例代码</a></h2>
<pre><code class="language-gxl">// 检查变量值是否等于期望值
gx.assert {
  value: ${MY_VAR},
  expect: "expected_value",
  err: "MY_VAR值不正确"
}

// 检查表达式结果并存储结果
gx.assert {
  value: ${CALC_RESULT},
  expect: 42,
  result: "assert_result"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxcmd-1"><a class="header" href="#gxcmd-1">gx.cmd</a></h1>
<h2 id="功能描述-15"><a class="header" href="#功能描述-15">功能描述</a></h2>
<p>执行系统命令或脚本。</p>
<h2 id="语法定义-15"><a class="header" href="#语法定义-15">语法定义</a></h2>
<pre><code class="language-gxl">gx.cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  shell: &lt;Shell类型&gt;,    // 指定使用的Shell（可选）
  out: &lt;输出变量名&gt;,     // 捕获命令标准输出的变量名（可选）
  err: &lt;错误变量名&gt;,     // 捕获命令错误输出的变量名（可选）
  suc: &lt;成功标识&gt;,       // 命令执行成功的标识（可选）
  sudo: &lt;布尔值&gt;,        // 是否使用sudo权限执行（可选）
  log: &lt;日志级别&gt;,       // 日志记录级别（可选）
  silence: &lt;布尔值&gt;      // 是否静默执行（可选）
}
</code></pre>
<h2 id="示例代码-17"><a class="header" href="#示例代码-17">示例代码</a></h2>
<pre><code class="language-gxl">// 执行简单命令
gx.cmd {
  cmd: "ls -la"
}

// 执行命令并捕获输出
gx.cmd {
  cmd: "date",
  out: "current_date"
}

// 使用sudo权限执行命令
gx.cmd {
  cmd: "systemctl restart nginx",
  sudo: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxdefined-1"><a class="header" href="#gxdefined-1">gx.defined</a></h1>
<h2 id="功能描述-16"><a class="header" href="#功能描述-16">功能描述</a></h2>
<p>检查变量是否已定义。</p>
<h2 id="语法定义-16"><a class="header" href="#语法定义-16">语法定义</a></h2>
<pre><code class="language-gxl">gx.defined(${变量名})
</code></pre>
<h2 id="示例代码-18"><a class="header" href="#示例代码-18">示例代码</a></h2>
<pre><code class="language-gxl">// 检查变量是否已定义
if (gx.defined(${MY_VAR})) {
  gx.echo { value: "MY_VAR已定义，值为: ${MY_VAR}" }
} else {
  gx.echo { value: "MY_VAR未定义" }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxdownload-和-gxupload-1"><a class="header" href="#gxdownload-和-gxupload-1">gx.download 和 gx.upload</a></h1>
<h2 id="功能描述-17"><a class="header" href="#功能描述-17">功能描述</a></h2>
<p>下载和上传文件。</p>
<h2 id="语法定义-17"><a class="header" href="#语法定义-17">语法定义</a></h2>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: &lt;下载URL&gt;,        // 文件下载URL
  local_file: &lt;本地路径&gt;, // 保存到本地的文件路径
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}

// 上传文件
gx.upload {
  url: &lt;上传URL&gt;,        // 文件上传URL
  local_file: &lt;本地路径&gt;, // 要上传的本地文件路径
  method: &lt;HTTP方法&gt;,     // HTTP方法（如POST、PUT等，默认POST）
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}
</code></pre>
<h2 id="示例代码-19"><a class="header" href="#示例代码-19">示例代码</a></h2>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: "https://example.com/file.zip",
  local_file: "downloaded_file.zip"
}

// 上传文件
gx.upload {
  url: "https://example.com/upload",
  local_file: "local_file.txt",
  method: "POST"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxecho-1"><a class="header" href="#gxecho-1">gx.echo</a></h1>
<h2 id="功能描述-18"><a class="header" href="#功能描述-18">功能描述</a></h2>
<p>输出文本信息到控制台。</p>
<h2 id="语法定义-18"><a class="header" href="#语法定义-18">语法定义</a></h2>
<pre><code class="language-gxl">gx.echo {
  value: &lt;文本内容&gt;,     // 要输出的文本内容
  file: &lt;文件路径&gt;,      // 输出到文件的路径（可选）
  export: &lt;变量名&gt;,      // 导出为环境变量的名称（可选）
  inc: &lt;布尔值&gt;          // 是否追加到文件末尾（可选）
}
</code></pre>
<h2 id="示例代码-20"><a class="header" href="#示例代码-20">示例代码</a></h2>
<pre><code class="language-gxl">// 输出简单文本
gx.echo {
  value: "Hello, Galaxy Flow!"
}

// 输出到文件
gx.echo {
  value: "This is a log entry",
  file: "app.log"
}

// 追加到文件
gx.echo {
  value: "Additional information",
  file: "app.log",
  inc: true
}

// 导出为环境变量
gx.echo {
  value: "production",
  export: "ENV_TYPE"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxread-1"><a class="header" href="#gxread-1">gx.read</a></h1>
<h2 id="功能描述-19"><a class="header" href="#功能描述-19">功能描述</a></h2>
<p>从不同来源读取数据并存储到变量中。</p>
<h2 id="语法定义-19"><a class="header" href="#语法定义-19">语法定义</a></h2>
<pre><code class="language-gxl">// 从文件读取
gx.read_file {
  file: &lt;文件路径&gt;,      // 要读取的文件路径
  name: &lt;变量名&gt;         // 存储文件内容的变量名
}

// 从标准输入读取
gx.read_stdin {
  name: &lt;变量名&gt;,        // 存储输入内容的变量名
  prompt: &lt;提示文本&gt;     // 输入提示文本（可选）
}

// 从命令输出读取
gx.read_cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  name: &lt;变量名&gt;,        // 存储命令输出的变量名
  shell: &lt;Shell类型&gt;     // 指定使用的Shell（可选）
}
</code></pre>
<h2 id="示例代码-21"><a class="header" href="#示例代码-21">示例代码</a></h2>
<pre><code class="language-gxl">// 从文件读取内容
gx.read_file {
  file: "config.json",
  name: "config_data"
}

// 从标准输入读取
gx.read_stdin {
  name: "user_input",
  prompt: "请输入您的姓名: "
}

// 从命令输出读取
gx.read_cmd {
  cmd: "git rev-parse HEAD",
  name: "commit_hash"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxrun-1"><a class="header" href="#gxrun-1">gx.run</a></h1>
<h2 id="功能描述-20"><a class="header" href="#功能描述-20">功能描述</a></h2>
<p>运行其他GXL工作流文件。</p>
<h2 id="语法定义-20"><a class="header" href="#语法定义-20">语法定义</a></h2>
<pre><code class="language-gxl">gx.run {
  local: &lt;工作流路径&gt;,    // 要运行的工作流文件路径
  env: &lt;环境配置&gt;,        // 环境配置（可选）
  flow: &lt;流程列表&gt;,       // 要执行的流程列表（可选）
  conf: &lt;配置文件&gt;,       // 配置文件路径（可选）
  isolate: &lt;布尔值&gt;       // 是否隔离环境（可选）
}
</code></pre>
<h2 id="示例代码-22"><a class="header" href="#示例代码-22">示例代码</a></h2>
<pre><code class="language-gxl">// 运行其他工作流
gx.run {
  local: "./subflow.gxl"
}

// 在特定环境中运行工作流
gx.run {
  local: "./deploy.gxl",
  env: "production",
  flow: "build,deploy"
}

// 隔离环境运行
gx.run {
  local: "./test.gxl",
  isolate: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxshell-1"><a class="header" href="#gxshell-1">gx.shell</a></h1>
<h2 id="功能描述-21"><a class="header" href="#功能描述-21">功能描述</a></h2>
<p>执行Shell脚本文件。</p>
<h2 id="语法定义-21"><a class="header" href="#语法定义-21">语法定义</a></h2>
<pre><code class="language-gxl">gx.shell {
  shell: &lt;脚本文件路径&gt;,  // 要执行的Shell脚本文件路径
  arg_file: &lt;参数文件&gt;,   // 参数文件路径（可选）
  out_var: &lt;输出变量名&gt;,  // 捕获脚本输出的变量名（可选）
  default: &lt;默认脚本&gt;     // 默认脚本文件路径（可选，与shell互斥）
}
</code></pre>
<h2 id="示例代码-23"><a class="header" href="#示例代码-23">示例代码</a></h2>
<pre><code class="language-gxl">// 执行Shell脚本
gx.shell {
  shell: "deploy.sh"
}

// 执行脚本并捕获输出
gx.shell {
  shell: "build.sh",
  out_var: "build_output"
}

// 使用参数文件
gx.shell {
  shell: "install.sh",
  arg_file: "install.args"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxtar-和-gxuntar-1"><a class="header" href="#gxtar-和-gxuntar-1">gx.tar 和 gx.untar</a></h1>
<h2 id="功能描述-22"><a class="header" href="#功能描述-22">功能描述</a></h2>
<p>创建和解压tar归档文件。</p>
<h2 id="语法定义-22"><a class="header" href="#语法定义-22">语法定义</a></h2>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: &lt;源文件/目录&gt;,     // 要归档的源文件或目录
  file: &lt;归档文件名&gt;      // 生成的归档文件名
}

// 解压tar归档
gx.untar {
  file: &lt;归档文件名&gt;,     // 要解压的归档文件
  dst: &lt;目标目录&gt;         // 解压到的目标目录
}
</code></pre>
<h2 id="示例代码-24"><a class="header" href="#示例代码-24">示例代码</a></h2>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: "src/",
  file: "source.tar"
}

// 解压tar归档
gx.untar {
  file: "source.tar",
  dst: "extracted/"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxtpl-1"><a class="header" href="#gxtpl-1">gx.tpl</a></h1>
<h2 id="功能描述-23"><a class="header" href="#功能描述-23">功能描述</a></h2>
<p>使用模板引擎处理文件模板。</p>
<h2 id="语法定义-23"><a class="header" href="#语法定义-23">语法定义</a></h2>
<pre><code class="language-gxl">gx.tpl {
  tpl: &lt;模板内容&gt;,       // 模板内容
  dst: &lt;目标文件路径&gt;,   // 生成文件的路径
  data: &lt;数据变量名&gt;,    // 模板数据变量名（可选）
  engine: &lt;引擎类型&gt;,    // 模板引擎类型（可选）
  file: &lt;模板文件路径&gt;   // 模板文件路径（可选，与tpl互斥）
}
</code></pre>
<h2 id="示例代码-25"><a class="header" href="#示例代码-25">示例代码</a></h2>
<pre><code class="language-gxl">// 使用内联模板
gx.tpl {
  tpl: "Hello, {{name}}! Welcome to {{app_name}}.",
  dst: "output.txt",
  data: "user_data"
}

// 使用模板文件
gx.tpl {
  file: "template.txt",
  dst: "output.txt",
  data: "template_data"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxvars-1"><a class="header" href="#gxvars-1">gx.vars</a></h1>
<h2 id="功能描述-24"><a class="header" href="#功能描述-24">功能描述</a></h2>
<p>定义和设置多个变量。</p>
<h2 id="语法定义-24"><a class="header" href="#语法定义-24">语法定义</a></h2>
<pre><code class="language-gxl">gx.vars {
  &lt;变量名1&gt;: &lt;值1&gt;,      // 变量名和对应的值
  &lt;变量名2&gt;: &lt;值2&gt;,      // 可以定义多个变量
  // ...
}
</code></pre>
<h2 id="示例代码-26"><a class="header" href="#示例代码-26">示例代码</a></h2>
<pre><code class="language-gxl">// 定义多个变量
gx.vars {
  app_name: "MyApp",
  version: "1.0.0",
  debug: true
}

// 使用变量引用
gx.vars {
  project_root: "${HOME}/projects",
  config_file: "${project_root}/config.yaml"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxver-1"><a class="header" href="#gxver-1">gx.ver</a></h1>
<h2 id="功能描述-25"><a class="header" href="#功能描述-25">功能描述</a></h2>
<p>管理和操作版本信息。</p>
<h2 id="语法定义-25"><a class="header" href="#语法定义-25">语法定义</a></h2>
<pre><code class="language-gxl">gx.ver {
  value: &lt;版本值&gt;,       // 版本值
  default: &lt;默认值&gt;,     // 默认版本值（可选）
  file: &lt;文件路径&gt;,      // 版本文件路径（可选）
  export: &lt;变量名&gt;,      // 导出版本信息的变量名（可选）
  inc: &lt;递增类型&gt;        // 版本递增类型（可选，可选值：build/bugfix/feature/main）
}
</code></pre>
<h2 id="示例代码-27"><a class="header" href="#示例代码-27">示例代码</a></h2>
<pre><code class="language-gxl">// 设置版本值
gx.ver {
  value: "1.2.3"
}

// 从文件读取版本并递增
gx.ver {
  file: "VERSION",
  inc: "feature"
}

// 导出版本信息
gx.ver {
  value: "2.0.0",
  export: "APP_VERSION"
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./mermaid.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>

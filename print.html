<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>galaxy-sec operator ecosystem</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mermaid.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">galaxy-sec operator ecosystem</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="galaxy-sec--operator--ecosystem"><a class="header" href="#galaxy-sec--operator--ecosystem">Galaxy-Sec  Operator  Ecosystem</a></h1>
<h2 id="包括"><a class="header" href="#包括">包括：</a></h2>
<ul>
<li>DSL语言: Gxl</li>
<li>维护器</li>
<li>命令工具
<ul>
<li>gflow :Gxl的执行器</li>
<li>gops : 维护工程</li>
<li>gsys ：系统维护器</li>
<li>gmod ：模块维护器</li>
</ul>
</li>
</ul>
<h2 id="核心流程"><a class="header" href="#核心流程">核心流程</a></h2>
<ul>
<li>1、gmod 创建模块维护器，用gxl 编写维护器的workflow</li>
<li>2、gsys 创建系统维护器，并组合多个模块维护器,用gxl 编写维护器的workflow</li>
<li>3、系统维护器 保存到配置管理库中，待发布到客户环境。</li>
<li>4、在客户环境中，使用gops 创建维护工程， 并加载系统维护器。</li>
<li>5、在客户环境中，使用gflow 执行维护器的workflow。</li>
<li>6、保存维护工程到配置管理库中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h1 id="galaxy-flow-v083--v086-发布说明"><a class="header" href="#galaxy-flow-v083--v086-发布说明">Galaxy Flow v0.8.3 → v0.8.6 发布说明</a></h1>
<h2 id="-版本信息"><a class="header" href="#-版本信息">🚀 版本信息</a></h2>
<ul>
<li>起始版本 : v0.8.3</li>
<li>目标版本 : v0.8.6</li>
<li>当前版本 : 0.8.6</li>
</ul>
<h2 id="-主要新功能"><a class="header" href="#-主要新功能">✨ 主要新功能</a></h2>
<h3 id="1-日志重定向系统重构"><a class="header" href="#1-日志重定向系统重构">1. 日志重定向系统重构</a></h3>
<ul>
<li>新增 : 使用管道(pip)进行日志重定向的全新实现</li>
<li>优化 : 改进了日志处理机制，提高了性能和稳定性</li>
<li>提交 : a5bf576 , deea236 , 2e1ce2c , be686b1 , 4e3f1a7</li>
</ul>
<h3 id="2-逻辑表达式支持"><a class="header" href="#2-逻辑表达式支持">2. 逻辑表达式支持</a></h3>
<ul>
<li>新增 : 逻辑表达式( logic_exp )功能实现</li>
<li>实现 : 完整的逻辑表达式解析和执行能力</li>
<li>提交 : d646fd4 , fc7c975</li>
</ul>
<h3 id="3-归档功能增强"><a class="header" href="#3-归档功能增强">3. 归档功能增强</a></h3>
<ul>
<li>新增 : gx.tar 和 gx.untar 命令支持</li>
<li>用途 : 提供原生的压缩和解压缩能力</li>
<li>提交 : 1755d4d</li>
</ul>
<h2 id="-改进与优化"><a class="header" href="#-改进与优化">🔧 改进与优化</a></h2>
<h3 id="代码质量"><a class="header" href="#代码质量">代码质量</a></h3>
<ul>
<li>重构 : 成功状态处理逻辑重构 ( 6dce866 )</li>
<li>优化 : 表达式逻辑更新 ( 73dcb46 )</li>
<li>清理 : 取消taskvalue中的日志信息 ( 523f85b )</li>
</ul>
<h3 id="依赖更新"><a class="header" href="#依赖更新">依赖更新</a></h3>
<ul>
<li>更新 : clap依赖升级到最新版本 ( 9246378 )</li>
<li>更新 : 多个crate依赖项更新 ( 1051001 , 352e19a )</li>
<li>维护 : 代码格式化和clippy修复 ( 08b51f2 , c57879b , b049906 )</li>
</ul>
<h2 id="-问题修复"><a class="header" href="#-问题修复">🐛 问题修复</a></h2>
<h3 id="关键修复"><a class="header" href="#关键修复">关键修复</a></h3>
<ul>
<li>修复 : 模块路径错误问题 (#61) - d099a55</li>
<li>修复 : 多个相关问题 (#62, #61) - 4419cad</li>
<li>修复 : 模块名称列表问题 - 19bfa32</li>
</ul>
<h3 id="其他修复"><a class="header" href="#其他修复">其他修复</a></h3>
<ul>
<li>修复 : 通道与启用状态的关联问题 - 5592286</li>
<li>修复 : 干运行参数传递给子gxl的问题 - 4644a1b</li>
</ul>
<h2 id="-其他变更"><a class="header" href="#-其他变更">📋 其他变更</a></h2>
<h3 id="构建和部署"><a class="header" href="#构建和部署">构建和部署</a></h3>
<ul>
<li>更新 : artifact构建更新 ( 9c1193d )</li>
<li>更新 : 管理配置更新 ( 3dcc127 )</li>
<li>维护 : 版本号更新到0.8.6 ( 2f4acfe , 5b4dbb0 )</li>
</ul>
<h3 id="内部改进"><a class="header" href="#内部改进">内部改进</a></h3>
<ul>
<li>重构 : 使用常量字符串优化 ( 64e7d30 , daf17ef )</li>
<li>新增 : 读取文件日志功能 ( 142b448 )</li>
</ul>
<h2 id="-升级建议"><a class="header" href="#-升级建议">📝 升级建议</a></h2>
<ol>
<li>
<ol>
<li></li>
</ol>
平滑升级 : 从v0.8.3升级到v0.8.6是向后兼容的</li>
<li>
<ol start="2">
<li></li>
</ol>
新功能试用 : 建议尝试新的日志重定向和逻辑表达式功能</li>
<li>
<ol start="3">
<li></li>
</ol>
依赖检查 : 确保所有依赖项已更新到兼容版本</li>
</ol>
<h2 id="-变更统计"><a class="header" href="#-变更统计">📊 变更统计</a></h2>
<ul>
<li>总提交数 : 30+ 次提交</li>
<li>功能新增 : 5个主要功能</li>
<li>问题修复 : 6个关键修复</li>
<li>代码优化 : 10+ 项改进
本次发布专注于提升系统稳定性、增加新功能，并修复已知问题，为用户提供更好的DevSecOps自动化体验。</li>
</ul>
<h1 id="083"><a class="header" href="#083">0.8.3</a></h1>
<h2 id="新增"><a class="header" href="#新增">新增</a></h2>
<ul>
<li>GXL 支持 数字、BOOL、数组、对象 数据类型</li>
<li>提供 defined 函数 - 检查变量是否已定义</li>
<li>提供 gx.shell 方便 shell 调用</li>
<li>支持 ${VAR:default} 变量定义默认值</li>
<li>gprj update mod 或 gflow --update mod 支持更新项目依赖的Mod</li>
</ul>
<h2 id="改进"><a class="header" href="#改进">改进</a></h2>
<ul>
<li>gx.read_file 读取内容到对象，便于后续处理</li>
<li>winnow 升级 0.7</li>
<li>对于远程Mod的获取，去掉外部Git 依赖</li>
<li>修改外部依赖</li>
</ul>
<h1 id="070"><a class="header" href="#070">0.7.0</a></h1>
<h2 id="新增-1"><a class="header" href="#新增-1">新增</a></h2>
<ul>
<li>支持事务机制</li>
<li>支持dryrun机制 - 允许预览操作结果而不实际执行</li>
</ul>
<h1 id="064"><a class="header" href="#064">0.6.4</a></h1>
<h2 id="新增-2"><a class="header" href="#新增-2">新增</a></h2>
<ul>
<li>支持 gx.cmd  quiet (静默） - 自定义控制cmd的日志输出与否</li>
</ul>
<h1 id="062"><a class="header" href="#062">0.6.2</a></h1>
<h2 id="新增-3"><a class="header" href="#新增-3">新增</a></h2>
<ul>
<li>优化日志输出，增加日志的重定向，支持捕获控制台标准日志输出</li>
</ul>
<h1 id="060"><a class="header" href="#060">0.6.0</a></h1>
<h2 id="新增-4"><a class="header" href="#新增-4">新增</a></h2>
<ul>
<li>生成任务报告 - 提供执行过程和结果的详细信息</li>
<li>支持flow上的Task注解 - 增强流程定义的灵活性</li>
</ul>
<h2 id="改进-1"><a class="header" href="#改进-1">改进</a></h2>
<ul>
<li>改进 flow 编排语法，由: 变为 |  符号</li>
</ul>
<h1 id="gflow-053"><a class="header" href="#gflow-053">gflow-0.5.3</a></h1>
<h2 id="内置环境变量"><a class="header" href="#内置环境变量">内置环境变量</a></h2>
<ul>
<li>GXL_PRJ_ROOT:    最近定义的 _gal/project.toml 的目录</li>
</ul>
<h2 id="extern-mod-支持变量"><a class="header" href="#extern-mod-支持变量">extern mod 支持变量</a></h2>
<pre><code>extern mod head { path = "${GXL_START_ROOT}/_gal/"; }
</code></pre>
<p><a href="https://github.com/galaxy-sec/galaxy-flow/releases/tag/v0.5.3">0.5.3 下载</a></p>
<h1 id="052"><a class="header" href="#052">0.5.2</a></h1>
<h2 id="内置环境变量-1"><a class="header" href="#内置环境变量-1">内置环境变量</a></h2>
<ul>
<li>GXL_START_ROOT:  GXL 启动处理的目录</li>
<li>GXL_CUR_DIR:  GXL 当前所在目录，在调用gx.run时，与GXL_START_ROOT可能不同</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gflow-命令使用文档"><a class="header" href="#gflow-命令使用文档">gflow 命令使用文档</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p><code>gflow</code> 是 Galaxy Flow 的核心执行引擎，用于运行 GXL 流程文件。</p>
<h2 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h2>
<pre><code class="language-bash">gflow [OPTIONS] [FLOW]...
</code></pre>
<h2 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h2>
<h3 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h3>
<ul>
<li><code>FLOW...</code>: 要执行的流程名称，例如：conf, test, package</li>
</ul>
<h3 id="选项参数"><a class="header" href="#选项参数">选项参数</a></h3>
<ul>
<li><code>-e, --env &lt;ENV&gt;</code>: 环境名称，例如：-e dev（默认：default）</li>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别，例如：-d 1（默认：0）</li>
<li><code>-f, --conf &lt;CONF&gt;</code>: 配置文件路径，默认为：
<ul>
<li>work: <code>./_rg/work.gxl</code></li>
<li>adm: <code>./_rg/adm.gxl</code></li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code>: 配置日志级别，例如：--log cmd=debug,parse=info</li>
<li><code>-q, --quiet</code>: 静默模式</li>
<li><code>-h, --help</code>: 显示帮助信息</li>
<li><code>-V, --version</code>: 显示版本信息</li>
</ul>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<h3 id="基本执行"><a class="header" href="#基本执行">基本执行</a></h3>
<pre><code class="language-bash"># 执行默认工作流
gflow

# 执行指定流程
gflow conf test package
</code></pre>
<h3 id="环境切换"><a class="header" href="#环境切换">环境切换</a></h3>
<pre><code class="language-bash"># 使用开发环境
gflow -e dev

# 使用生产环境
gflow -e prod
</code></pre>
<h3 id="调试模式"><a class="header" href="#调试模式">调试模式</a></h3>
<pre><code class="language-bash"># 启用调试模式
gflow -d 2

# 配置详细日志
gflow --log cmd=debug,parse=info
</code></pre>
<h3 id="指定配置"><a class="header" href="#指定配置">指定配置</a></h3>
<pre><code class="language-bash"># 使用自定义配置文件
gflow -f ./config/my-config.gxl
</code></pre>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<p>默认配置文件为：</p>
<ul>
<li><code>./_rg/work.gxl</code> - 工作流配置</li>
<li><code>./_rg/adm.gxl</code> - 管理配置</li>
</ul>
<p>配置文件包含：</p>
<ul>
<li>任务定义</li>
<li>变量配置</li>
<li>模块引用</li>
<li>执行策略</li>
</ul>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<ul>
<li><code>GALAXY_FLOW_HOME</code>: Galaxy Flow 主目录</li>
<li><code>RUST_LOG</code>: Rust 日志级别</li>
</ul>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<ul>
<li><code>0</code>: 执行成功</li>
<li><code>非0</code>: 执行失败，返回错误码</li>
</ul>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="找不到配置文件"><a class="header" href="#找不到配置文件">找不到配置文件</a></h3>
<p>确保当前目录下有 <code>_rg/work.gxl</code> 或 <code>_rg/adm.gxl</code> 文件，或使用 <code>-f</code> 指定配置文件。</p>
<h3 id="权限问题"><a class="header" href="#权限问题">权限问题</a></h3>
<p>确保有执行权限：</p>
<pre><code class="language-bash">chmod +x gflow
</code></pre>
<h3 id="模块加载失败"><a class="header" href="#模块加载失败">模块加载失败</a></h3>
<p>检查网络连接和模块路径配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod---galaxy-module-management-tool"><a class="header" href="#gmod---galaxy-module-management-tool">gmod - Galaxy Module Management Tool</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p><code>gmod</code> 是 Galaxy 模块管理工具，用于创建、更新和本地化 Galaxy 模块。它提供了完整的模块生命周期管理功能，帮助开发者快速构建和维护 Galaxy 项目。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<pre><code class="language-bash"># 从源代码安装
cargo install --path .

# 或者使用二进制分发
curl -fsSL https://github.com/galaxy-sec/galaxy-ops/releases/latest/download/gmod.tar.gz | tar -xz
sudo mv gmod /usr/local/bin/
</code></pre>
<h2 id="基本用法-1"><a class="header" href="#基本用法-1">基本用法</a></h2>
<h3 id="显示版本信息"><a class="header" href="#显示版本信息">显示版本信息</a></h3>
<pre><code class="language-bash">gmod
# 输出示例：gmod: 1.0.0
</code></pre>
<h3 id="显示帮助信息"><a class="header" href="#显示帮助信息">显示帮助信息</a></h3>
<pre><code class="language-bash">gmod --help
gmod &lt;command&gt; --help
</code></pre>
<h2 id="命令详解"><a class="header" href="#命令详解">命令详解</a></h2>
<h3 id="gmod-example"><a class="header" href="#gmod-example">gmod example</a></h3>
<p>创建示例模块结构</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod example
</code></pre>
<p><strong>功能：</strong></p>
<ul>
<li>在当前目录创建完整的示例模块结构</li>
<li>包含所有必需的配置文件和模板</li>
<li>展示模块组织的最佳实践</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash">gmod example
# 创建示例模块到当前目录
</code></pre>
<h3 id="gmod-new"><a class="header" href="#gmod-new">gmod new</a></h3>
<p>定义新的模块规范</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 模块名称（字母数字，可包含连字符和下划线）【必填】</li>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li>0：关闭调试输出</li>
<li>1：基础调试信息</li>
<li>2：详细调试信息</li>
<li>3：跟踪调试信息</li>
<li>4：完整调试信息</li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置（格式：模块=级别,模块=级别）</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的新模块</li>
<li>初始化模块目录结构</li>
<li>生成所有必需的配置文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 "my-module" 的新模块
gmod new --name my-module

# 创建模块并启用调试输出
gmod new --name my-module --debug 2

# 创建模块并配置日志
gmod new --name my-module --log cmd=debug,parse=info
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>创建目录：my-module/
生成配置文件：my-module/mod.yml
生成配置文件：my-module/module.yaml
生成模板文件：my-module/templates/
生成示例文件：my-module/examples/
</code></pre>
<h3 id="gmod-update"><a class="header" href="#gmod-update">gmod update</a></h3>
<p>更新现有模块的依赖关系</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：正常更新</li>
<li>1：跳过确认</li>
<li>2：覆盖现有文件</li>
<li>3：强制 git pull</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新模块的依赖关系</li>
<li>下载远程引用的模块</li>
<li>支持强制更新模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新模块
gmod update

# 强制更新，跳过确认
gmod update --force 1

# 详细调试输出更新过程
gmod update --debug 3 --log all=debug
</code></pre>
<h3 id="gmod-localize"><a class="header" href="#gmod-localize">gmod localize</a></h3>
<p>本地化模块配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 值文件路径（YAML/JSON）</li>
<li><code>--default</code> - 使用默认值，不使用用户提供的 value.yml</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>根据环境特定的值生成本地化配置</li>
<li>支持多环境配置管理</li>
<li>可选择使用自定义或默认值</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认值本地化
gmod localize --default

# 使用自定义值文件本地化
gmod localize --value prod-values.yml

# 使用自定义值文件并启用调试
gmod localize --value dev-values.yml --debug 2
</code></pre>
<h2 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h2>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置</li>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态</li>
</ul>
<h2 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h2>
<h3 id="模块配置结构"><a class="header" href="#模块配置结构">模块配置结构</a></h3>
<pre><code>my-module/
├── mod.yml                    # 模块主配置文件
├── module.yaml               # 模块元数据
├── templates/                # 模板目录
├── examples/                # 示例文件
└── config/                  # 配置文件
    ├── default.yml          # 默认配置
    ├── local.yml            # 本地配置
    └── env/                  # 环境特定配置
        ├── dev.yml
        ├── staging.yml
        └── prod.yml
</code></pre>
<h3 id="modyml-示例"><a class="header" href="#modyml-示例">mod.yml 示例</a></h3>
<pre><code class="language-yaml">name: my-module
version: "1.0.0"
description: "My Galaxy Module"
author: "Your Name &lt;your.email@example.com&gt;"

dependencies:
  - galaxy/core: "&gt;=1.0.0"
  - galaxy/utils: "~2.0.0"

sources:
  - type: git
    url: "https://github.com/username/my-module.git"
    ref: main

outputs:
  - name: main
    path: "build/output"
    format: tar.gz
</code></pre>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<h3 id="模块命名"><a class="header" href="#模块命名">模块命名</a></h3>
<ul>
<li>使用小写字母、数字、连字符和下划线</li>
<li>避免特殊字符和空格</li>
<li>使用有意义的名称，如：<code>user-service-api</code></li>
</ul>
<h3 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h3>
<ul>
<li>使用语义化版本控制</li>
<li>定期更新依赖：<code>gmod update --force 1</code></li>
<li>在生产环境使用锁定版本</li>
</ul>
<h3 id="配置管理"><a class="header" href="#配置管理">配置管理</a></h3>
<ul>
<li>使用环境特定的配置文件</li>
<li>在 CI/CD 流程中自动本地化</li>
<li>使用默认配置作为后备</li>
</ul>
<h3 id="调试技巧"><a class="header" href="#调试技巧">调试技巧</a></h3>
<pre><code class="language-bash"># 启用完整调试输出
gmod update --debug 4 --log all=debug

# 检查模块依赖关系
gmod new --name debug-test --debug 2

# 使用详细日志进行故障排除
gmod localize --debug 3 --log cmd=debug,net=trace
</code></pre>
<h2 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h2>
<h3 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h3>
<p><strong>Q: 创建模块失败</strong></p>
<pre><code>错误：无法创建目录 "my-module"
原因：目录已存在或权限不足
解决：删除现有目录或检查权限
</code></pre>
<p><strong>Q: 更新模块时网络错误</strong></p>
<pre><code>错误：无法下载依赖
解决：检查网络连接和 git 配置
gmod update --debug 3 --log net=debug
</code></pre>
<p><strong>Q: 本地化失败</strong></p>
<pre><code>错误：无法解析值文件
解决：检查 YAML/JSON 格式是否正确
gmod localize --value config.yml --debug 2
</code></pre>
<h3 id="调试模式-1"><a class="header" href="#调试模式-1">调试模式</a></h3>
<p>使用调试模式获取详细的执行信息：</p>
<pre><code class="language-bash"># 最高级别调试
gmod update --debug 4 --log all=debug

# 关键模块调试
gmod new --name test --debug 3 --log cmd=debug
</code></pre>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxmod_cmd_app_creation

# 运行测试并显示输出
cargo test -- --nocapture
</code></pre>
<h2 id="示例工作流"><a class="header" href="#示例工作流">示例工作流</a></h2>
<h3 id="开发新模块"><a class="header" href="#开发新模块">开发新模块</a></h3>
<pre><code class="language-bash"># 1. 创建新模块
gmod new --name user-service

# 2. 编辑模块配置
cd user-service
vim mod.yml

# 3. 开发功能
# ... 编码 ...

# 4. 更新依赖
cd ..
gmod update

# 5. 本地化配置
gmod localize --value dev-values.yml

# 6. 验证模块
gmod example
</code></pre>
<h3 id="部署到生产环境"><a class="header" href="#部署到生产环境">部署到生产环境</a></h3>
<pre><code class="language-bash"># 1. 创建生产模块
gmod new --name user-service-prod

# 2. 更新到最新版本
gmod update --force 3

# 3. 使用生产配置本地化
gmod localize --value prod-values.yml

# 4. 验证配置
ls -la user-service-prod/config/env/prod.yml
</code></pre>
<h2 id="版本历史"><a class="header" href="#版本历史">版本历史</a></h2>
<h3 id="当前版本100"><a class="header" href="#当前版本100">当前版本：1.0.0</a></h3>
<ul>
<li>初始版本</li>
<li>支持模块创建、更新和本地化</li>
<li>完整的错误处理和日志记录</li>
</ul>
<h2 id="贡献指南"><a class="header" href="#贡献指南">贡献指南</a></h2>
<p>欢迎贡献代码和建议：</p>
<ol>
<li>Fork 项目（https://github.com/galaxy-sec/galaxy-ops）</li>
<li>创建特性分支</li>
<li>提交更改</li>
<li>推送到分支</li>
<li>创建 Pull Request</li>
</ol>
<h2 id="许可证"><a class="header" href="#许可证">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gops---galaxy-operations-system-系统操作管理工具"><a class="header" href="#gops---galaxy-operations-system-系统操作管理工具">gops - Galaxy Operations System 系统操作管理工具</a></h1>
<h2 id="概述-2"><a class="header" href="#概述-2">概述</a></h2>
<p><code>gops</code> 是 Galaxy Operations System 的核心管理工具，用于管理系统配置、导入模块、更新引用等操作。它提供了完整的系统操作功能，帮助开发者高效地管理 Galaxy 系统的各种配置和操作。</p>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<pre><code class="language-bash"># 从源代码安装
cargo install --path .

# 或者使用二进制分发
https://github.com/galaxy-sec/galaxy-ops/releases/latest/
</code></pre>
<h2 id="基本用法-2"><a class="header" href="#基本用法-2">基本用法</a></h2>
<h3 id="显示版本信息-1"><a class="header" href="#显示版本信息-1">显示版本信息</a></h3>
<pre><code class="language-bash">gops
# 输出示例：gops: 1.0.0
</code></pre>
<h3 id="显示帮助信息-1"><a class="header" href="#显示帮助信息-1">显示帮助信息</a></h3>
<pre><code class="language-bash">gops --help
gops &lt;command&gt; --help
</code></pre>
<h2 id="命令详解-1"><a class="header" href="#命令详解-1">命令详解</a></h2>
<h3 id="gops-new"><a class="header" href="#gops-new">gops new</a></h3>
<p>创建新的系统配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 系统配置名称（必填）
<ul>
<li>系统配置的唯一标识名称</li>
<li>支持字母数字、连字符和下划线</li>
<li>必须为非空字符串</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的新系统配置</li>
<li>初始化系统配置目录结构</li>
<li>生成所有必需的配置文件</li>
<li>设置默认的系统配置参数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 "my-config" 的新系统配置
gops new --name my-config

# 创建带详细调试的系统配置
gops new --name debug-config --debug 2
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>创建目录：my-config/
生成配置文件：my-config/ops_config.yml
生成模板文件：my-config/templates/
生成示例文件：my-config/examples/
生成脚本文件：my-config/scripts/
</code></pre>
<h3 id="gops-import"><a class="header" href="#gops-import">gops import</a></h3>
<p>导入外部模块到当前系统</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops import [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li>0：关闭调试输出</li>
<li>1：基础调试信息</li>
<li>2：详细调试信息</li>
<li>3：跟踪调试信息</li>
<li>4：完整调试信息</li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置（格式：模块=级别,模块=级别）</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：不强制更新</li>
<li>1：强制更新引用</li>
<li>2：强制更新依赖</li>
<li>3：强制更新所有内容</li>
</ul>
</li>
<li><code>-p, --path &lt;PATH&gt;</code> - 模块导入路径（必填）
<ul>
<li>可以是相对路径或绝对路径</li>
<li>指定要导入的模块所在位置</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>从指定路径导入模块配置</li>
<li>将模块集成到当前系统</li>
<li>自动处理模块依赖关系</li>
<li>支持强制导入模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 从指定路径导入模块
gops import --path /path/to/module

# 跳过确认导入
gops import --path /path/to/module --force 1

# 详细调试导入过程
gops import --path /path/to/module --debug 3 --log import=debug

# 强制更新所有内容
gops import --path /path/to/module --force 3
</code></pre>
<h3 id="gops-update"><a class="header" href="#gops-update">gops update</a></h3>
<p>更新系统模块和引用</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：不强制更新</li>
<li>1：强制更新引用</li>
<li>2：强制更新依赖</li>
<li>3：强制更新所有内容</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新系统模块的引用关系</li>
<li>更新模块的依赖配置</li>
<li>下载远程资源引用</li>
<li>支持多种强制更新模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新系统
gops update

# 强制更新引用
gops update --force 1

# 详细调试更新过程
gops update --debug 3 --log all=debug
</code></pre>
<h3 id="gops-localize"><a class="header" href="#gops-localize">gops localize</a></h3>
<p>本地化模块配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 本地化值文件路径
<ul>
<li>指定用于本地化的值文件路径</li>
<li>通常是 YAML 格式的配置文件</li>
</ul>
</li>
<li><code>--default</code> - 使用默认模块配置
<ul>
<li>启用默认模块模式</li>
<li>不使用用户自定义的 value.yml 文件</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>根据环境特定的值本地化模块配置</li>
<li>适配不同环境的配置需求</li>
<li>支持多环境配置管理</li>
<li>可选择使用自定义或默认值</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认配置本地化
gops localize --default

# 使用自定义值文件本地化
gops localize --value prod-values.yml

# 使用自定义值文件并启用调试
gops localize --value dev-values.yml --debug 2
</code></pre>
<blockquote>
<p><strong>注意：</strong> 目前 <code>gops localize</code> 命令实现为 <code>todo!()</code>，功能尚未完成。</p>
</blockquote>
<h3 id="gops-setting"><a class="header" href="#gops-setting">gops setting</a></h3>
<p>系统设置管理</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops setting [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置
<ul>
<li>格式：模块=级别,模块=级别</li>
<li>例如：--log setting=debug,system=info</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>管理系统级别的配置设置</li>
<li>查看和修改系统配置参数</li>
<li>提供系统状态信息</li>
<li>支持调试和日志配置</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 查看系统设置
gops setting

# 启用调试输出查看设置
gops setting --debug 2

# 配置日志级别查看设置
gops setting --log setting=debug,system=info
</code></pre>
<h2 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h2>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置</li>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态</li>
<li><code>TEST_MODE</code> 和 <code>MOCK_SUCCESS</code> 用于测试环境，确保测试的安全性和隔离性</li>
</ul>
<h2 id="配置文件-2"><a class="header" href="#配置文件-2">配置文件</a></h2>
<h3 id="系统配置结构"><a class="header" href="#系统配置结构">系统配置结构</a></h3>
<pre><code>my-config/
├── ops_config.yml              # 系统主配置文件
├── templates/                  # 模板目录
├── examples/                  # 示例文件
├── scripts/                   # 脚本文件
├── modules/                   # 模块目录
├── config/                    # 配置文件
│   ├── default.yml           # 默认配置
│   ├── local.yml             # 本地配置
│   └── env/                  # 环境特定配置
│       ├── dev.yml
│       ├── staging.yml
│       └── prod.yml
└── settings/                  # 系统设置
    ├── system.yml
    ├── security.yml
    └── performance.yml
</code></pre>
<h3 id="ops_configyml-示例"><a class="header" href="#ops_configyml-示例">ops_config.yml 示例</a></h3>
<pre><code class="language-yaml"># 系统配置文件
system_name: my-ops-system
version: "1.0.0"
description: "My Galaxy Operations System"

# 模块配置
modules:
  - name: core
    type: system
    version: "1.0.0"
  - name: database
    type: external
    path: "/path/to/database-module"
    version: "2.1.0"

# 依赖配置
dependencies:
  - galaxy/core: "&gt;=1.0.0"
  - galaxy/utils: "~2.0.0"
  - galaxy/security: "^1.5.0"

# 导入配置
imports:
  - name: user-service
    path: "/path/to/user-service"
    version: "1.2.0"

# 输出配置
outputs:
  - name: artifacts
    path: "build/artifacts"
    format: tar.gz

# 系统设置
settings:
  debug_level: 1
  log_level: info
  auto_update: true
</code></pre>
<h2 id="最佳实践-1"><a class="header" href="#最佳实践-1">最佳实践</a></h2>
<h3 id="配置命名"><a class="header" href="#配置命名">配置命名</a></h3>
<ul>
<li>使用小写字母、数字、连字符和下划线</li>
<li>避免特殊字符和空格</li>
<li>使用有意义的名称，如：<code>production-config</code></li>
<li>区分环境和用途：<code>dev-api-config</code></li>
</ul>
<h3 id="模块管理"><a class="header" href="#模块管理">模块管理</a></h3>
<pre><code class="language-bash"># 导入新模块
gops import --path /path/to/new-module --force 1

# 更新现有模块
gops update --force 2

# 验证配置
gops setting --debug 2
</code></pre>
<h3 id="配置管理-1"><a class="header" href="#配置管理-1">配置管理</a></h3>
<pre><code class="language-bash"># 开发环境配置
gops localize --value dev-config.yml --debug 2

# 测试环境配置
gops localize --value test-config.yml

# 生产环境配置
gops localize --value prod-config.yml --default
</code></pre>
<h3 id="调试技巧-1"><a class="header" href="#调试技巧-1">调试技巧</a></h3>
<pre><code class="language-bash"># 启用完整调试输出
gops import --path /test --debug 4 --log all=debug

# 检查系统设置
gops setting --debug 3 --log setting=debug

# 使用详细日志进行故障排除
gops update --debug 2 --log cmd=debug,net=trace
</code></pre>
<h2 id="故障排除-1"><a class="header" href="#故障排除-1">故障排除</a></h2>
<h3 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h3>
<p><strong>Q: 创建配置失败</strong></p>
<pre><code>错误：无法创建目录 "my-config"
原因：目录已存在或权限不足
解决：删除现有目录或检查权限
</code></pre>
<p><strong>Q: 导入模块失败</strong></p>
<pre><code>错误：无法导入模块
原因：路径不存在或权限不足
解决：检查路径是否正确，确保有读取权限
gops import --path /test/path --debug 3 --log import=debug
</code></pre>
<p><strong>Q: 更新模块时网络错误</strong></p>
<pre><code>错误：无法下载依赖
解决：检查网络连接和 git 配置
gops update --debug 3 --log net=debug
</code></pre>
<p><strong>Q: 本地化功能未实现</strong></p>
<pre><code>错误：localize 功能尚未完成
原因：当前版本实现为 todo!()
解决：等待后续版本支持，或使用其他配置管理方式
</code></pre>
<h3 id="调试模式-2"><a class="header" href="#调试模式-2">调试模式</a></h3>
<p>使用调试模式获取详细的执行信息：</p>
<pre><code class="language-bash"># 最高级别调试
gops import --path /test --debug 4 --log all=debug

# 关键模块调试
gops new --name test --debug 3 --log cmd=debug

# 设置调试
gops setting --debug 2 --log setting=debug
</code></pre>
<h3 id="系统诊断"><a class="header" href="#系统诊断">系统诊断</a></h3>
<pre><code class="language-bash"># 检查配置文件
ls -la my-config/

# 验证系统配置
cat my-config/ops_config.yml

# 检查模块目录
ls -la my-config/modules/

# 查看系统设置
gops setting --debug 1
</code></pre>
<h2 id="测试-1"><a class="header" href="#测试-1">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxops_run_success

# 运行测试并显示输出
cargo test -- --nocapture

# 测试环境隔离
TEST_MODE=true cargo test
</code></pre>
<h2 id="示例工作流-1"><a class="header" href="#示例工作流-1">示例工作流</a></h2>
<h3 id="开发新系统"><a class="header" href="#开发新系统">开发新系统</a></h3>
<pre><code class="language-bash"># 1. 创建新系统配置
gops new --name my-ops-system

# 2. 导入外部模块
gops import --path /path/to/user-service --force 1

# 3. 导入数据库模块
gops import --path /path/to/database-module --force 2

# 4. 更新系统模块
gops update

# 5. 查看系统设置
gops setting --debug 1

# 6. 本地化配置（功能待实现）
gops localize --value dev-config.yml
</code></pre>
<h3 id="部署到生产环境-1"><a class="header" href="#部署到生产环境-1">部署到生产环境</a></h3>
<pre><code class="language-bash"># 1. 创建生产系统配置
gops new --name production-system

# 2. 导入生产模块
gops import --path /path/to/production-modules --force 3

# 3. 更新到最新版本
gops update --force 3

# 4. 查看生产设置
gops setting --log production=debug

# 5. 使用生产配置本地化
gops localize --value prod-config.yml --default
</code></pre>
<h2 id="版本历史-1"><a class="header" href="#版本历史-1">版本历史</a></h2>
<h3 id="当前版本100-1"><a class="header" href="#当前版本100-1">当前版本：1.0.0</a></h3>
<ul>
<li>初始版本</li>
<li>支持系统配置创建</li>
<li>支持模块导入功能</li>
<li>支持系统模块更新</li>
<li>支持系统设置管理</li>
<li>本地化功能标记为待实现（todo!()）</li>
<li>完整的错误处理和日志记录</li>
</ul>
<h2 id="功能开发状态"><a class="header" href="#功能开发状态">功能开发状态</a></h2>
<div class="table-wrapper"><table><thead><tr><th>功能</th><th>状态</th><th>说明</th></tr></thead><tbody>
<tr><td>new</td><td>✅ 完成</td><td>创建新的系统配置</td></tr>
<tr><td>import</td><td>✅ 完成</td><td>导入外部模块到当前系统</td></tr>
<tr><td>update</td><td>✅ 完成</td><td>更新系统模块和引用</td></tr>
<tr><td>localize</td><td>⏳ 待开发</td><td>本地化模块配置（当前为 todo!()）</td></tr>
<tr><td>setting</td><td>✅ 完成</td><td>系统设置管理</td></tr>
</tbody></table>
</div>
<h2 id="贡献指南-1"><a class="header" href="#贡献指南-1">贡献指南</a></h2>
<p>欢迎贡献代码和建议：</p>
<ol>
<li>Fork 项目</li>
<li>创建特性分支</li>
<li>提交更改</li>
<li>推送到分支</li>
<li>创建 Pull Request</li>
</ol>
<h2 id="许可证-1"><a class="header" href="#许可证-1">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gprj-命令使用文档"><a class="header" href="#gprj-命令使用文档">gprj 命令使用文档</a></h1>
<h2 id="概述-3"><a class="header" href="#概述-3">概述</a></h2>
<p><code>gprj</code> 是 Galaxy Flow 的项目管理工具，用于初始化和管理 Galaxy 项目环境。</p>
<h2 id="基本用法-3"><a class="header" href="#基本用法-3">基本用法</a></h2>
<pre><code class="language-bash">gprj &lt;COMMAND&gt; [OPTIONS]
</code></pre>
<h2 id="命令列表"><a class="header" href="#命令列表">命令列表</a></h2>
<h3 id="1-init---初始化命令"><a class="header" href="#1-init---初始化命令">1. init - 初始化命令</a></h3>
<p>用于初始化 Galaxy 环境和项目。</p>
<h4 id="init-env---初始化-galaxy-环境"><a class="header" href="#init-env---初始化-galaxy-环境">init env - 初始化 Galaxy 环境</a></h4>
<pre><code class="language-bash">gprj init env
</code></pre>
<p>初始化系统级的 Galaxy 运行环境。</p>
<h4 id="init-prj-with-local---使用本地模块初始化项目"><a class="header" href="#init-prj-with-local---使用本地模块初始化项目">init prj-with-local - 使用本地模块初始化项目</a></h4>
<pre><code class="language-bash">gprj init prj-with-local
</code></pre>
<p>创建新项目并使用本地模块作为依赖。</p>
<h4 id="init-prj---使用远程模板初始化项目"><a class="header" href="#init-prj---使用远程模板初始化项目">init prj - 使用远程模板初始化项目</a></h4>
<pre><code class="language-bash">gprj init prj [OPTIONS]
</code></pre>
<h5 id="参数"><a class="header" href="#参数">参数</a></h5>
<ul>
<li><code>--tpl &lt;TPL&gt;</code>: 选择模板名称（默认：simple）
<ul>
<li>可选值：simple, open_pages, rust_prj 等</li>
</ul>
</li>
<li><code>--branch &lt;BRANCH&gt;</code>: 指定模板仓库分支</li>
<li><code>--tag &lt;TAG&gt;</code>: 指定模板仓库标签
<ul>
<li>可选值：alpha, develop, beta, release/1.0</li>
</ul>
</li>
<li><code>--repo &lt;REPO&gt;</code>: 模板仓库地址（默认：https://gal-tpl.git）</li>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别（默认：0）</li>
<li><code>--log &lt;LOG&gt;</code>: 日志配置</li>
<li><code>-p, --cmd-print</code>: 打印执行的命令</li>
</ul>
<h5 id="示例"><a class="header" href="#示例">示例</a></h5>
<pre><code class="language-bash"># 使用默认模板初始化
gprj init prj

# 使用特定模板
gprj init prj --tpl rust_prj

# 使用特定分支
gprj init prj --branch develop

# 使用特定标签
gprj init prj --tag release/1.0
</code></pre>
<h3 id="2-update---更新命令"><a class="header" href="#2-update---更新命令">2. update - 更新命令</a></h3>
<p>用于更新项目模块。</p>
<h4 id="update-mod---更新模块"><a class="header" href="#update-mod---更新模块">update mod - 更新模块</a></h4>
<pre><code class="language-bash">gprj update mod [OPTIONS]
</code></pre>
<h5 id="参数-1"><a class="header" href="#参数-1">参数</a></h5>
<ul>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别（默认：0）</li>
<li><code>-f, --conf-work &lt;CONF_WORK&gt;</code>: 工作配置文件（默认：./_gal/work.gxl）</li>
<li><code>--conf-adm &lt;CONF_ADM&gt;</code>: 管理配置文件（默认：./_gal/adm.gxl）</li>
<li><code>--log &lt;LOG&gt;</code>: 日志配置</li>
<li><code>-q, --quiet</code>: 静默模式（默认：true）</li>
</ul>
<h5 id="示例-1"><a class="header" href="#示例-1">示例</a></h5>
<pre><code class="language-bash"># 更新模块
gprj update mod

# 使用自定义配置更新
gprj update mod -f ./config/work.gxl
</code></pre>
<h3 id="3-conf---配置管理"><a class="header" href="#3-conf---配置管理">3. conf - 配置管理</a></h3>
<p>用于管理配置文件。</p>
<h4 id="conf-init---初始化配置"><a class="header" href="#conf-init---初始化配置">conf init - 初始化配置</a></h4>
<pre><code class="language-bash">gprj conf init [OPTIONS]
</code></pre>
<h5 id="参数-2"><a class="header" href="#参数-2">参数</a></h5>
<ul>
<li><code>-r, --remote</code>: 使用远程配置（默认：false）</li>
</ul>
<h5 id="示例-2"><a class="header" href="#示例-2">示例</a></h5>
<pre><code class="language-bash"># 初始化本地配置
gprj conf init

# 初始化远程配置
gprj conf init --remote
</code></pre>
<h3 id="4-check---检查命令"><a class="header" href="#4-check---检查命令">4. check - 检查命令</a></h3>
<p>检查当前项目配置和环境。</p>
<pre><code class="language-bash">gprj check
</code></pre>
<h3 id="5-adm---管理命令"><a class="header" href="#5-adm---管理命令">5. adm - 管理命令</a></h3>
<p>执行管理任务，等同于 gflow 的管理模式。</p>
<pre><code class="language-bash">gprj adm [OPTIONS]
</code></pre>
<h2 id="配置文件-3"><a class="header" href="#配置文件-3">配置文件</a></h2>
<h3 id="默认配置文件"><a class="header" href="#默认配置文件">默认配置文件</a></h3>
<ul>
<li><code>./_gal/work.gxl</code> - 工作流配置</li>
<li><code>./_gal/adm.gxl</code> - 管理配置</li>
<li><code>./_gal/head.gxl</code> - 头部配置</li>
</ul>
<h3 id="配置内容"><a class="header" href="#配置内容">配置内容</a></h3>
<ul>
<li>项目元数据</li>
<li>模块依赖</li>
<li>环境变量</li>
<li>执行策略</li>
</ul>
<h2 id="使用流程"><a class="header" href="#使用流程">使用流程</a></h2>
<h3 id="1-初始化新项目"><a class="header" href="#1-初始化新项目">1. 初始化新项目</a></h3>
<pre><code class="language-bash"># 1. 初始化环境
gprj init env

# 2. 初始化项目
gprj init prj --tpl simple

# 3. 检查配置
gprj check
</code></pre>
<h3 id="2-更新项目"><a class="header" href="#2-更新项目">2. 更新项目</a></h3>
<pre><code class="language-bash"># 更新所有模块
gprj update mod

# 使用自定义配置更新
gprj update mod -f ./my-config.gxl
</code></pre>
<h3 id="3-配置管理"><a class="header" href="#3-配置管理">3. 配置管理</a></h3>
<pre><code class="language-bash"># 初始化配置
gprj conf init

# 使用远程配置
gprj conf init --remote
</code></pre>
<h2 id="模板仓库"><a class="header" href="#模板仓库">模板仓库</a></h2>
<h3 id="默认模板仓库"><a class="header" href="#默认模板仓库">默认模板仓库</a></h3>
<ul>
<li>地址：https://gal-tpl.git</li>
<li>包含模板：simple, open_pages, rust_prj 等</li>
</ul>
<h3 id="自定义模板仓库"><a class="header" href="#自定义模板仓库">自定义模板仓库</a></h3>
<pre><code class="language-bash">gprj init prj --repo https://my-tpl.git --tpl my-template
</code></pre>
<h2 id="环境变量-3"><a class="header" href="#环境变量-3">环境变量</a></h2>
<ul>
<li><code>GALAXY_FLOW_HOME</code>: Galaxy Flow 主目录</li>
<li><code>RUST_LOG</code>: Rust 日志级别</li>
</ul>
<h2 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h2>
<ul>
<li><code>0</code>: 执行成功</li>
<li><code>非0</code>: 执行失败，返回错误码</li>
</ul>
<h2 id="常见问题-3"><a class="header" href="#常见问题-3">常见问题</a></h2>
<h3 id="权限问题-1"><a class="header" href="#权限问题-1">权限问题</a></h3>
<p>确保有执行权限：</p>
<pre><code class="language-bash">chmod +x gprj
</code></pre>
<h3 id="网络连接"><a class="header" href="#网络连接">网络连接</a></h3>
<p>初始化项目时需要网络连接以下载模板。</p>
<h3 id="模板选择"><a class="header" href="#模板选择">模板选择</a></h3>
<p>使用 <code>gprj init prj --help</code> 查看所有可用模板。</p>
<h3 id="配置冲突"><a class="header" href="#配置冲突">配置冲突</a></h3>
<p>如果配置文件已存在，先备份再重新初始化：</p>
<pre><code class="language-bash">mv _gal/work.gxl _gal/work.gxl.backup
gprj conf init
</code></pre>
<h2 id="最佳实践-2"><a class="header" href="#最佳实践-2">最佳实践</a></h2>
<h3 id="项目初始化"><a class="header" href="#项目初始化">项目初始化</a></h3>
<ol>
<li>先初始化环境：<code>gprj init env</code></li>
<li>选择合适的模板：<code>gprj init prj --tpl &lt;template&gt;</code></li>
<li>检查配置：<code>gprj check</code></li>
<li>更新模块：<code>gprj update mod</code></li>
</ol>
<h3 id="团队协作"><a class="header" href="#团队协作">团队协作</a></h3>
<ul>
<li>使用统一的模板仓库</li>
<li>定期更新模块：<code>gprj update mod</code></li>
<li>使用版本控制管理配置文件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gsys---galaxy-system-management-tool"><a class="header" href="#gsys---galaxy-system-management-tool">gsys - Galaxy System Management Tool</a></h1>
<h2 id="概述-4"><a class="header" href="#概述-4">概述</a></h2>
<p><code>gsys</code> 是 Galaxy 系统管理工具，用于创建、更新和本地化 Galaxy 系统配置。它提供了完整的系统生命周期管理功能，帮助开发者快速构建和维护 Galaxy 系统。</p>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<pre><code class="language-bash"># 从源代码安装
cargo install --path .

# 或者使用二进制分发
https://github.com/galaxy-sec/galaxy-ops/releases/latest/
</code></pre>
<h2 id="基本用法-4"><a class="header" href="#基本用法-4">基本用法</a></h2>
<h3 id="显示版本信息-2"><a class="header" href="#显示版本信息-2">显示版本信息</a></h3>
<pre><code class="language-bash">gsys
# 输出示例：gsys: 1.0.0
</code></pre>
<h3 id="显示帮助信息-2"><a class="header" href="#显示帮助信息-2">显示帮助信息</a></h3>
<pre><code class="language-bash">gsys --help
gsys &lt;command&gt; --help
</code></pre>
<h2 id="命令详解-2"><a class="header" href="#命令详解-2">命令详解</a></h2>
<h3 id="gsys-new"><a class="header" href="#gsys-new">gsys new</a></h3>
<p>创建新的系统操作符</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gsys new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 系统名称（字母数字，可包含连字符和下划线）【必填】</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的新系统</li>
<li>初始化系统目录结构</li>
<li>生成所有必需的配置文件</li>
<li>交互式选择系统型号配置</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 "my-system" 的新系统
gsys new --name my-system

# 创建系统时交互式选择系统型号
# 系统会提示：请选择系统型号配置:
# 1. ModelSTD_1
# 2. ModelSTD_2
# ...
# 选择完成后会自动生成对应的配置文件
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>创建目录：my-system/
生成配置文件：my-system/sys/sys_model.yml
生成模板文件：my-system/templates/
生成示例文件：my-system/examples/
</code></pre>
<h3 id="gsys-update"><a class="header" href="#gsys-update">gsys update</a></h3>
<p>更新现有系统配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gsys update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li>0：关闭调试输出</li>
<li>1：基础调试信息</li>
<li>2：详细调试信息</li>
<li>3：跟踪调试信息</li>
<li>4：完整调试信息</li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置（格式：模块=级别,模块=级别）</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：正常更新</li>
<li>1：跳过确认</li>
<li>2：覆盖文件</li>
<li>3：强制 git pull</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新系统的配置和依赖关系</li>
<li>下载远程引用的系统资源</li>
<li>支持多种强制更新模式</li>
<li>自动处理系统版本冲突</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新系统
gsys update

# 跳过确认更新
gsys update --force 1

# 详细调试输出更新过程
gsys update --debug 3 --log all=debug

# 完整强制更新
gsys update --force 3 --debug 4
</code></pre>
<h3 id="gsys-localize"><a class="header" href="#gsys-localize">gsys localize</a></h3>
<p>本地化系统配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gsys localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 值文件路径（YAML/JSON）</li>
<li><code>--default</code> - 使用内置默认值，不使用用户提供的 value.yml</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>根据环境特定的值生成本地化配置</li>
<li>支持多环境配置管理</li>
<li>可选择使用自定义或默认值</li>
<li>自动生成环境特定的配置文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认值本地化
gsys localize --default

# 使用自定义值文件本地化
gsys localize --value prod-values.yml

# 使用自定义值文件并启用调试
gsys localize --value dev-values.yml --debug 2

# 使用详细日志进行本地化
gsys localize --value staging-values.yml --log cmd=debug,localize=info
</code></pre>
<h2 id="系统型号配置"><a class="header" href="#系统型号配置">系统型号配置</a></h2>
<h3 id="支持的系统型号"><a class="header" href="#支持的系统型号">支持的系统型号</a></h3>
<p><code>gsys</code> 支持多种系统型号配置，可通过以下方式查看：</p>
<pre><code class="language-bash"># 查看所有支持的系统型号
python3 -c "from galaxy_ops.module import ModelSTD; print('\n'.join(str(m) for m in ModelSTD.support()))"
</code></pre>
<h3 id="系统型号选择"><a class="header" href="#系统型号选择">系统型号选择</a></h3>
<p>在创建新系统时，<code>gsys</code> 会交互式提示选择系统型号：</p>
<pre><code>请选择系统型号配置:
1. ModelSTD_AWS
2. ModelSTD_Docker
3. ModelSTD_Kubernetes
4. ModelSTD_BareMetal
5. 从当前系统自动检测
请输入选项编号 [1-5]:
</code></pre>
<h3 id="当前系统检测"><a class="header" href="#当前系统检测">当前系统检测</a></h3>
<p>如果选择"从当前系统自动检测"，<code>gsys</code> 会自动检测当前运行环境并生成对应的配置：</p>
<pre><code class="language-bash"># 自动检测当前系统
ModelSTD::from_cur_sys()  # 内部调用的方法
</code></pre>
<h2 id="环境变量-4"><a class="header" href="#环境变量-4">环境变量</a></h2>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置</li>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态</li>
<li><code>TEST_MODE</code> 和 <code>MOCK_SUCCESS</code> 用于测试环境，确保测试的安全性和隔离性</li>
</ul>
<h2 id="配置文件-4"><a class="header" href="#配置文件-4">配置文件</a></h2>
<h3 id="系统配置结构-1"><a class="header" href="#系统配置结构-1">系统配置结构</a></h3>
<pre><code>my-system/
├── sys/                       # 系统配置目录
│   ├── sys_model.yml          # 系统型号配置
│   ├── dependencies.yml      # 依赖配置
│   └── config/               # 系统配置
│       ├── default.yml        # 默认配置
│       ├── local.yml          # 本地配置
│       └── env/               # 环境特定配置
│           ├── dev.yml
│           ├── staging.yml
│           └── prod.yml
├── templates/                 # 模板目录
├── examples/                 # 示例文件
├── scripts/                  # 脚本文件
└── deployment/               # 部署配置
    ├── docker/
    ├── kubernetes/
    └── terraform/
</code></pre>
<h3 id="sys_modelyml-示例"><a class="header" href="#sys_modelyml-示例">sys_model.yml 示例</a></h3>
<pre><code class="language-yaml"># AWS 系统型号配置
system_name: my-aws-system
model: ModelSTD_AWS
version: "1.0.0"

# 基础配置
base_config:
  region: us-east-1
  availability_zones:
    - us-east-1a
    - us-east-1b
    - us-east-1c

# 计算资源
compute:
  type: auto_scaling
  min_size: 2
  max_size: 10
  desired_capacity: 3
  instance_type: t3.large

# 存储配置
storage:
  type: ebs
  volume_size: 100
  volume_type: gp3
  encrypted: true

# 网络配置
network:
  vpc_cidr: "10.0.0.0/16"
  subnet_cidrs:
    - "10.0.1.0/24"
    - "10.0.2.0/24"
    - "10.0.3.0/24"

# 安全配置
security:
  enable_vpc: true
  enable_security_groups: true
  enable_iam: true
</code></pre>
<h3 id="docker-系统型号配置"><a class="header" href="#docker-系统型号配置">Docker 系统型号配置</a></h3>
<pre><code class="language-yaml"># Docker 系统型号配置
system_name: my-docker-system
model: ModelSTD_Docker
version: "1.0.0"

# 容器配置
containers:
  - name: main
    image: "my-app:latest"
    ports:
      - "8080:80"
    environment:
      - NODE_ENV=production
    volumes:
      - "/opt/app/data:/app/data"

# 网络配置
networks:
  - name: app-network
    driver: bridge
    internal: false

# 数据卷配置
volumes:
  - name: app-data
    driver: local
</code></pre>
<h2 id="最佳实践-3"><a class="header" href="#最佳实践-3">最佳实践</a></h2>
<h3 id="系统命名"><a class="header" href="#系统命名">系统命名</a></h3>
<ul>
<li>使用小写字母、数字、连字符和下划线</li>
<li>避免特殊字符和空格</li>
<li>使用有意义的名称，如：<code>production-web-app</code></li>
<li>区分环境和用途：<code>dev-api-gateway</code></li>
</ul>
<h3 id="系统型号选择-1"><a class="header" href="#系统型号选择-1">系统型号选择</a></h3>
<pre><code class="language-bash"># AWS 环境
gsys new --name aws-ecommerce -- 选择 ModelSTD_AWS

# Docker 环境
gsys new --name docker-microservices -- 选择 ModelSTD_Docker

# Kubernetes 环境
gsys new --name k8s-monitoring -- 选择 ModelSTD_Kubernetes

# 裸金属服务器
gsys new --name bare-metal-database -- 选择 ModelSTD_BareMetal
</code></pre>
<h3 id="依赖管理-1"><a class="header" href="#依赖管理-1">依赖管理</a></h3>
<ul>
<li>定期更新系统依赖：<code>gsys update --force 1</code></li>
<li>在生产环境使用锁定版本</li>
<li>使用版本控制管理配置变更</li>
</ul>
<h3 id="配置管理-2"><a class="header" href="#配置管理-2">配置管理</a></h3>
<pre><code class="language-bash"># 开发环境配置
gsys localize --value dev-config.yml --log cmd=debug

# 测试环境配置
gsys localize --value test-config.yml

# 生产环境配置
gsys localize --value prod-config.yml --default
</code></pre>
<h2 id="故障排除-2"><a class="header" href="#故障排除-2">故障排除</a></h2>
<h3 id="常见问题-4"><a class="header" href="#常见问题-4">常见问题</a></h3>
<p><strong>Q: 创建系统失败</strong></p>
<pre><code>错误：无法创建目录 "my-system"
原因：目录已存在或权限不足
解决：删除现有目录或检查权限
</code></pre>
<p><strong>Q: 系统型号选择失败</strong></p>
<pre><code>错误：无法解析系统型号
解决：检查系统型号配置文件是否正确
gsys new --name test-system -- 选择 1
</code></pre>
<p><strong>Q: 更新系统时网络错误</strong></p>
<pre><code>错误：无法下载依赖
解决：检查网络连接和 git 配置
gsys update --debug 3 --log net=debug
</code></pre>
<p><strong>Q: 本地化失败</strong></p>
<pre><code>错误：无法解析值文件
解决：检查 YAML/JSON 格式是否正确
gsys localize --value config.yml --debug 2
</code></pre>
<h3 id="调试模式-3"><a class="header" href="#调试模式-3">调试模式</a></h3>
<p>使用调试模式获取详细的执行信息：</p>
<pre><code class="language-bash"># 最高级别调试
gsys update --debug 4 --log all=debug

# 关键模块调试
gsys new --name test --debug 3 --log cmd=debug

# 网络调试
gsys update --debug 3 --log net=debug
</code></pre>
<h3 id="系统诊断-1"><a class="header" href="#系统诊断-1">系统诊断</a></h3>
<pre><code class="language-bash"># 检查系统配置
ls -la my-system/sys/

# 验证系统型号配置
cat my-system/sys/sys_model.yml

# 检查环境配置
ls -la my-system/sys/config/env/
</code></pre>
<h2 id="测试-2"><a class="header" href="#测试-2">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxsys_run_success

# 运行测试并显示输出
cargo test -- --nocapture

# 测试环境隔离
TEST_MODE=true cargo test
</code></pre>
<h2 id="示例工作流-2"><a class="header" href="#示例工作流-2">示例工作流</a></h2>
<h3 id="开发新系统-1"><a class="header" href="#开发新系统-1">开发新系统</a></h3>
<pre><code class="language-bash"># 1. 创建新系统
gsys new --name my-system

# 2. 选择系统型号（交互式）
# 输入编号选择对应的系统型号

# 3. 编辑系统配置
cd my-system
vim sys/sys_model.yml

# 4. 更新系统资源
cd ..
gsys update

# 5. 本地化配置
gsys localize --value dev-config.yml

# 6. 验证系统配置
ls -la my-system/sys/config/env/
</code></pre>
<h3 id="部署到生产环境-2"><a class="header" href="#部署到生产环境-2">部署到生产环境</a></h3>
<pre><code class="language-bash"># 1. 创建生产系统
gsys new --name production-system

# 2. 选择生产环境系统型号
# 根据实际情况选择 AWS/Docker/K8s 等

# 3. 更新到最新版本
gsys update --force 3

# 4. 使用生产配置本地化
gsys localize --value prod-config.yml --default

# 5. 验证生产配置
cat my-system/sys/config/env/prod.yml
</code></pre>
<h2 id="版本历史-2"><a class="header" href="#版本历史-2">版本历史</a></h2>
<h3 id="当前版本100-2"><a class="header" href="#当前版本100-2">当前版本：1.0.0</a></h3>
<ul>
<li>初始版本</li>
<li>支持系统创建、更新和本地化</li>
<li>交互式系统型号选择</li>
<li>多种系统型号支持（AWS、Docker、Kubernetes、BareMetal）</li>
<li>完整的错误处理和日志记录</li>
</ul>
<h2 id="贡献指南-2"><a class="header" href="#贡献指南-2">贡献指南</a></h2>
<p>欢迎贡献代码和建议：</p>
<ol>
<li>Fork 项目</li>
<li>创建特性分支</li>
<li>提交更改</li>
<li>推送到分支</li>
<li>创建 Pull Request</li>
</ol>
<h2 id="许可证-2"><a class="header" href="#许可证-2">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buildin"><a class="header" href="#buildin">BUILDIN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="维护器"><a class="header" href="#维护器">维护器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统维护器"><a class="header" href="#系统维护器">系统维护器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="系统模型配置"><a class="header" href="#系统模型配置">系统模型配置</a></h1>
<h2 id="概述-5"><a class="header" href="#概述-5">概述</a></h2>
<p><code>sys_model.yml</code> 是 Sys-Operator 中最重要的配置文件之一，定义了系统的基础信息、目标运行环境和扩展元数据。所有系统都必须包含这个文件，它是系统定义的核心。</p>
<h2 id="配置结构"><a class="header" href="#配置结构">配置结构</a></h2>
<h3 id="基础系统定义"><a class="header" href="#基础系统定义">基础系统定义</a></h3>
<pre><code class="language-yaml"># 必需字段
name: system_name                    # 系统名称（必需）
model: arm-mac14-host               # 目标平台模型（必需）
vender: "Galaxy-Ops"                # 厂商信息（可选）
</code></pre>
<h3 id="扩展元数据"><a class="header" href="#扩展元数据">扩展元数据</a></h3>
<h2 id="字段详解"><a class="header" href="#字段详解">字段详解</a></h2>
<h3 id="1-name---系统名称"><a class="header" href="#1-name---系统名称">1. <code>name</code> - 系统名称</a></h3>
<p><strong>类型</strong>: <code>string</code>
<strong>必需</strong>: <code>是</code>
<strong>描述</strong>: 系统的唯一标识名称</p>
<p><strong>规范</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>避免特殊字符和空格</li>
<li>长度建议不超过 64 个字符</li>
<li>避免使用保留关键字</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的示例
name: production_web_system
name: microservice_platform
name: database_cluster

# 避免的示例
name: Production Web System  # 包含空格
name: prod_web_system$      # 包含特殊字符
name: sys_1                 # 无意义的编号
</code></pre>
<h3 id="2-model---目标平台模型"><a class="header" href="#2-model---目标平台模型">2. <code>model</code> - 目标平台模型</a></h3>
<p><strong>类型</strong>: <code>string</code>
<strong>必需</strong>: <code>是</code>
<strong>描述</strong>: 系统运行的目标平台和环境</p>
<p><strong>格式</strong>: <code>arch-os-spc</code></p>
<p><strong>组成部分</strong>:</p>
<ul>
<li>
<p><strong>架构 (arch)</strong>:</p>
<ul>
<li><code>arm</code>: ARM 架构（Apple M1/M2, Raspberry Pi 等）</li>
<li><code>x86</code>: x86-64 架构（Intel/AMD）</li>
<li><code>amd64</code>: AMD64 架构（兼容 x86-64）</li>
<li><code>aarch64</code>: ARM64 架构</li>
</ul>
</li>
<li>
<p><strong>操作系统 (os)</strong>:</p>
<ul>
<li><code>mac14</code>: macOS 14.x</li>
<li><code>ubt22</code>: Ubuntu 22.04 LTS</li>
</ul>
</li>
<li>
<p><strong>环境 (spc)</strong>:</p>
<ul>
<li><code>host</code>: 宿主机环境</li>
<li><code>k8s</code>: Kubernetes 环境</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># Apple M1 芯片，macOS 14，Host 模式
model: arm-mac14-host

# Intel x86，Ubuntu 22.04，Kubernetes 模式
model: x86-ubt22-k8s

# Intel x86，Ubuntu 22.04，Docker 容器模式
model: x86-ubt22-docker

</code></pre>
<h3 id="3-vender---厂商信息"><a class="header" href="#3-vender---厂商信息">3. <code>vender</code> - 厂商信息</a></h3>
<p><strong>类型</strong>: <code>string</code>
<strong>必需</strong>: <code>否</code>
<strong>描述</strong>: 系统的厂商、组织或开发者信息</p>
<p><strong>用途</strong>:</p>
<ul>
<li>标识系统来源</li>
<li>版本管理和发布</li>
<li>技术支持联系</li>
<li>生态系统分类</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml">vender: "Galaxy-Ops"
vender: "Enterprise Corp"
vender: "Open Source Community"
vender: "Development Team"
</code></pre>
<h2 id="最佳实践-4"><a class="header" href="#最佳实践-4">最佳实践</a></h2>
<h3 id="1-命名最佳实践"><a class="header" href="#1-命名最佳实践">1. 命名最佳实践</a></h3>
<h4 id="系统命名建议"><a class="header" href="#系统命名建议">系统命名建议</a></h4>
<ul>
<li>使用描述性名称，清晰表达系统功能</li>
<li>包含环境标识（如 <code>production_</code>, <code>staging_</code>, <code>dev_</code>）</li>
<li>避免使用版本号（使用 <code>metadata.version</code> 管理）</li>
<li>保持命名一致性</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的命名
name: production_web_system
name: staging_api_gateway
name: dev_database_cluster
name: monitoring_platform

# 避免的命名
name: web_system_prod      # 环境标识分离
name: sys_v2               # 版本号分离
name: app1                 # 无意义的编号
</code></pre>
<h4 id="版本管理建议"><a class="header" href="#版本管理建议">版本管理建议</a></h4>
<ul>
<li>使用语义化版本</li>
<li>使用 <code>metadata.version</code> 而非文件名</li>
<li>考虑使用标签和分支管理版本</li>
</ul>
<h3 id="3-模型选择建议"><a class="header" href="#3-模型选择建议">3. 模型选择建议</a></h3>
<h4 id="平台兼容性"><a class="header" href="#平台兼容性">平台兼容性</a></h4>
<ul>
<li>选择目标部署环境支持的平台模型</li>
<li>考虑跨平台兼容性需求</li>
<li>明确标记平台特定的配置</li>
</ul>
<h4 id="环境区分"><a class="header" href="#环境区分">环境区分</a></h4>
<ul>
<li>使用不同的模型区分开发和生产环境</li>
<li>考虑容器化 vs 宿主机部署的差异</li>
<li>支持混合环境部署需求</li>
</ul>
<h2 id="故障排除-3"><a class="header" href="#故障排除-3">故障排除</a></h2>
<h3 id="1-常见错误"><a class="header" href="#1-常见错误">1. 常见错误</a></h3>
<h4 id="缺少必需字段"><a class="header" href="#缺少必需字段">缺少必需字段</a></h4>
<pre><code class="language-yaml"># 错误示例
# 缺少 name 字段
model: x86-ubt22-host
vender: "Example Corp"

# 缺少 model 字段
name: example_system
vender: "Example Corp"
</code></pre>
<h4 id="模型格式错误"><a class="header" href="#模型格式错误">模型格式错误</a></h4>
<pre><code class="language-yaml"># 错误示例
model: arm-mac-14-host    # 分隔符错误
model: x86-ubuntu-22-host # 操作系统名称错误
model: arm-mac14-docker  # 不支持的环境
</code></pre>
<h4 id="命名格式错误"><a class="header" href="#命名格式错误">命名格式错误</a></h4>
<pre><code class="language-yaml"># 错误示例
name: Production System  # 包含空格
name: system$1           # 包含特殊字符
name: SYSTEM_NAME        # 包含大写字母
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><code>sys_model.yml</code> 是系统配置的核心文件，定义了系统的基础信息和运行环境。理解各个字段的含义和规范对于正确配置系统至关重要：</p>
<ol>
<li><strong>name</strong>: 系统的唯一标识，必须规范命名</li>
<li><strong>model</strong>: 目标平台环境，格式必须正确</li>
<li><strong>vender</strong>: 厂商信息，用于标识系统来源</li>
</ol>
<p>遵循这些配置规范和最佳实践，可以：</p>
<ul>
<li>提高配置的可读性和维护性</li>
<li>确保系统在不同环境中的正确部署</li>
<li>支持系统的版本管理和生命周期管理</li>
<li>便于团队协作和知识共享</li>
</ul>
<p>建议在使用过程中：</p>
<ul>
<li>定期验证配置文件的正确性</li>
<li>保持命名和格式的一致性</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务系统示例"><a class="header" href="#微服务系统示例">微服务系统示例</a></h1>
<h2 id="概述-6"><a class="header" href="#概述-6">概述</a></h2>
<p>本文档提供了一个完整的微服务系统示例，展示如何使用 Sys-Operator 构建和管理复杂的微服务架构。该示例包含 Web 前端、API 网关、用户服务、订单服务和数据库等多个模块，体现了现代微服务系统的典型架构模式。</p>
<h2 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h2>
<h3 id="整体架构图"><a class="header" href="#整体架构图">整体架构图</a></h3>
<pre class="mermaid">graph TB
    subgraph &quot;客户端层&quot;
        A[Web浏览器]
        B[移动应用]
        C[API客户端]
    end

    subgraph &quot;接入层&quot;
        D[Nginx Ingress]
        E[API Gateway]
    end

    subgraph &quot;业务服务层&quot;
        F[用户服务]
        G[订单服务]
        H[支付服务]
        I[通知服务]
    end

    subgraph &quot;数据层&quot;
        J[PostgreSQL主库]
        K[PostgreSQL从库]
        L[Redis缓存]
    end

    subgraph &quot;基础设施层&quot;
        M[Kubernetes集群]
        N[监控系统]
        O[日志系统]
    end

    A --&gt; D
    B --&gt; D
    C --&gt; E

    D --&gt; E
    E --&gt; F
    E --&gt; G
    E --&gt; H
    E --&gt; I

    F --&gt; J
    G --&gt; J
    H --&gt; J
    I --&gt; L

    J --&gt; K
    J --&gt; L

    F --&gt; M
    G --&gt; M
    H --&gt; M
    I --&gt; M

    M --&gt; N
    M --&gt; O
</pre>
<h3 id="服务依赖关系"><a class="header" href="#服务依赖关系">服务依赖关系</a></h3>
<pre><code>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户服务      │───▶│   订单服务      │───▶│   支付服务      │
│ (UserService)   │    │ (OrderService)  │    │ (PaymentService) │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   PostgreSQL    │    │   PostgreSQL    │    │   PostgreSQL    │
│    主库         │    │    主库         │    │    主库         │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    Redis缓存    │    │    Redis缓存    │    │    Redis缓存    │
│ (用户会话)      │    │ (订单状态)      │    │ (支付状态)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
</code></pre>
<h2 id="系统配置"><a class="header" href="#系统配置">系统配置</a></h2>
<h3 id="1-系统模型定义-syssys_modelyml"><a class="header" href="#1-系统模型定义-syssys_modelyml">1. 系统模型定义 (<code>sys/sys_model.yml</code>)</a></h3>
<pre><code class="language-yaml"># 系统基本信息
name: microservice_platform
model: x86-ubt22-k8s
vender: "TechCorp"


### 2. 模块列表配置 (`sys/mod_list.yml`)

```yaml
# 接入层模块
- name: nginx_ingress
  addr:
    repo: https://github.com/galaxy-operators/nginx
    tag: v1.25.3
  model: x86-ubt22-k8s
  enable: true


- name: api_gateway
  addr:
    repo: https://github.com/galaxy-operators/api-gateway
    tag: v3.0.0
  model: x86-ubt22-k8s
  enable: true
  priority: 90


# 用户服务模块
- name: user_service
  addr:
    repo: https://github.com/techcorp/user-service
    tag: v4.1.0
  model: x86-ubt22-k8s
  enable: true
  priority: 80


# 订单服务模块
- name: order_service
  addr:
    repo: https://github.com/techcorp/order-service
    tag: v3.5.0
  model: x86-ubt22-k8s
  enable: true
  priority: 70


# 支付服务模块
- name: payment_service
  addr:
    repo: https://github.com/techcorp/payment-service
    tag: v2.8.0
  model: x86-ubt22-k8s
  enable: true


# 通知服务模块
- name: notification_service
  addr:
    repo: https://github.com/techcorp/notification-service
    tag: v1.6.0
  model: x86-ubt22-k8s
  enable: true
  priority: 60


# 数据库模块
- name: postgres_primary
  addr:
    repo: https://github.com/galaxy-operators/postgresql-ha
    tag: v15.5.0
  model: x86-ubt22-k8s
  enable: true


- name: postgres_readonly
  addr:
    repo: https://github.com/galaxy-operators/postgresql-ha
    tag: v15.5.0
  model: x86-ubt22-k8s
  enable: true


# 缓存模块
- name: redis_cache
  addr:
    repo: https://github.com/galaxy-operators/redis-ha
    tag: v7.2.4
  model: x86-ubt22-k8s
  enable: true


# 外部服务模块
- name: external_payment_gateway
  addr:
    path: ./external-gateways/payment-gateway
  model: x86-ubt22-k8s


# 监控模块
- name: monitoring_stack
  addr:
    repo: https://github.com/galaxy-operators/enterprise-monitoring
    tag: v2.5.0
  model: x86-ubt22-k8s
  enable: true

</code></pre>
<h3 id="3-系统变量配置-sysvarsyml"><a class="header" href="#3-系统变量配置-sysvarsyml">3. 系统变量配置 (<code>sys/vars.yml</code>)</a></h3>
<pre><code class="language-yaml"># 系统配置
vars:
# 环境配置
- name: ENVIRONMENT
  value: "production"
  description: "部署环境"
  group: environment

- name: CLUSTER_NAME
  value: "${CLUSTER_NAME:production-cluster}"
  description: "Kubernetes集群名称"
  group: environment

- name: NAMESPACE
  value: "${NAMESPACE:microservices}"
  description: "Kubernetes命名空间"
  group: environment

# 应用配置
- name: APP_VERSION
  value: "2.3.0"
  description: "应用版本"
  group: application

- name: DOMAIN_NAME
  value: "${DOMAIN_NAME:platform.techcorp.com}"
  description: "系统域名"
  group: application

- name: BASE_URL
  value: "https://${DOMAIN_NAME}"
  description: "基础URL"
  group: application

# 安全配置
- name: ENABLE_MTLS
  value: "${ENABLE_MTLS:true}"
  description: "启用双向TLS"
  type: boolean
  group: security

- name: API_RATE_LIMIT
  value: "${API_RATE_LIMIT:1000}"
  description: "API速率限制"
  type: integer
  min: 1
  max: 10000
  group: security

- name: SESSION_TIMEOUT_MINUTES
  value: "${SESSION_TIMEOUT_MINUTES:30}"
  description: "会话超时时间"
  type: integer
  min: 5
  max: 1440
  group: security

# 数据库配置
- name: DATABASE_BACKUP_SCHEDULE
  value: "${DATABASE_BACKUP_SCHEDULE:0 1 * * *}"
  description: "数据库备份计划"
  group: database

- name: DATABASE_RETENTION_DAYS
  value: "${DATABASE_RETENTION_DAYS:30}"
  description: "数据保留天数"
  type: integer
  min: 7
  max: 365
  group: database

- name: CONNECTION_POOL_SIZE
  value: "${CONNECTION_POOL_SIZE:20}"
  description: "连接池大小"
  type: integer
  min: 1
  max: 100
  group: database

# 缓存配置
- name: CACHE_DEFAULT_TTL
  value: "${CACHE_DEFAULT_TTL:3600}"
  description: "默认缓存TTL（秒）"
  type: integer
  min: 60
  max: 86400
  group: cache

- name: CACHE_MAX_SIZE
  value: "${CACHE_MAX_SIZE:10000}"
  description: "缓存最大条目数"
  type: integer
  min: 100
  max: 100000
  group: cache

- name: CACHE_REFRESH_INTERVAL
  value: "${CACHE_REFRESH_INTERVAL:300}"
  description: "缓存刷新间隔（秒）"
  type: integer
  min: 60
  max: 3600
  group: cache

# 消息队列配置
- name: MESSAGE_QUEUE_MAX_RETRIES
  value: "${MESSAGE_QUEUE_MAX_RETRIES:3}"
  description: "消息队列最大重试次数"
  type: integer
  min: 1
  max: 10
  group: messaging

- name: MESSAGE_QUEUE_DELAY_SECONDS
  value: "${MESSAGE_QUEUE_DELAY_SECONDS:60}"
  description: "消息队列重试延迟"
  type: integer
  min: 10
  max: 3600
  group: messaging

# 高可用配置
- name: HIGH_AVAILABILITY_ENABLED
  value: "${HIGH_AVAILABILITY_ENABLED:true}"
  description: "启用高可用"
  type: boolean
  group: ha

- name: HEALTH_CHECK_INTERVAL_SECONDS
  value: "${HEALTH_CHECK_INTERVAL_SECONDS:30}"
  description: "健康检查间隔"
  type: integer
  min: 10
  max: 300
  group: ha

- name: FAILURE_DETECTION_SECONDS
  value: "${FAILURE_DETECTION_SECONDS:60}"
  description: "故障检测时间"
  type: integer
  min: 30
  max: 300
  group: ha

- name: AUTO_FAILOVER_ENABLED
  value: "${AUTO_FAILOVER_ENABLED:true}"
  description: "启用自动故障转移"
  type: boolean
  group: ha

# 性能配置
- name: DEFAULT_REPLICAS
  value: "${DEFAULT_REPLICAS:2}"
  description: "默认副本数"
  type: integer
  min: 1
  max: 10
  group: performance

- name: MAX_REPLICAS
  value: "${MAX_REPLICAS:10}"
  description: "最大副本数"
  type: integer
  min: 1
  max: 100
  group: performance

- name: CPU_REQUEST
  value: "${CPU_REQUEST:100m}"
  description: "CPU请求值"
  group: performance

- name: MEMORY_REQUEST
  value: "${MEMORY_REQUEST:256Mi}"
  description: "内存请求值"
  group: performance

- name: CPU_LIMIT
  value: "${CPU_LIMIT:2000m}"
  description: "CPU限制值"
  group: performance

- name: MEMORY_LIMIT
  value: "${MEMORY_LIMIT:4Gi}"
  description: "内存限制值"
  group: performance

# 监控配置
- name: MONITORING_ENABLED
  value: "${MONITORING_ENABLED:true}"
  description: "启用监控"
  type: boolean
  group: monitoring

- name: ALERT_EMAIL_RECIPIENTS
  value: "${ALERT_EMAIL_RECIPIENTS:devops-alerts@techcorp.com}"
  description: "告警邮件接收者"
  group: monitoring

- name: SLACK_WEBHOOK_URL
  value: "${SLACK_WEBHOOK_URL}"
  description: "Slack Webhook URL"
  group: monitoring

- name: PAGERDUTY_SERVICE_KEY
  value: "${PAGERDUTY_SERVICE_KEY}"
  description: "PagerDuty服务密钥"
  group: monitoring

# 业务配置
- name: BUSINESS_HOURS_START
  value: "${BUSINESS_HOURS_START:09:00}"
  description: "业务开始时间"
  group: business

- name: BUSINESS_HOURS_END
  value: "${BUSINESS_HOURS_END:18:00}"
  description: "业务结束时间"
  group: business

- name: MAINTENANCE_WINDOW_START
  value: "${MAINTENANCE_WINDOW_START:02:00}"
  description: "维护窗口开始时间"
  group: business

- name: MAINTENANCE_WINDOW_END
  value: "${MAINTENANCE_WINDOW_END:04:00}"
  description: "维护窗口结束时间"
  group: business

- name: FEATURE_FLAGS
  value: "${FEATURE_FLAGS:new-dashboard,advanced-analytics}"
  description: "功能开关"
  group: business
</code></pre>
<h3 id="4-系统工作流配置-sysworkflowsoperatorsgxl"><a class="header" href="#4-系统工作流配置-sysworkflowsoperatorsgxl">4. 系统工作流配置 (<code>sys/workflows/operators.gxl</code>)</a></h3>
<pre><code class="language-gxl">// 系统操作符工作流
mod operators : sys_ops {
    // 自动加载入口
    #[auto_load(entry)]
    flow __into {
        // 加载系统配置
        gx.read_file(
            file : "sys/sys_model.yml",
            name : "SYSTEM_DEFINE"
        );

        gx.read_file(
            file : "sys/mod_list.yml",
            name : "MODULE_LIST"
        );

        gx.read_file(
            file : "sys/vars.yml",
            name : "SYSTEM_VARS"
        );
    }

    // 系统初始化任务
    #[task(name="gsys@init")]
    flow init {
        gx.echo("=== 开始微服务系统初始化 ===");
        gx.echo("系统名称: ${SYSTEM_DEFINE.NAME}");
        gx.echo("目标平台: ${SYSTEM_DEFINE.MODEL}");

        // 1. 基础环境检查
        gx.echo("1. 检查基础环境...");
        gx.check_environment();
        gx.check_kubernetes_cluster();
        gx.check_network_connectivity();

        // 2. 创建系统目录
        gx.echo("2. 创建系统目录结构...");
        gx.cmd("mkdir -p sys/mods");
        gx.cmd("mkdir -p sys/workflows");
        gx.cmd("mkdir -p config/helm");

        // 3. 下载和验证模块
        gx.echo("3. 下载和验证系统模块...");
        let module_count = 0;
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("  处理模块: ${MODULE.NAME}");

                // 下载模块
                gx.download_module(${MODULE});

                // 验证模块
                gx.validate_module(${MODULE});

                // 生成本地化配置
                gx.generate_local_config(${MODULE});

                module_count = module_count + 1;
            }
        }
        gx.echo("  总计处理 ${module_count} 个模块");

        // 4. 生成Helm图表
        gx.echo("4. 生成Helm部署图表...");
        gx.generate_helm_charts();

        // 5. 验证系统配置
        gx.echo("5. 验证系统配置...");
        gx.validate_system_config();

        gx.echo("=== 微服务系统初始化完成 ===");
    }

    // 系统本地化任务
    #[task(name="gsys@localize")]
    flow localize {
        gx.echo("=== 开始微服务系统本地化 ===");

        // 1. 本地化系统配置
        gx.echo("1. 本地化系统配置...");
        gx.localize_system_config();

        // 2. 本地化各个模块
        gx.echo("2. 本地化系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("  本地化模块: ${MODULE.NAME}");
                gx.localize_module(${MODULE});
            }
        }

        // 3. 生成本地化报告
        gx.echo("3. 生成本地化报告...");
        gx.generate_localization_report();

        // 4. 生成环境特定配置
        gx.echo("4. 生成环境特定配置...");
        gx.generate_environment_configs();

        gx.echo("=== 微服务系统本地化完成 ===");
    }

    // 系统部署任务
    #[task(name="gsys@deploy")]
    flow deploy {
        gx.echo("=== 开始微服务系统部署 ===");

        // 1. 部署基础设施组件
        gx.echo("1. 部署基础设施组件...");
        gx.deploy_infrastructure();

        // 2. 部署数据库组件
        gx.echo("2. 部署数据库组件...");
        gx.deploy_database_components();

        // 3. 部署缓存组件
        gx.echo("3. 部署缓存组件...");
        gx.deploy_cache_components();

        // 4. 部署业务服务
        gx.echo("4. 部署业务服务...");
        gx.deploy_business_services();

        // 5. 部署网关和负载均衡
        gx.echo("5. 部署网关和负载均衡...");
        gx.deploy_gateway_components();

        // 6. 部署监控系统
        gx.echo("6. 部署监控系统...");
        gx.deploy_monitoring_components();

        // 7. 验证部署结果
        gx.echo("7. 验证部署结果...");
        gx.validate_deployment();

        gx.echo("=== 微服务系统部署完成 ===");
    }

    // 系统健康检查任务
    #[task(name="gsys@health")]
    flow health {
        gx.echo("=== 开始微服务系统健康检查 ===");

        // 1. 检查基础设施健康
        gx.echo("1. 检查基础设施健康...");
        gx.check_infrastructure_health();

        // 2. 检查数据库健康
        gx.echo("2. 检查数据库健康...");
        gx.check_database_health();

        // 3. 检查缓存健康
        gx.echo("3. 检查缓存健康...");
        gx.check_cache_health();

        // 4. 检查业务服务健康
        gx.echo("4. 检查业务服务健康...");
        gx.check_service_health();

        // 5. 检查网关健康
        gx.echo("5. 检查网关健康...");
        gx.check_gateway_health();

        // 6. 生成健康报告
        gx.echo("6. 生成健康报告...");
        gx.generate_health_report();

        gx.echo("=== 微服务系统健康检查完成 ===");
    }

    // 系统扩缩容任务
    #[task(name="gsys@scale")]
    flow scale {
        gx.echo("=== 开始微服务系统扩缩容 ===");

        // 1. 分析负载情况
        gx.echo("1. 分析系统负载...");
        let load_analysis = gx.analyze_system_load();

        // 2. 确定扩缩容策略
        gx.echo("2. 确定扩缩容策略...");
        let scale_strategy = gx.determine_scale_strategy(load_analysis);

        // 3. 执行扩缩容操作
        gx.echo("3. 执行扩缩容操作...");
        gx.execute_scaling(scale_strategy);

        // 4. 验证扩缩容结果
        gx.echo("4. 验证扩缩容结果...");
        gx.validate_scaling_result();

        gx.echo("=== 微服务系统扩缩容完成 ===");
    }

    // 系统备份任务
    #[task(name="gsys@backup")]
    flow backup {
        gx.echo("=== 开始微服务系统备份 ===");

        // 1. 备份数据库
        gx.echo("1. 备份数据库...");
        gx.backup_databases();

        // 2. 备份配置文件
        gx.echo("2. 备份配置文件...");
        gx.backup_configurations();

        // 3. 备份应用数据
        gx.echo("3. 备份应用数据...");
        gx.backup_application_data();

        // 4. 备份监控系统数据
        gx.echo("4. 备份监控系统数据...");
        gx.backup_monitoring_data();

        // 5. 生成备份报告
        gx.echo("5. 生成备份报告...");
        gx.generate_backup_report();

        gx.echo("=== 微服务系统备份完成 ===");
    }

    // 系统恢复任务
    #[task(name="gsys@restore")]
    flow restore {
        gx.echo("=== 开始微服务系统恢复 ===");

        // 1. 验证备份完整性
        gx.echo("1. 验证备份完整性...");
        gx.validate_backup_integrity();

        // 2. 恢复数据库
        gx.echo("2. 恢复数据库...");
        gx.restore_databases();

        // 3. 恢复配置文件
        gx.echo("3. 恢复配置文件...");
        gx.restore_configurations();

        // 4. 恢复应用数据
        gx.echo("4. 恢复应用数据...");
        gx.restore_application_data();

        // 5. 验证恢复结果
        gx.echo("5. 验证恢复结果...");
        gx.validate_restore_result();

        gx.echo("=== 微服务系统恢复完成 ===");
    }
}
</code></pre>
<h2 id="部署指南"><a class="header" href="#部署指南">部署指南</a></h2>
<h3 id="1-前置要求"><a class="header" href="#1-前置要求">1. 前置要求</a></h3>
<ul>
<li><strong>Kubernetes集群</strong>: 1.20+ 版本</li>
<li><strong>存储支持</strong>: 支持动态配置的存储类</li>
<li><strong>网络插件</strong>: 支持LoadBalancer服务</li>
<li><strong>监控系统</strong>: Prometheus + Grafana</li>
<li><strong>日志系统</strong>: EFK 或类似方案</li>
</ul>
<h3 id="2-快速部署"><a class="header" href="#2-快速部署">2. 快速部署</a></h3>
<pre><code class="language-bash"># 1. 创建系统目录
mkdir microservice-platform
cd microservice-platform

# 2. 初始化系统结构
gsys init

# 3. 复制配置文件
cp ../config/sys_model.yml sys/
cp ../config/mod_list.yml sys/
cp ../config/vars.yml sys/

# 4. 部署系统
gsys deploy

# 5. 检查部署状态
gsys health
</code></pre>
<h3 id="3-helm部署"><a class="header" href="#3-helm部署">3. Helm部署</a></h3>
<pre><code class="language-bash"># 1. 生成本地Helm图表
gsys generate-helm-charts

# 2. 部署基础组件
helm install infra ./helm/infrastructure/

# 3. 部署数据库
helm install db ./helm/database/

# 4. 部署缓存
helm install cache ./helm/cache/

# 5. 部署业务服务
helm install services ./helm/services/

# 6. 部署监控
helm install monitoring ./helm/monitoring/
</code></pre>
<h3 id="4-环境配置"><a class="header" href="#4-环境配置">4. 环境配置</a></h3>
<h4 id="开发环境"><a class="header" href="#开发环境">开发环境</a></h4>
<pre><code class="language-yaml"># 开发环境配置
env: "development"
cluster_name: "dev-cluster"
namespace: "dev-microservices"

# 数据库配置
database_host: "dev-postgresql"
database_port: 5432
max_connections: 50

# 缓存配置
cache_enabled: true
cache_ttl: 300

# 监控配置
monitoring_enabled: false
logging_level: "debug"
</code></pre>
<h4 id="生产环境"><a class="header" href="#生产环境">生产环境</a></h4>
<pre><code class="language-yaml"># 生产环境配置
env: "production"
cluster_name: "prod-cluster"
namespace: "prod-microservices"

# 数据库配置
database_host: "prod-postgresql-primary"
database_port: 5432
max_connections: 500
backup_enabled: true

# 缓存配置
cache_enabled: true
cache_ttl: 3600

# 监控配置
monitoring_enabled: true
logging_level: "info"
</code></pre>
<h3 id="5-监控配置"><a class="header" href="#5-监控配置">5. 监控配置</a></h3>
<h4 id="prometheus配置"><a class="header" href="#prometheus配置">Prometheus配置</a></h4>
<pre><code class="language-yaml"># prometheus-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    scrape_configs:
    - job_name: 'kubernetes-pods'
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
</code></pre>
<h4 id="grafana仪表板"><a class="header" href="#grafana仪表板">Grafana仪表板</a></h4>
<pre><code class="language-json">{
  "dashboard": {
    "title": "微服务平台监控",
    "panels": [
      {
        "title": "API响应时间",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "{{method}} {{status}}"
          }
        ]
      },
      {
        "title": "API请求量",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total[5m]))",
            "legendFormat": "Total requests"
          }
        ]
      },
      {
        "title": "数据库连接数",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends",
            "legendFormat": "Database connections"
          }
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="最佳实践-5"><a class="header" href="#最佳实践-5">最佳实践</a></h2>
<h3 id="1-架构设计原则"><a class="header" href="#1-架构设计原则">1. 架构设计原则</a></h3>
<h4 id="微服务拆分原则"><a class="header" href="#微服务拆分原则">微服务拆分原则</a></h4>
<ul>
<li><strong>单一职责</strong>: 每个微服务只负责单一业务功能</li>
<li><strong>团队自治</strong>: 服务由独立团队开发和维护</li>
<li><strong>服务粒度</strong>: 服务大小适中，避免过细或过粗</li>
<li><strong>数据自治</strong>: 每个服务管理自己的数据</li>
</ul>
<h4 id="服务发现原则"><a class="header" href="#服务发现原则">服务发现原则</a></h4>
<ul>
<li><strong>注册中心</strong>: 使用服务注册中心管理服务实例</li>
<li><strong>健康检查</strong>: 定期检查服务健康状态</li>
<li><strong>负载均衡</strong>: 实现客户端和服务端负载均衡</li>
<li><strong>容错机制</strong>: 实现熔断、重试、降级等容错机制</li>
</ul>
<h3 id="2-数据管理原则"><a class="header" href="#2-数据管理原则">2. 数据管理原则</a></h3>
<h4 id="数据一致性"><a class="header" href="#数据一致性">数据一致性</a></h4>
<ul>
<li><strong>最终一致性</strong>: 优先采用最终一致性模型</li>
<li><strong>补偿事务</strong>: 使用补偿事务处理分布式事务</li>
<li><strong>事件驱动</strong>: 采用事件驱动架构保持数据同步</li>
<li><strong>数据备份</strong>: 实现定期数据备份和恢复机制</li>
</ul>
<h4 id="数据安全"><a class="header" href="#数据安全">数据安全</a></h4>
<ul>
<li><strong>加密存储</strong>: 敏感数据加密存储</li>
<li><strong>访问控制</strong>: 实现细粒度的数据访问控制</li>
<li><strong>审计日志</strong>: 记录数据访问和变更日志</li>
<li><strong>合规性</strong>: 遵循数据保护和隐私合规要求</li>
</ul>
<h3 id="3-运维管理原则"><a class="header" href="#3-运维管理原则">3. 运维管理原则</a></h3>
<h4 id="监控告警"><a class="header" href="#监控告警">监控告警</a></h4>
<ul>
<li><strong>全面监控</strong>: 实现基础设施、平台、应用三层监控</li>
<li><strong>智能告警</strong>: 基于机器学习的智能告警策略</li>
<li><strong>多渠道通知</strong>: 支持邮件、短信、即时通讯等多渠道通知</li>
<li><strong>告警收敛</strong>: 实现告警聚合和收敛机制</li>
</ul>
<h4 id="发布策略"><a class="header" href="#发布策略">发布策略</a></h4>
<ul>
<li><strong>蓝绿部署</strong>: 使用蓝绿部署减少停机时间</li>
<li><strong>金丝雀发布</strong>: 采用金丝雀发布降低风险</li>
<li><strong>自动化测试</strong>: 实现自动化测试和验证</li>
<li><strong>快速回滚</strong>: 支持快速故障回滚机制</li>
</ul>
<h3 id="4-性能优化建议"><a class="header" href="#4-性能优化建议">4. 性能优化建议</a></h3>
<h4 id="服务优化"><a class="header" href="#服务优化">服务优化</a></h4>
<ul>
<li><strong>缓存策略</strong>: 合理使用缓存减少数据库访问</li>
<li><strong>异步处理</strong>: 使用消息队列处理异步任务</li>
<li><strong>连接池</strong>: 使用数据库和HTTP连接池</li>
<li><strong>资源限制</strong>: 设置合理的CPU和内存限制</li>
</ul>
<h4 id="网络优化"><a class="header" href="#网络优化">网络优化</a></h4>
<ul>
<li><strong>CDN加速</strong>: 使用CDN加速静态资源</li>
<li><strong>负载均衡</strong>: 实现多级负载均衡</li>
<li><strong>网络隔离</strong>: 网络流量隔离和安全隔离</li>
<li><strong>压缩传输</strong>: 启用GZIP等压缩传输</li>
</ul>
<h2 id="故障排除-4"><a class="header" href="#故障排除-4">故障排除</a></h2>
<h3 id="1-常见问题"><a class="header" href="#1-常见问题">1. 常见问题</a></h3>
<h4 id="服务启动失败"><a class="header" href="#服务启动失败">服务启动失败</a></h4>
<pre><code class="language-bash"># 检查服务日志
kubectl logs -f service/user-service -n microservices

# 检查资源使用
kubectl top pods -n microservices

# 检查服务状态
kubectl get pods -n microservices -l app=user-service
</code></pre>
<h4 id="数据库连接问题"><a class="header" href="#数据库连接问题">数据库连接问题</a></h4>
<pre><code class="language-bash"># 检查数据库服务状态
kubectl get deployment -n microservices

# 检查数据库连接
kubectl exec -it deployment/postgres-primary -n microservices -- psql -U postgres

# 检查网络连通性
kubectl exec -it deployment/user-service -n microservices -- curl postgres-primary:5432
</code></pre>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>本微服务系统示例展示了如何使用 Sys-Operator 构建复杂的微服务平台。通过模块化的设计和标准化的配置管理，实现了：</p>
<h3 id="运维价值"><a class="header" href="#运维价值">运维价值</a></h3>
<ul>
<li><strong>自动化</strong>: 自动化的部署和扩缩容</li>
</ul>
<p>通过遵循最佳实践和本示例的设计模式，可以构建出稳定可靠、易于维护的微服务平台，为业务发展提供强有力的技术支撑。</p>
<hr />
<p><em>更多详情请参考相关配置文档和运维手册。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sys-operator-目录结构"><a class="header" href="#sys-operator-目录结构">Sys-Operator 目录结构</a></h1>
<h2 id="概述-7"><a class="header" href="#概述-7">概述</a></h2>
<p>本文档详细说明了 Sys-Operator 的目录结构，帮助你理解系统组织和文件规范。</p>
<h2 id="完整的目录结构"><a class="header" href="#完整的目录结构">完整的目录结构</a></h2>
<pre><code>system_name/
├── _gal/                              # 项目配置目录
│   ├── adm.gxl                       # 系统管理配置
│   ├── work.gxl                      # 工作流环境配置
│   └── project.toml                  # 项目元数据配置
├── sys/                              # 系统定义目录
│   ├── sys_model.yml                 # 系统模型定义
│   ├── mod_list.yml                  # 模块列表定义
│   ├── vars.yml                      # 系统变量定义
│   ├── mods/                         # 模块本地化副本
│   │   ├── module1_name/
│   │   │   └── arm-mac14-host/       # 特定平台配置
│   │   │       ├── spec/             # 规范文件
│   │   │       ├── local/            # 本地化配置
│   │   │       ├── values/           # 值文件
│   │   │       ├── vars.yml          # 模块变量
│   │   │       ├── setting.yml       # 本地化设置
│   │   │       └── workflows/        # 模块工作流
│   │   └── module2_name/
│   │       └── x86-ubt22-k8s/        # 不同平台配置
│   │           └── [相同结构]
│   └── workflows/                    # 系统工作流定义
│       └── operators.gxl             # 系统操作符工作流
├── sys-prj.yml                       # 系统项目配置
├── version.txt                       # 系统版本信息
├── .gitignore                        # Git 忽略文件
└── test_res/                         # 测试资源目录
</code></pre>
<h2 id="目录说明"><a class="header" href="#目录说明">目录说明</a></h2>
<h3 id="_gal---项目配置目录"><a class="header" href="#_gal---项目配置目录"><code>_gal/</code> - 项目配置目录</a></h3>
<p>存储 Galaxy 项目的配置文件，包括版本管理、工作流定义和项目元数据。</p>
<p><strong>关键文件：</strong></p>
<ul>
<li><strong><code>adm.gxl</code></strong>: 系统管理配置，定义版本管理和发布流程</li>
<li><strong><code>work.gxl</code></strong>: 工作流环境配置，定义执行环境和参数</li>
<li><strong><code>project.toml</code></strong>: 项目元数据配置，包含项目基本信息</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>集中管理项目级别的配置</li>
<li>提供版本控制和发布管理</li>
<li>定义多环境执行配置</li>
</ul>
<h3 id="sys---系统定义目录"><a class="header" href="#sys---系统定义目录"><code>sys/</code> - 系统定义目录</a></h3>
<p>包含系统的核心定义文件和模块的本地化副本，是 Sys-Operator 的核心目录。</p>
<p><strong>关键文件：</strong></p>
<ul>
<li><strong><code>sys_model.yml</code></strong>: 系统模型定义，包含系统基本信息和目标环境</li>
<li><strong><code>mod_list.yml</code></strong>: 模块列表定义，包含系统包含的所有模块配置</li>
<li><strong><code>vars.yml</code></strong>: 系统变量定义，定义环境变量和配置参数</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>定义系统的基础架构</li>
<li>管理模块组合和依赖</li>
<li>配置系统级变量和参数</li>
</ul>
<h3 id="mods---模块本地化副本"><a class="header" href="#mods---模块本地化副本"><code>mods/</code> - 模块本地化副本</a></h3>
<p>存储系统中包含的各个模块的本地化配置和文件，这些是从模块源地址复制或下载而来的。</p>
<p><strong>子目录结构：</strong></p>
<pre><code>mods/
├── module_name/
│   └── platform_model/               # 平台特定配置
│       ├── spec/                    # 规范文件
│       ├── local/                   # 本地化配置
│       ├── values/                  # 值文件
│       ├── vars.yml                 # 模块变量
│       ├── setting.yml              # 本地化设置
│       └── workflows/               # 模块工作流
</code></pre>
<p><strong>平台命名规范：</strong></p>
<ul>
<li><code>arm-mac14-host</code>: Apple M1/M2 芯片，macOS 系统，Host 模式</li>
<li><code>x86-ubt22-host</code>: Intel/AMD x86，Ubuntu 22.04，Host 模式</li>
<li><code>x86-ubt22-k8s</code>: Intel/AMD x86，Ubuntu 22.04，Kubernetes 模式</li>
</ul>
<p><strong>作用：</strong></p>
<ul>
<li>存储模块的本地化配置</li>
<li>支持多平台部署</li>
<li>提供模块的定制化配置</li>
</ul>
<h3 id="workflows---系统工作流目录"><a class="header" href="#workflows---系统工作流目录"><code>workflows/</code> - 系统工作流目录</a></h3>
<p>包含系统级别的操作流程定义，使用 GXL 语言编写。</p>
<p><strong>关键文件：</strong></p>
<ul>
<li><strong><code>operators.gxl</code></strong>: 系统操作符工作流，定义系统的生命周期管理</li>
</ul>
<p><strong>工作流类型：</strong></p>
<ul>
<li><strong><code>init</code></strong>: 系统初始化</li>
<li><strong><code>update</code></strong>: 系统更新</li>
<li><strong><code>localize</code></strong>: 系统本地化</li>
<li><strong><code>install</code></strong>: 系统安装</li>
<li><strong><code>start</code></strong>: 系统启动</li>
<li><strong><code>stop</code></strong>: 系统停止</li>
<li><strong><code>status</code></strong>: 系统状态检查</li>
</ul>
<h3 id="其他重要文件"><a class="header" href="#其他重要文件">其他重要文件</a></h3>
<h4 id="sys-prjyml---系统项目配置"><a class="header" href="#sys-prjyml---系统项目配置"><code>sys-prj.yml</code> - 系统项目配置</a></h4>
<p>定义系统项目的完整配置，包括：</p>
<ul>
<li>测试环境配置</li>
<li>构建配置</li>
<li>发布配置</li>
<li>质量检查</li>
<li>安全配置</li>
<li>监控配置</li>
</ul>
<h4 id="versiontxt---系统版本信息"><a class="header" href="#versiontxt---系统版本信息"><code>version.txt</code> - 系统版本信息</a></h4>
<p>简单的文本文件，包含系统版本号：</p>
<pre><code>1.0.0
</code></pre>
<h2 id="文件组织原则"><a class="header" href="#文件组织原则">文件组织原则</a></h2>
<h3 id="1-按功能分类"><a class="header" href="#1-按功能分类">1. 按功能分类</a></h3>
<ul>
<li><strong>配置文件</strong>: 存储在项目根目录和 <code>_gal/</code> 目录</li>
<li><strong>系统定义</strong>: 存储在 <code>sys/</code> 目录</li>
<li><strong>模块文件</strong>: 存储在 <code>sys/mods/</code> 目录</li>
<li><strong>工作流文件</strong>: 存储在 <code>sys/workflows/</code> 目录</li>
<li><strong>测试资源</strong>: 存储在 <code>test_res/</code> 目录</li>
</ul>
<h3 id="3-层次结构"><a class="header" href="#3-层次结构">3. 层次结构</a></h3>
<ul>
<li><strong>项目级</strong>: 系统整体配置和元数据</li>
<li><strong>系统级</strong>: 系统定义和配置</li>
<li><strong>模块级</strong>: 模块具体配置和文件</li>
<li><strong>平台级</strong>: 特定平台的配置</li>
</ul>
<h2 id="最佳实践-6"><a class="header" href="#最佳实践-6">最佳实践</a></h2>
<h3 id="1-目录创建"><a class="header" href="#1-目录创建">1. 目录创建</a></h3>
<p>使用 <code>gsys new </code> 命令创建标准化的目录结构：</p>
<h3 id="2-目录维护"><a class="header" href="#2-目录维护">2. 目录维护</a></h3>
<ul>
<li>保持目录结构的标准化</li>
<li>遵循命名规范</li>
<li>定期清理无用文件</li>
<li>保持 .gitignore 文件的更新</li>
</ul>
<h3 id="3-文件组织"><a class="header" href="#3-文件组织">3. 文件组织</a></h3>
<ul>
<li>相关文件放在同一目录下</li>
<li>避免文件重复</li>
<li>使用合适的文件名</li>
<li>保持文件的版本控制</li>
</ul>
<h3 id="4-平台管理"><a class="header" href="#4-平台管理">4. 平台管理</a></h3>
<ul>
<li>为每个支持的创建相应平台目录</li>
<li>保持平台间配置的一致性</li>
<li>明确标记平台特定的配置</li>
</ul>
<h2 id="常见问题-5"><a class="header" href="#常见问题-5">常见问题</a></h2>
<h3 id="1-目录结构混乱"><a class="header" href="#1-目录结构混乱">1. 目录结构混乱</a></h3>
<p><strong>问题</strong>: 目录结构不符合规范，文件分散
<strong>解决方案</strong>:</p>
<pre><code class="language-bash"># 重新生成标准结构
gsys init --force
# 手动整理现有文件
</code></pre>
<h3 id="2-平台配置冲突"><a class="header" href="#2-平台配置冲突">2. 平台配置冲突</a></h3>
<p><strong>问题</strong>: 不同平台间配置有冲突
<strong>解决方案</strong>: 使用条件变量和平台特定的配置文件</p>
<h3 id="3-文件重复"><a class="header" href="#3-文件重复">3. 文件重复</a></h3>
<p><strong>问题</strong>: 相同功能在多个文件中重复定义
<strong>解决方案</strong>: 使用继承和引用机制，避免重复定义</p>
<h3 id="4-版本控制问题"><a class="header" href="#4-版本控制问题">4. 版本控制问题</a></h3>
<p><strong>问题</strong>: 敏感信息被提交到版本控制
<strong>解决方案</strong>: 更新 .gitignore 文件，使用环境变量管理敏感信息</p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>Sys-Operator 的目录结构设计遵循了模块化、可维护性、可扩展性的原则。通过标准化的目录结构，可以有效地组织系统配置，管理模块依赖，并支持多平台部署。理解和遵循这个目录结构对于使用 Sys-Operator 至关重要。</p>
<hr />
<p><em>更多详情请参考 <a href="operator/sys/structure/./file-organization.html">文件组织方式</a> 和 <a href="operator/sys/structure/./naming-conventions.html">命名规范</a>。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件组织方式"><a class="header" href="#文件组织方式">文件组织方式</a></h1>
<h2 id="概述-8"><a class="header" href="#概述-8">概述</a></h2>
<p>本文档详细说明 Sys-Operator 中的文件组织方式，包括配置文件的结构、模块文件的存储、工作流文件的编排等，帮助你理解如何有效地组织和管理系统文件。</p>
<h2 id="配置文件组织"><a class="header" href="#配置文件组织">配置文件组织</a></h2>
<h3 id="1-系统级配置文件"><a class="header" href="#1-系统级配置文件">1. 系统级配置文件</a></h3>
<p>系统级配置文件存储在 <code>sys/</code> 目录下，定义整个系统的基础架构和配置。</p>
<h4 id="sys_modelyml---系统模型定义"><a class="header" href="#sys_modelyml---系统模型定义"><code>sys_model.yml</code> - 系统模型定义</a></h4>
<p><strong>文件作用</strong>: 定义系统的基本信息和目标运行环境</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础系统定义
name: system_name                    # 系统名称（必需）
model: arm-mac14-host               # 目标平台模型（必需）
vender: "Galaxy-Ops"                # 厂商信息（可选）

# 扩展元数据
metadata:
  description: "系统描述"            # 系统描述
  version: "1.0.0"                  # 系统版本
  tags: [production, web]            # 系统标签
  authors: ["dev-team@example.com"] # 作者信息
  maintainers: ["ops-team@example.com"] # 维护者信息
  documentation: "docs/README.md"   # 文档路径
  homepage: "https://github.com/..." # 项目主页
  repository: "https://github.com/..." # 代码仓库
</code></pre>
<p><strong>命名规范</strong>:</p>
<ul>
<li>文件名必须为 <code>sys_model.yml</code></li>
<li>系统名称必须唯一且有意义</li>
<li>模型名称遵循 <code>arch-os-spc</code> 格式</li>
<li>版本号遵循语义化版本规范</li>
</ul>
<h4 id="mod_listyml---模块列表定义"><a class="header" href="#mod_listyml---模块列表定义"><code>mod_list.yml</code> - 模块列表定义</a></h4>
<p><strong>文件作用</strong>: 定义系统包含的所有模块及其配置</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础模块列表
- name: module_name                     # 模块名称（必需）
  addr:                                  # 模块地址（必需）
    repo: "https://github.com/user/repo" # Git 仓库（可选）
    tag: "v1.0.0"                        # 标签（可选）
    branch: "main"                       # 分支（可选）
    path: "./local/path"                 # 本地路径（可选）
  model: arm-mac14-host                 # 目标平台模型（必需）
  enable: true                           # 是否启用（可选，默认为 true）

# 高级模块配置
- name: advanced_module
  addr:
    repo: "https://github.com/user/module"
    tag: "v2.0.0"
  model: x86-ubt22-k8s
  enable: true
  priority: 100                         # 启动优先级（可选）
  depends_on: ["base_module"]           # 依赖关系（可选）
  condition: "${ENV:development}" == "production" # 启用条件（可选）
  setting:                              # 模块特定设置（可选）
    src: "${GXL_PRJ_ROOT}/sys/setting/module"
    dst: "${GXL_PRJ_ROOT}/sys/mods/module/local/"
  vars:                                 # 模块变量覆盖（可选）
    - name: VAR_NAME
      value: "custom_value"
</code></pre>
<p><strong>配置验证</strong>:</p>
<ul>
<li>模块名称不能重复</li>
<li>模块地址必须有效</li>
<li>模型必须存在</li>
<li>依赖关系不能形成循环</li>
</ul>
<h4 id="varsyml---系统变量定义"><a class="header" href="#varsyml---系统变量定义"><code>vars.yml</code> - 系统变量定义</a></h4>
<p><strong>文件作用</strong>: 定义系统级别的环境变量和配置参数</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础变量
vars:
- name: VARIABLE_NAME             # 变量名（必需）
  value: "default_value"          # 默认值（必需）
  desp: "变量描述"               # 描述（可选）

# 类型化变量
- name: INT_VAR
  type: integer                  # 数据类型（可选）
  min: 1                         # 最小值（可选）
  max: 100                       # 最大值（可选）
  value: 10

- name: BOOL_VAR
  type: boolean
  value: true

- name: ENUM_VAR
  type: enum                     # 枚举类型
  values: [opt1, opt2, opt3]     # 可选值（必需）
  value: opt1

- name: REGEX_VAR
  type: string
  pattern: "^[a-zA-Z]+$"         # 正则模式（必需）
  value: "valid_string"

# 分组变量
vars:
# 网络配置
- name: HTTP_PORT
  group: network
  value: 80

- name: HTTPS_PORT
  group: network
  value: 443

# 数据库配置
- name: DB_HOST
  group: database
  value: "localhost"

- name: DB_PORT
  group: database
  type: integer
  min: 1
  max: 65535
  value: 5432

# 环境变量替换
- name: CONFIG_PATH
  value: "${CONFIG_PATH:/etc/app/config}"

- name: DEBUG_MODE
  value: "${DEBUG_MODE:false}"

# 条件变量
- name: FEATURE_FLAG
  value: "${FEATURE_FLAG:default}"
</code></pre>
<h3 id="2-项目级配置文件"><a class="header" href="#2-项目级配置文件">2. 项目级配置文件</a></h3>
<p>项目级配置文件存储在 <code>_gal/</code> 目录下，定义项目级别的管理配置。</p>
<h4 id="_galadmgxl---系统管理配置"><a class="header" href="#_galadmgxl---系统管理配置"><code>_gal/adm.gxl</code> - 系统管理配置</a></h4>
<p><strong>文件作用</strong>: 定义系统的版本管理和发布配置</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-gxl">// 引入版本管理模块
extern mod ver,git,ver_adm {
    git = "https://github.com/galaxy-operators/cfm-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 环境定义
mod envs {
    env default {
        PKG_NAME = "your_system";        // 系统包名
        VERSION = "1.0.0";              // 系统版本
        MAINTAINER = "devops@example.com";
        DESCRIPTION = "System description";
    }

    env production {
        PKG_NAME = "production-system";
        VERSION = "1.0.0";
        MAINTAINER = "prod-team@example.com";
    }
}

// 主模块继承版本管理功能
mod main : ver_adm {
    // 版本信息任务
    #[task(name="version")]
    flow version {
        gx.echo("System version: ${VERSION}");
        gx.echo("Package name: ${PKG_NAME}");
        gx.echo("Maintainer: ${MAINTAINER}");
    }

    // 发布任务（可选）
    #[task(name="publish")]
    flow publish {
        gx.echo("Publishing system to registry...");
        // 发布逻辑
    }
}
</code></pre>
<h4 id="_galworkgxl---工作流环境配置"><a class="header" href="#_galworkgxl---工作流环境配置"><code>_gal/work.gxl</code> - 工作流环境配置</a></h4>
<p><strong>文件作用</strong>: 定义系统的工作流环境和执行配置</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-gxl">// 引入操作符和版本管理模块
extern mod operators { path = "./sys/workflows"; }
extern mod ver,git {
    git = "https://github.com/galaxy-operators/cfm-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 环境定义
mod envs {
    // 默认环境
    env default : _common {
        FORCE_FLAG = "";                // 强制标志
        LOG_LEVEL = "";                 // 日志级别
        SYS_BIN = "gsys";              // 系统管理器
        MOD_BIN = "gmod";              // 模块管理器
        SYS = "sys";                    // 系统标识
        MODULE_ENV = "default";         // 模块环境
    }

    // 强制执行环境
    env force {
        FORCE_FLAG = "-f 3";
        LOG_LEVEL = "--log debug";
    }

    // 生产环境
    env production {
        FORCE_FLAG = "-f 2";
        LOG_LEVEL = "--log info";
        MODULE_ENV = "production";
    }

    // 开发环境
    env development {
        FORCE_FLAG = "";
        LOG_LEVEL = "--log debug";
        MODULE_ENV = "development";
    }

    // 通用配置
    env _common {
        BUILD_PATH = "${GXL_PRJ_ROOT}/build";    // 构建路径
        DEPLOY_PATH = "${GXL_PRJ_ROOT}/deploy";   // 部署路径
    }
}

// 主模块继承操作符功能
mod main : operators {
    BUILD_PATH = "${GXL_PRJ_ROOT}/build";

    // 自动加载入口
    #[auto_load(entry)]
    flow ver.use | @_into_main {
        ENV_SYS_MODEL = ${DEFINE.MODEL};          // 设置系统模型
        ENV_PKG_NAME = ${DEFINE.NAME};             // 设置包名
    }

    // 主配置任务
    #[task(name="main conf")]
    flow conf {
        gx.echo("=== 开始系统配置 ===");

        // 更新系统配置
        gx.cmd ("${ENV_SYS_BIN} update ${ENV_LOG_LEVEL} ${ENV_FORCE_FLAG}");

        // 本地化系统配置
        gx.cmd ("${ENV_SYS_BIN} localize ${ENV_LOG_LEVEL}");

        gx.echo("=== 系统配置完成 ===");
    }
}
</code></pre>
<h3 id="3-模块文件组织"><a class="header" href="#3-模块文件组织">3. 模块文件组织</a></h3>
<p>模块文件存储在 <code>sys/mods/</code> 目录下，每个模块有自己的本地化副本。</p>
<h4 id="模块目录结构"><a class="header" href="#模块目录结构">模块目录结构</a></h4>
<pre><code>sys/mods/
├── module_name/
│   └── platform_model/
│       ├── spec/                    # 规范文件
│       │   ├── module_spec.yml      # 模块规范
│       │   └── interfaces.yml       # 接口定义
│       ├── local/                   # 本地化配置
│       │   ├── config.yml           # 本地配置
│       │   ├── templates/            # 模板文件
│       │   └── scripts/             # 脚本文件
│       ├── values/                  # 值文件
│       │   ├── production.yml       # 生产环境值
│       │   ├── staging.yml          # 测试环境值
│       │   └── development.yml      # 开发环境值
│       ├── vars.yml                 # 模块变量
│       ├── setting.yml              # 本地化设置
│       └── workflows/               # 模块工作流
│           ├── install.gxl          # 安装工作流
│           ├── configure.gxl        # 配置工作流
│           └── start.gxl             # 启动工作流
</code></pre>
<h4 id="模块配置文件"><a class="header" href="#模块配置文件">模块配置文件</a></h4>
<p><strong><code>vars.yml</code> - 模块变量</strong>:</p>
<pre><code class="language-yaml"># 模块特定变量
vars:
- name: MODULE_VERSION
  value: "1.0.0"
  description: "模块版本"

- name: MODULE_TYPE
  value: "service"
  description: "模块类型"

- name: MODULE_PORT
  type: integer
  min: 1
  max: 65535
  value: 8080
  description: "服务端口"

# 继承系统变量
vars:
- name: GLOBAL_CONFIG_PATH
  value: "${GLOBAL_CONFIG_PATH}"
  description: "全局配置路径"
</code></pre>
<p><strong><code>setting.yml</code> - 本地化设置</strong>:</p>
<pre><code class="language-yaml"># 本地化设置
setting:
  # 源配置路径
  src:
    - "${GXL_PRJ_ROOT}/sys/setting/module/*"
    - "${GXL_PRJ_ROOT}/common/settings/*"
  
  # 目标路径
  dst: "${GXL_PRJ_ROOT}/sys/mods/module/local/"
  
  # 文件映射
  mapping:
    "config.template": "config.yml"
    "env.template": "env.yml"
  
  # 过滤器
  filters:
    - "*.yml"          # 只处理 YAML 文件
    - exclude: "*.tmp" # 排除临时文件
</code></pre>
<h4 id="模块工作流文件"><a class="header" href="#模块工作流文件">模块工作流文件</a></h4>
<p><strong><code>workflows/install.gxl</code> - 安装工作流</strong>:</p>
<pre><code class="language-gxl">// 模块安装工作流
mod install {
    // 安装任务
    #[task(name="module_install")]
    flow install {
        gx.echo("=== 开始模块安装 ===");
        gx.echo("模块名称: ${MODULE.NAME}");
        gx.echo("模块版本: ${MODULE.VERSION}");

        // 预检查
        gx.echo("1. 执行预检查...");
        gx.pre_check();

        // 依赖安装
        gx.echo("2. 安装依赖...");
        gx.install_dependencies();

        // 配置文件
        gx.echo("3. 配置文件...");
        gx.configure();

        // 验证安装
        gx.echo("4. 验证安装...");
        gx.validate();

        gx.echo("=== 模块安装完成 ===");
    }
}
</code></pre>
<h3 id="4-工作流文件组织"><a class="header" href="#4-工作流文件组织">4. 工作流文件组织</a></h3>
<p>系统工作流文件存储在 <code>sys/workflows/</code> 目录下。</p>
<h4 id="operatorsgxl---系统操作符工作流"><a class="header" href="#operatorsgxl---系统操作符工作流"><code>operators.gxl</code> - 系统操作符工作流</a></h4>
<p><strong>文件作用</strong>: 定义系统级别的操作流程</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-gxl">// 引入系统操作模块
extern mod sys_ops {
    git = "https://github.com/galaxy-operators/ops-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 系统操作符模块
mod operators : sys_ops {
    // 自动加载入口
    #[auto_load(entry)]
    flow __into {
        // 加载系统配置
        gx.read_file(
            file : "sys/sys_model.yml",
            name : "SYSTEM_DEFINE"
        );

        gx.read_file(
            file : "sys/mod_list.yml",
            name : "MODULE_LIST"
        );

        gx.read_file(
            file : "sys/vars.yml",
            name : "SYSTEM_VARS"
        );
    }

    // 系统初始化任务
    #[task(name="gsys@init")]
    flow init {
        gx.echo("=== 开始系统初始化 ===");
        gx.echo("系统名称: ${SYSTEM_DEFINE.NAME}");
        gx.echo("目标平台: ${SYSTEM_DEFINE.MODEL}");

        // 检查系统环境
        gx.echo("1. 检查系统环境...");
        gx.check_environment();

        // 初始化系统目录
        gx.echo("2. 初始化系统目录...");
        gx.cmd("mkdir -p sys/mods");
        gx.cmd("mkdir -p sys/workflows");

        // 初始化各个模块
        gx.echo("3. 初始化系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("初始化模块: ${MODULE.NAME}");
                gx.init_module(${MODULE});
            }
        }

        gx.echo("=== 系统初始化完成 ===");
    }

    // 系统更新任务
    #[task(name="gsys@update")]
    flow update {
        gx.echo("=== 开始系统更新 ===");

        // 更新系统定义
        gx.echo("1. 更新系统定义...");
        gx.update_system_definition();

        // 更新模块列表
        gx.echo("2. 更新模块列表...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("更新模块: ${MODULE.NAME}");
                gx.update_module(${MODULE});
            }
        }

        // 验证系统完整性
        gx.echo("3. 验证系统完整性...");
        gx.validate_system_integrity();

        gx.echo("=== 系统更新完成 ===");
    }

    // 系统本地化任务
    #[task(name="gsys@localize")]
    flow localize {
        gx.echo("=== 开始系统本地化 ===");

        // 本地化系统配置
        gx.echo("1. 本地化系统配置...");
        gx.localize_system_config();

        // 本地化各个模块
        gx.echo("2. 本地化系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("本地化模块: ${MODULE.NAME}");
                gx.localize_module(${MODULE});
            }
        }

        // 生成本地化报告
        gx.echo("3. 生成本地化报告...");
        gx.generate_localization_report();

        gx.echo("=== 系统本地化完成 ===");
    }
}
</code></pre>
<h3 id="5-项目配置文件"><a class="header" href="#5-项目配置文件">5. 项目配置文件</a></h3>
<p><code>sys-prj.yml</code> - 系统项目配置</p>
<p><strong>文件作用</strong>: 定义系统项目的完整配置</p>
<p><strong>配置结构</strong>:</p>
<pre><code class="language-yaml"># 基础项目配置
name: "Production Web System"               # 系统项目名称
version: "1.0.0"                           # 项目版本
description: "Production web application system with monitoring"

# 测试环境配置
test_envs:
  dep_root: "./test_deps"                   # 依赖根目录
  deps:
    - addr:
        repo: https://github.com/galaxy-operators/bitnami-common.git
      local: ./test_res/bit-common          # 本地路径
      rename: bit-common                    # 重命名
      enable: true                          # 是否启用

    - addr:
        path: ./test_deps/test-data         # 本地路径依赖
      local: test-data
      enable: true

# 构建配置
build:
  # 构建目标
  targets:
    - arm-mac14-host
    - x86-ubt22-host
    - x86-ubt22-k8s

  # 构建选项
  options:
    parallel: true                          # 并行构建
    cache_enabled: true                     # 启用缓存
    cache_dir: "./build/cache"             # 缓存目录

  # 构建输出
  output:
    format: "tar.gz"                       # 输出格式
    destination: "./build/dist"            # 输出目录

# 发布配置
publish:
  repo: "https://github.com/galaxy-operators/systems"  # 发布仓库
  branch: "main"                           # 发布分支
  tag_format: "v${version}"                # 标签格式

  # 发布环境
  environments:
    staging:
      repo: "https://github.com/galaxy-operators/systems-staging"
      branch: "staging"
    production:
      repo: "https://github.com/galaxy-operators/systems-production"
      branch: "main"
      auto_tag: true                        # 自动打标签

# 质量检查
quality:
  # 代码检查
  lint:
    enabled: true
    rules:
      - no-hardcoded-secrets
      - consistent-naming
      - security-checks

  # 测试配置
  test:
    enabled: true
    types:
      - unit
      - integration
      - e2e
    coverage_threshold: 80                 # 覆盖率阈值

# 安全配置
security:
  # 敏感信息扫描
  secret_scanning:
    enabled: true
    patterns:
      - "API_KEY"
      - "PASSWORD"
      - "TOKEN"
      - "SECRET"

  # 许可证检查
  license_check:
    enabled: true
    allowed:
      - "MIT"
      - "Apache-2.0"
      - "BSD-3-Clause"
    forbidden:
      - "GPL-3.0"
      - "AGPL-3.0"

# 监控配置
monitoring:
  # 构建监控
  build:
    enabled: true
    metrics:
      - build_duration
      - build_success_rate
      - artifact_size

  # 运行时监控
  runtime:
    enabled: true
    endpoints:
      - health
      - metrics
      - logging
</code></pre>
<h2 id="文件验证与组织"><a class="header" href="#文件验证与组织">文件验证与组织</a></h2>
<h3 id="1-配置文件验证"><a class="header" href="#1-配置文件验证">1. 配置文件验证</a></h3>
<p><strong>YAML 文件验证</strong>:</p>
<pre><code class="language-bash"># 验证 sys_model.yml
yq eval . sys/sys_model.yml &gt; /dev/null

# 验证 mod_list.yml
yq eval . sys/mod_list.yml &gt; /dev/null

# 验证 vars.yml
yq eval . sys/vars.yml &gt; /dev/null

# 验证 sys-prj.yml
yq eval . sys-prj.yml &gt; /dev/null
</code></pre>
<p><strong>GXL 文件验证</strong>:</p>
<pre><code class="language-bash"># 验证语法
gxl-validate sys/workflows/operators.gxl
gxl-validate _gal/adm.gxl
gxl-validate _gal/work.gxl
</code></pre>
<h3 id="2-文件组织检查"><a class="header" href="#2-文件组织检查">2. 文件组织检查</a></h3>
<p><strong>目录结构检查</strong>:</p>
<pre><code class="language-bash"># 检查必需文件
check_required_files() {
    local dir=$1
    local required_files=(
        "sys/sys_model.yml"
        "sys/mod_list.yml"
        "sys/vars.yml"
        "sys/workflows/operators.gxl"
    )
    
    for file in "${required_files[@]}"; do
        if [[ ! -f "$dir/$file" ]]; then
            echo "错误: 缺少必需文件 $file"
            return 1
        fi
    done
    return 0
}
</code></pre>
<p><strong>重复文件检查</strong>:</p>
<pre><code class="language-bash"># 检查重复配置
check_duplicate_config() {
    local dir=$1
    local temp_file=$(mktemp)
    
    # 提取所有配置项
    find "$dir" -name "*.yml" -exec yq eval '.' {} \; &gt; "$temp_file"
    
    # 检查重复项
    sort "$temp_file" | uniq -d &gt; "${temp_file}.duplicates"
    
    if [[ -s "${temp_file}.duplicates" ]]; then
        echo "警告: 发现重复配置项"
        cat "${temp_file}.duplicates"
    fi
    
    rm -f "$temp_file" "${temp_file}.duplicates"
}
</code></pre>
<h2 id="最佳实践-7"><a class="header" href="#最佳实践-7">最佳实践</a></h2>
<h3 id="1-文件组织原则"><a class="header" href="#1-文件组织原则">1. 文件组织原则</a></h3>
<h4 id="分离关注点"><a class="header" href="#分离关注点">分离关注点</a></h4>
<ul>
<li><strong>配置文件</strong>: 纯配置信息，不包含业务逻辑</li>
<li><strong>工作流文件</strong>: 包含操作逻辑，引用配置文件</li>
<li><strong>模块文件</strong>: 平台特定的配置和文件</li>
</ul>
<h4 id="减少重复"><a class="header" href="#减少重复">减少重复</a></h4>
<ul>
<li>使用变量和引用机制</li>
<li>避免硬编码相同配置</li>
<li>使用模板和继承</li>
</ul>
<h4 id="保持一致性"><a class="header" href="#保持一致性">保持一致性</a></h4>
<ul>
<li>遵循命名规范</li>
<li>使用统一的格式和风格</li>
<li>保持目录结构的清晰</li>
</ul>
<h3 id="2-维护策略"><a class="header" href="#2-维护策略">2. 维护策略</a></h3>
<h4 id="版本控制"><a class="header" href="#版本控制">版本控制</a></h4>
<ul>
<li>使用 .gitignore 管理临时文件</li>
<li>使用语义化版本管理</li>
<li>分支管理策略</li>
</ul>
<h4 id="文档更新"><a class="header" href="#文档更新">文档更新</a></h4>
<ul>
<li>配置变更时更新文档</li>
<li>维护文件变更日志</li>
<li>定期审核文件结构</li>
</ul>
<h4 id="自动化"><a class="header" href="#自动化">自动化</a></h4>
<ul>
<li>使用脚本验证文件结构</li>
<li>自动生成配置文件模板</li>
<li>定期备份重要配置</li>
</ul>
<h2 id="故障排除-5"><a class="header" href="#故障排除-5">故障排除</a></h2>
<h3 id="1-配置错误"><a class="header" href="#1-配置错误">1. 配置错误</a></h3>
<p><strong>常见问题</strong>:</p>
<ul>
<li>YAML 语法错误</li>
<li>GXL 语法错误</li>
<li>文件路径错误</li>
<li>模型不存在</li>
</ul>
<p><strong>解决方案</strong>:</p>
<ul>
<li>使用验证工具检查语法</li>
<li>检查文件路径引用</li>
<li>确认模型定义存在</li>
</ul>
<h3 id="2-文件组织问题"><a class="header" href="#2-文件组织问题">2. 文件组织问题</a></h3>
<p><strong>常见问题</strong>:</p>
<ul>
<li>目录结构混乱</li>
<li>文件重复定义</li>
<li>平台配置冲突</li>
<li>版本控制问题</li>
</ul>
<p><strong>解决方案</strong>:</p>
<ul>
<li>重新组织目录结构</li>
<li>消除重复定义</li>
<li>平台配置隔离</li>
<li>完善版本控制</li>
</ul>
<h3 id="3-权限和访问"><a class="header" href="#3-权限和访问">3. 权限和访问</a></h3>
<p><strong>常见问题</strong>:</p>
<ul>
<li>文件权限不足</li>
<li>网络访问限制</li>
<li>路径解析错误</li>
</ul>
<p><strong>解决方案</strong>:</p>
<ul>
<li>设置适当的文件权限</li>
<li>确保网络访问正常</li>
<li>使用绝对路径或相对路径</li>
</ul>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>Sys-Operator 的文件组织方式遵循了模块化、标准化、可维护性的原则。通过合理的文件结构和配置组织，可以有效管理系统配置，提高开发效率，降低维护成本。理解并遵循这些文件组织方式对于有效使用 Sys-Operator 至关重要。</p>
<hr />
<p><em>更多详情请参考 <a href="operator/sys/structure/./directory.html">目录结构</a> 和 <a href="operator/sys/structure/./naming-conventions.html">命名规范</a>。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h1>
<h2 id="概述-9"><a class="header" href="#概述-9">概述</a></h2>
<p>本文档详细说明 Sys-Operator 中的命名规范，包括文件名、变量名、模块名、系统名等的命名约定，帮助你保持命名的一致性和可读性。</p>
<h2 id="命名原则"><a class="header" href="#命名原则">命名原则</a></h2>
<h3 id="1-可读性原则"><a class="header" href="#1-可读性原则">1. 可读性原则</a></h3>
<p><strong>目标</strong>: 命名应该清晰表达其用途，便于理解和维护。</p>
<p><strong>规则</strong>:</p>
<ul>
<li>使用有意义的名称，避免缩写和模糊的词汇</li>
<li>名称应该自解释，减少额外的注释需求</li>
<li>保持名称的简洁性，不过度冗长</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的命名
name: "production_web_system"
name: "user_management_service"
name: "database_connection_pool"

# 不好的命名
name: "prod_sys"         # 缩写不清晰
name: "system_1"         # 无意义
name: "usermgmt_service" # 缩写不规范
</code></pre>
<h3 id="2-一致性原则"><a class="header" href="#2-一致性原则">2. 一致性原则</a></h3>
<p><strong>目标</strong>: 保持整个项目命名风格的一致性。</p>
<p><strong>规则</strong>:</p>
<ul>
<li>统一的命名风格（全小写、驼峰、下划线等）</li>
<li>相同概念使用相同的术语</li>
<li>遵循项目的现有命名约定</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 一致的命名风格
vars:
  - name: database_host           # 下划线分隔
  - name: database_port
  - name: database_name

# 不一致的命名风格
vars:
  - name: databaseHost           # 混合风格
  - name: DB_PORT                # 大写缩写
  - name: databaseName           # 驼峰命名
</code></pre>
<h3 id="3-可扩展性原则"><a class="header" href="#3-可扩展性原则">3. 可扩展性原则</a></h3>
<p><strong>目标</strong>: 命名应该支持项目的扩展和演进。</p>
<p><strong>规则</strong>:</p>
<ul>
<li>避免硬编码的数字和版本</li>
<li>使用通用的术语，便于复用</li>
<li>支持多环境和多部署</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 可扩展的命名
name: "web_application_system"    # 通用的名称
name: "microservice_platform"      # 可扩展的平台名称

# 不可扩展的命名
name: "system_v2_1_production   # 硬编码版本
name: "legacy_app_deprecated     # 硬编码状态
</code></pre>
<h2 id="文件命名规范"><a class="header" href="#文件命名规范">文件命名规范</a></h2>
<h3 id="1-配置文件"><a class="header" href="#1-配置文件">1. 配置文件</a></h3>
<p><strong>YAML 配置文件</strong>:</p>
<pre><code>sys_model.yml           # 系统模型定义（必需）
mod_list.yml            # 模块列表定义（必需）
vars.yml               # 系统变量定义（必需）
admin-config.gxl       # 系统管理配置（推荐）
work-config.gxl        # 工作流环境配置（推荐）
project-config.toml    # 项目配置（推荐）
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>多个单词用下划线分隔</li>
<li>扩展名表示文件格式（.yml, .gxl, .toml）</li>
<li>文件名应该反映文件内容</li>
</ul>
<p><strong>错误示例</strong>:</p>
<pre><code>SysModel.yaml          # 大写字母和错误扩展名
model_list.yml         # 缩写不清晰
config.yml             # 过于通用
system_configs.yml     # 复数形式不必要
</code></pre>
<h3 id="2-工作流文件"><a class="header" href="#2-工作流文件">2. 工作流文件</a></h3>
<p><strong>GXL 工作流文件</strong>:</p>
<pre><code>operators.gxl          # 系统操作符工作流（必需）
system-workflows.gxl   # 系统工作流（可选）
module-workflows.gxl   # 模块工作流（可选）
custom-workflows.gxl   # 自定义工作流（可选）
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>工作流文件应该以 <code>-workflows.gxl</code> 结尾</li>
<li>自定义工作流应该有明确的前缀</li>
<li>系统级和模块级工作流应该区分</li>
</ul>
<h3 id="3-模块文件"><a class="header" href="#3-模块文件">3. 模块文件</a></h3>
<p><strong>模块目录名</strong>:</p>
<pre><code>sys/mods/
├── web_server/
├── database_server/
├── cache_manager/
├── message_queue/
├── load_balancer/
└── monitoring_agent/
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>多个单词用下划线分隔</li>
<li>描述性名称，明确模块功能</li>
<li>避免缩写和简写</li>
</ul>
<h3 id="4-平台目录名"><a class="header" href="#4-平台目录名">4. 平台目录名</a></h3>
<p><strong>平台模型目录</strong>:</p>
<pre><code>arm-mac14-host
x86-ubt22-host
x86-ubt22-k8s
x86-centos8-host
arm-linux-k8s
</code></pre>
<p><strong>命名规则</strong>:</p>
<ul>
<li>格式：<code>arch-os-spc</code></li>
<li>架构：<code>arm</code>, <code>x86</code>, <code>amd64</code></li>
<li>操作系统：<code>mac14</code>, <code>ubt22</code>, <code>centos8</code>, <code>linux</code></li>
<li>环境：<code>host</code>, <code>k8s</code>, <code>docker</code></li>
</ul>
<h2 id="变量命名规范"><a class="header" href="#变量命名规范">变量命名规范</a></h2>
<h3 id="1-系统变量"><a class="header" href="#1-系统变量">1. 系统变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用全大写字母</li>
<li>单词间用下划线分隔</li>
<li>前缀标识变量类型</li>
<li>包含适当的命名空间</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 系统配置
- name: SYSTEM_NAME
  value: "production_system"

- name: SYSTEM_VERSION
  value: "1.0.0"

- name: SYSTEM_ENVIRONMENT
  value: "production"

# 网络配置
- name: NETWORK_HOST
  value: "localhost"

- name: NETWORK_PORT
  value: 8080

- name: NETWORK_PROTOCOL
  value: "https"

# 数据库配置
- name: DATABASE_HOST
  value: "postgres-primary"

- name: DATABASE_PORT
  value: 5432

- name: DATABASE_NAME
  value: "production_db"

# 安全配置
- name: SECURITY_ENCRYPTION_KEY
  value: "generated_key_here"

- name: SECURITY_SSL_CERT_PATH
  value: "/etc/ssl/certs/server.crt"

# 性能配置
- name: PERFORMANCE_MAX_THREADS
  value: 100

- name: PERFORMANCE_MEMORY_LIMIT
  value: "4GB"
</code></pre>
<h3 id="2-模块变量"><a class="header" href="#2-模块变量">2. 模块变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>模块名作为前缀</li>
<li>跟随具体的配置项</li>
<li>使用统一的术语</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># web_server 模块变量
vars:
  - name: WEB_SERVER_PORT
    value: 80

  - name: WEB_SERVER_SSL_PORT
    value: 443

  - name: WEB_SERVER_WORKERS
    value: 4

  - name: WEB_SERVER_KEEP_ALIVE
    value: "75s"

# database_server 模块变量
vars:
  - name: DATABASE_SERVER_HOST
    value: "db-primary"

  - name: DATABASE_SERVER_PORT
    value: 5432

  - name: DATABASE_SERVER_MAX_CONNECTIONS
    value: 100

  - name: DATABASE_SERVER_TIMEOUT
    value: "30s"
</code></pre>
<h3 id="3-环境变量"><a class="header" href="#3-环境变量">3. 环境变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>支持环境变量替换</li>
<li>使用默认值语法</li>
<li>变量名与配置名对应</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 环境变量替换
vars:
  - name: DATABASE_HOST
    value: "${DATABASE_HOST:localhost}"

  - name: DATABASE_PORT
    value: "${DATABASE_PORT:5432}"

  - name: ENABLE_DEBUG
    value: "${ENABLE_DEBUG:false}"

  - name: LOG_LEVEL
    value: "${LOG_LEVEL:info}"

  - name: CONFIG_PATH
    value: "${CONFIG_PATH:/etc/app/config}"

  - name: API_KEY
    value: "${API_KEY}"
</code></pre>
<h3 id="4-分组变量"><a class="header" href="#4-分组变量">4. 分组变量</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用 <code>group</code> 字段进行分类</li>
<li>组名与功能相关</li>
<li>组内变量命名保持一致</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 按功能分组的变量
vars:
# 网络配置组
- name: HTTP_PORT
  group: network
  value: 80

- name: HTTPS_PORT
  group: network
  value: 443

- name: DOMAIN_NAME
  group: network
  value: "example.com"

# 数据库配置组
- name: DB_HOST
  group: database
  value: "postgres"

- name: DB_PORT
  group: database
  value: 5432

- name: DB_NAME
  group: database
  value: "app_db"

# 安全配置组
- name: ENABLE_SSL
  group: security
  value: true

- name: SSL_CERT_PATH
  group: security
  value: "/etc/ssl/certs/server.crt"

- name: SSL_KEY_PATH
  group: security
  value: "/etc/ssl/private/server.key"

# 监控配置组
- name: ENABLE_MONITORING
  group: monitoring
  value: true

- name: METRICS_PORT
  group: monitoring
  value: 9090

- name: LOG_LEVEL
  group: monitoring
  value: "info"
</code></pre>
<h2 id="模块命名规范"><a class="header" href="#模块命名规范">模块命名规范</a></h2>
<h3 id="1-模块名"><a class="header" href="#1-模块名">1. 模块名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>描述性名称</li>
<li>避免缩写</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 好的模块名
- name: web_server
- name: database_server
- name: cache_manager
- name: message_queue
- name: load_balancer
- name: monitoring_agent
- name: file_storage
- name: authentication_service

# 不好的模块名
- name: web
- name: db
- name: cache
- name: mq
- name: lb
- name: monitor
- name: storage
- name: auth
</code></pre>
<h3 id="2-模块类型"><a class="header" href="#2-模块类型">2. 模块类型</a></h3>
<p><strong>常用模块类型</strong>:</p>
<pre><code>server      # 服务器服务
client      # 客户端服务
proxy       # 代理服务
gateway     # 网关服务
cache       # 缓存服务
storage     # 存储服务
queue       # 消息队列
monitor     # 监控服务
security    # 安全服务
network     # 网络服务
</code></pre>
<p><strong>命名模式</strong>:</p>
<ul>
<li><code>{function}_{type}</code>: <code>web_server</code>, <code>database_server</code></li>
<li><code>{type}_{service}</code>: <code>cache_redis</code>, <code>queue_rabbitmq</code></li>
<li><code>{service}_{tool}</code>: <code>monitor_grafana</code>, <code>security_consul</code></li>
</ul>
<h2 id="系统命名规范"><a class="header" href="#系统命名规范">系统命名规范</a></h2>
<h3 id="1-系统名"><a class="header" href="#1-系统名">1. 系统名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>描述性名称</li>
<li>包含环境标识（可选）</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 生产环境
name: production_web_system
name: staging_api_gateway
name: development_database_cluster

# 开发环境
name: dev_web_system
name: test_user_service
name: local_message_queue

# 通用环境
name: microservice_platform
name: data_processing_system
name: enterprise_application
</code></pre>
<h3 id="2-系统标识"><a class="header" href="#2-系统标识">2. 系统标识</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>系统名作为基础</li>
<li>添加环境前缀（可选）</li>
<li>添加版本标识（可选）</li>
</ul>
<p><strong>标识格式</strong>:</p>
<pre><code>{environment}_{system_name}_{version}
</code></pre>
<p><strong>示例</strong>:</p>
<pre><code>prod_web_system_v1.0.0
staging_api_gateway_v2.1.0
dev_database_cluster_v0.9.0
</code></pre>
<h2 id="工作流命名规范"><a class="header" href="#工作流命名规范">工作流命名规范</a></h2>
<h3 id="1-任务名"><a class="header" href="#1-任务名">1. 任务名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用动词开头</li>
<li>描述具体操作</li>
<li>动词+名词结构</li>
</ul>
<p><strong>常用动词</strong>:</p>
<pre><code>install     # 安装
start       # 启动
stop        # 停止
restart     # 重启
update      # 更新
configure   # 配置
deploy      # 部署
backup      # 备份
restore     # 恢复
validate    # 验证
check       # 检查
monitor     # 监控
</code></pre>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl"># 好的任务名
#[task(name="install_service")]
#[task(name="start_application")]
#[task(name="stop_database")]
#[task(name="update_config")]
#[task(name="deploy_system")]
#[task(name="validate_environment")]

# 不好的任务名
#[task(name="install")]        # 过于简单
#[task(name="do_start")]        # 冗余
#[task(name="run_installer")]   # 间接
</code></pre>
<h3 id="2-流程名"><a class="header" href="#2-流程名">2. 流程名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用多个单词</li>
<li>描述完整流程</li>
<li>包含系统标识</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl"># 系统操作流程
flow system_installation
flow system_configuration
flow system_deployment
flow system_monitoring

# 模块操作流程
flow module_initialization
flow module_configuration
flow module_deployment
flow module_validation
</code></pre>
<h2 id="gxl-元素命名规范"><a class="header" href="#gxl-元素命名规范">GXL 元素命名规范</a></h2>
<h3 id="1-变量名"><a class="header" href="#1-变量名">1. 变量名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用大写字母</li>
<li>单词间用下划线分隔</li>
<li>描述变量内容</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl">// 系统配置变量
let SYSTEM_NAME = "web_system"
let SYSTEM_MODEL = "arm-mac14-host"
let MODULE_COUNT = 5

// 环境变量
let ENVIRONMENT = "production"
let LOG_LEVEL = "info"
let FORCE_FLAG = ""

// 路径变量
let PROJECT_ROOT = "${GXL_PRJ_ROOT}"
let CONFIG_PATH = "${PROJECT_ROOT}/config"
let DEPLOY_PATH = "${PROJECT_ROOT}/deploy"
</code></pre>
<h3 id="2-函数名"><a class="header" href="#2-函数名">2. 函数名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用动词+名词结构</li>
<li>动词用现在时</li>
<li>描述函数功能</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl">// 检查函数
function check_environment()
function check_dependencies()
function check_health()

// 安装函数
function install_system()
function install_module(module_name)
function install_dependencies()

// 配置函数
function configure_system()
function configure_module(module)
function apply_settings()

// 工具函数
function read_file(file_path)
function write_file(file_path, content)
function validate_config()
</code></pre>
<h3 id="3-标签名"><a class="header" href="#3-标签名">3. 标签名</a></h3>
<p><strong>命名规则</strong>:</p>
<ul>
<li>使用小写字母</li>
<li>单词间用下划线分隔</li>
<li>标签语义明确</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-gxl">// 系统标签
label system_initialized
label system_running
label system_stopped
label system_error

// 模块标签
label module_installed
label module_started
label module_stopped
label module_failed

// 流程标签
label installation_complete
label deployment_successful
label validation_passed
label configuration_applied
</code></pre>
<h2 id="避免的命名模式"><a class="header" href="#避免的命名模式">避免的命名模式</a></h2>
<h3 id="1-不推荐的命名"><a class="header" href="#1-不推荐的命名">1. 不推荐的命名</a></h3>
<p><strong>避免使用</strong>:</p>
<ul>
<li>单字符变量名（a, b, c）</li>
<li>缩写不明确的名称（cfg, tmp, var）</li>
<li>硬编码数字和版本</li>
<li>保留关键字和特殊字符</li>
<li>过于通用的名称</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 不推荐的命名
- name: a                    # 单字符
- name: cfg                  # 缩写不明确
- name: v1                  # 硬编码版本
- name: temp_123             # 临时编号
- name: system               # 过于通用
- name: config               # 过于通用
- name: data                 # 过于通用
</code></pre>
<h3 id="2-特殊字符和保留字"><a class="header" href="#2-特殊字符和保留字">2. 特殊字符和保留字</a></h3>
<p><strong>避免使用的字符</strong>:</p>
<ul>
<li>空格和特殊字符</li>
<li>连字符（-）</li>
<li>斜杠（/）</li>
<li>点号（.）开头或结尾</li>
<li>保留关键字</li>
</ul>
<p><strong>示例</strong>:</p>
<pre><code class="language-yaml"># 错误的命名
- name: web server          # 包含空格
- name: api-gateway        # 使用连字符
- name: config/backup       # 包含斜杠
- name: .hidden            # 以点号开头
- name: system$            # 包含特殊字符
- name: null               # 保留关键字
</code></pre>
<h2 id="命名验证工具"><a class="header" href="#命名验证工具">命名验证工具</a></h2>
<h3 id="1-自动验证脚本"><a class="header" href="#1-自动验证脚本">1. 自动验证脚本</a></h3>
<p><strong>bash 脚本示例</strong>:</p>
<pre><code class="language-bash">#!/bin/bash

# 验证 YAML 配置文件
validate_naming_conventions() {
    local file=$1
    local errors=0
    
    # 检查变量名
    if [[ $file == *"vars.yml" ]]; then
        local invalid_vars=$(yq eval '.vars[] | select(.name | ascii_downcase != .name)' "$file")
        if [[ -n "$invalid_vars" ]]; then
            echo "错误: 变量名必须全小写"
            echo "$invalid_vars"
            errors=$((errors + 1))
        fi
    fi
    
    # 检查模块名
    if [[ $file == *"mod_list.yml" ]]; then
        local invalid_modules=$(yq eval '.[] | select(.name | ascii_downcase != .name)' "$file")
        if [[ -n "$invalid_modules" ]]; then
            echo "错误: 模块名必须全小写"
            echo "$invalid_modules"
            errors=$((errors + 1))
        fi
    fi
    
    return $errors
}

# 验证所有配置文件
for file in sys/*.yml; do
    if [[ -f "$file" ]]; then
        echo "验证文件: $file"
        validate_naming_conventions "$file"
        if [[ $? -eq 0 ]]; then
            echo "✓ 通过验证"
        else
            echo "✗ 验证失败"
        fi
    fi
done
</code></pre>
<h3 id="2-集成验证"><a class="header" href="#2-集成验证">2. 集成验证</a></h3>
<p><strong>Git 钩子示例</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

# 检查提交的文件是否包含配置文件
changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(yml|gxl)$')

if [[ -n "$changed_files" ]]; then
    echo "验证命名规范..."
    
    for file in $changed_files; do
        echo "检查文件: $file"
        
        # 执行命名规范检查
        if ! validate_naming_conventions "$file"; then
            echo "错误: $file 不符合命名规范"
            exit 1
        fi
    done
fi

echo "命名规范验证通过"
</code></pre>
<h2 id="最佳实践-8"><a class="header" href="#最佳实践-8">最佳实践</a></h2>
<h3 id="1-创建命名规范文档"><a class="header" href="#1-创建命名规范文档">1. 创建命名规范文档</a></h3>
<p><strong>内容建议</strong>:</p>
<ul>
<li>项目特定的命名规则</li>
<li>术语表和缩写定义</li>
<li>示例和反例</li>
<li>验证工具使用方法</li>
<li>维护更新策略</li>
</ul>
<h3 id="2-自动化验证"><a class="header" href="#2-自动化验证">2. 自动化验证</a></h3>
<p><strong>工具集成</strong>:</p>
<ul>
<li>CI/CD 流水线集成</li>
<li>代码审查工具集成</li>
<li>文档生成工具集成</li>
<li>开发环境配置集成</li>
</ul>
<h3 id="3-定期审查"><a class="header" href="#3-定期审查">3. 定期审查</a></h3>
<p><strong>审查频率</strong>:</p>
<ul>
<li>新功能开发时</li>
<li>代码审查阶段</li>
<li>版本发布前</li>
<li>定期维护更新</li>
</ul>
<h3 id="4-团队协作"><a class="header" href="#4-团队协作">4. 团队协作</a></h3>
<p><strong>团队实践</strong>:</p>
<ul>
<li>命名规范培训</li>
<li>代码审查重点</li>
<li>示例代码库</li>
<li>常见问题解答</li>
</ul>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<p>良好的命名规范是项目成功的重要因素。Sys-Operator 的命名规范注重可读性、一致性和可扩展性，通过清晰的命名约定可以：</p>
<ul>
<li>提高代码可读性和维护性</li>
<li>减少沟通成本和理解误差</li>
<li>支持项目的长期演进</li>
<li>便于团队协作和代码审查</li>
<li>提供更好的开发体验</li>
</ul>
<p>遵循这些命名规范，并与团队保持一致的命名约定，将有助于建立高质量、可维护的系统配置。</p>
<hr />
<p><em>更多详情请参考 <a href="operator/sys/structure/./directory.html">目录结构</a> 和 <a href="operator/sys/structure/./file-organization.html">文件组织方式</a>。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见问题故障排除"><a class="header" href="#常见问题故障排除">常见问题故障排除</a></h1>
<h2 id="概述-10"><a class="header" href="#概述-10">概述</a></h2>
<p>本文档提供了 Sys-Operator 系统常见问题的故障排除指南，帮助你快速定位和解决系统运行中的各种问题。</p>
<h2 id="系统初始化问题"><a class="header" href="#系统初始化问题">系统初始化问题</a></h2>
<h3 id="1-系统启动失败"><a class="header" href="#1-系统启动失败">1. 系统启动失败</a></h3>
<h4 id="问题现象"><a class="header" href="#问题现象">问题现象</a></h4>
<pre><code class="language-bash">$ gsys start
错误: 系统启动失败 - 依赖服务不可用
</code></pre>
<h4 id="可能原因"><a class="header" href="#可能原因">可能原因</a></h4>
<ul>
<li>数据库连接失败</li>
<li>缓存服务未启动</li>
<li>网络连接问题</li>
<li>配置文件错误</li>
</ul>
<h4 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查服务状态
$ kubectl get pods -n microservices
$ docker ps | grep microservices

# 2. 检查配置文件
$ yq validate sys/sys_model.yml
$ yq validate sys/mod_list.yml
$ yq validate sys/vars.yml

# 3. 检查服务依赖
$ gsys check-dependencies

# 4. 查看详细日志
$ gsys start --log debug

# 5. 重启相关服务
$ kubectl rollout restart deployment/database
</code></pre>
<h3 id="2-模块加载失败"><a class="header" href="#2-模块加载失败">2. 模块加载失败</a></h3>
<h4 id="问题现象-1"><a class="header" href="#问题现象-1">问题现象</a></h4>
<pre><code class="language-bash">$ gsys localize
错误: 模块 user-service 加载失败
错误: 模块地址无效或不可访问
</code></pre>
<h4 id="可能原因-1"><a class="header" href="#可能原因-1">可能原因</a></h4>
<ul>
<li>模块仓库地址错误</li>
<li>网络连接问题</li>
<li>模块版本不兼容</li>
<li>权限不足</li>
</ul>
<h4 id="解决方案-1"><a class="header" href="#解决方案-1">解决方案</a></h4>
<pre><code class="language-bash"># 1. 验证模块地址
$ curl -I https://github.com/user/repo.git

# 2. 检查网络连接
$ ping github.com
$ traceroute github.com

# 3. 尝试不同的模块源
$ gsys localize --module-source git
$ gsys localize --module-source local

# 4. 检查权限
$ ls -la ~/.ssh/
$ ssh -T git@github.com

# 5. 手动下载模块
$ git clone https://github.com/user/repo.git
$ gsys localize --local-path ./repo
</code></pre>
<h2 id="配置管理问题"><a class="header" href="#配置管理问题">配置管理问题</a></h2>
<h3 id="1-配置文件错误"><a class="header" href="#1-配置文件错误">1. 配置文件错误</a></h3>
<h4 id="问题现象-2"><a class="header" href="#问题现象-2">问题现象</a></h4>
<pre><code class="language-bash">$ gsys validate
错误: 配置文件解析失败 - sys/vars.yml: 第15行，期望值
</code></pre>
<h4 id="可能原因-2"><a class="header" href="#可能原因-2">可能原因</a></h4>
<ul>
<li>YAML 语法错误</li>
<li>必需字段缺失</li>
<li>数据类型不匹配</li>
<li>变量引用错误</li>
</ul>
<h4 id="解决方案-2"><a class="header" href="#解决方案-2">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查YAML语法
$ yq eval '.' sys/vars.yml

# 2. 使用语法高亮编辑器检查
# VS Code 或其他编辑器中打开配置文件

# 3. 验证必需字段
$ yq eval '.name' sys/sys_model.yml
$ yq eval '.model' sys/sys_model.yml

# 4. 检查变量引用
$ yq eval '.vars[] | select(.value | contains("${"))' sys/vars.yml

# 5. 逐步验证配置
$ yq eval '.vars[0]' sys/vars.yml
$ yq eval '.vars[1]' sys/vars.yml
</code></pre>
<h3 id="2-配置热重载失败"><a class="header" href="#2-配置热重载失败">2. 配置热重载失败</a></h3>
<h4 id="问题现象-3"><a class="header" href="#问题现象-3">问题现象</a></h4>
<pre><code class="language-bash">$ gsys reload
错误: 配置重载失败 - 配置文件被锁定
</code></pre>
<h4 id="可能原因-3"><a class="header" href="#可能原因-3">可能原因</a></h4>
<ul>
<li>配置文件正在被其他进程使用</li>
<li>权限不足</li>
<li>文件系统错误</li>
<li>服务未启动</li>
</ul>
<h4 id="解决方案-3"><a class="header" href="#解决方案-3">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查文件占用
$ lsof sys/vars.yml
$ fuser sys/vars.yml

# 2. 检查文件权限
$ ls -la sys/
$ chmod 644 sys/vars.yml

# 3. 重启服务
$ gsys stop
$ gsys start

# 4. 使用临时文件
$ cp sys/vars.yml sys/vars.yml.tmp
$ vi sys/vars.yml.tmp
$ mv sys/vars.yml.tmp sys/vars.yml
$ gsys reload
</code></pre>
<h2 id="网络连接问题"><a class="header" href="#网络连接问题">网络连接问题</a></h2>
<h3 id="1-服务连接超时"><a class="header" href="#1-服务连接超时">1. 服务连接超时</a></h3>
<h4 id="问题现象-4"><a class="header" href="#问题现象-4">问题现象</a></h4>
<pre><code class="language-bash">$ gsys check-health
错误: 用户服务连接超时 - 连接超时 (28)
</code></pre>
<h4 id="可能原因-4"><a class="header" href="#可能原因-4">可能原因</a></h4>
<ul>
<li>防火墙阻止连接</li>
<li>端口未开放</li>
<li>服务未启动</li>
<li>DNS解析错误</li>
<li>网络延迟过高</li>
</ul>
<h4 id="解决方案-4"><a class="header" href="#解决方案-4">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查端口开放
$ netstat -tlnp | grep :8080
$ ss -tlnp | grep :8080

# 2. 测试网络连通性
$ telnet user-service 8080
$ nc -zv user-service 8080

# 3. 检查防火墙
$ sudo ufw status
$ sudo iptables -L -n

# 4. 检查DNS解析
$ nslookup user-service
$ dig user-service

# 5. 测试延迟
$ ping user-service
$ traceroute user-service
</code></pre>
<h3 id="2-服务发现失败"><a class="header" href="#2-服务发现失败">2. 服务发现失败</a></h3>
<h4 id="问题现象-5"><a class="header" href="#问题现象-5">问题现象</a></h4>
<pre><code class="language-bash">$ gsys status
警告: 服务发现失败 - 无法注册服务到注册中心
</code></pre>
<h4 id="可能原因-5"><a class="header" href="#可能原因-5">可能原因</a></h4>
<ul>
<li>注册中心服务未启动</li>
<li>网络分区</li>
<li>服务配置错误</li>
<li>权限问题</li>
</ul>
<h4 id="解决方案-5"><a class="header" href="#解决方案-5">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查注册中心状态
$ kubectl get deployment -n registry
$ kubectl logs deployment/registry -n registry

# 2. 检查服务配置
$ yq eval '.service_discovery' sys/vars.yml
$ yq eval '.registry' sys/vars.yml

# 3. 测试注册中心连接
$ curl -X POST http://registry:8081/api/v1/register \
  -H "Content-Type: application/json" \
  -d '{"name":"test","address":"localhost:8080"}'

# 4. 检查网络策略
$ kubectl get networkpolicy -n registry
$ kubectl describe networkpolicy -n registry
</code></pre>
<h2 id="性能问题"><a class="header" href="#性能问题">性能问题</a></h2>
<h3 id="1-系统响应缓慢"><a class="header" href="#1-系统响应缓慢">1. 系统响应缓慢</a></h3>
<h4 id="问题现象-6"><a class="header" href="#问题现象-6">问题现象</a></h4>
<pre><code class="language-bash">$ gsys metrics
系统响应时间: 5.2s
CPU使用率: 85%
内存使用率: 90%
</code></pre>
<h4 id="可能原因-6"><a class="header" href="#可能原因-6">可能原因</a></h4>
<ul>
<li>资源不足</li>
<li>数据库查询慢</li>
<li>网络延迟</li>
<li>并发处理能力不足</li>
</ul>
<h4 id="解决方案-6"><a class="header" href="#解决方案-6">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查系统资源
$ free -h
$ df -h
$ top
$ htop

# 2. 分析数据库性能
$ psql -h localhost -U postgres -c "SELECT * FROM pg_stat_activity;"
$ psql -h localhost -U postgres -c "EXPLAIN ANALYZE SELECT * FROM users;"

# 3. 检查网络性能
$ ping -c 4 target-server
$ traceroute target-server
$ iperf3 -c target-server

# 4. 优化配置
$ vi sys/vars.yml
# 调整以下配置：
# - increase_memory_limit
# - increase_worker_threads
# - optimize_database_pool
$ gsys restart
</code></pre>
<h3 id="2-内存泄漏"><a class="header" href="#2-内存泄漏">2. 内存泄漏</a></h3>
<h4 id="问题现象-7"><a class="header" href="#问题现象-7">问题现象</a></h4>
<pre><code class="language-bash">$ gsys metrics
内存使用率持续增长
进程数不断增加
</code></pre>
<h4 id="可能原因-7"><a class="header" href="#可能原因-7">可能原因</a></h4>
<ul>
<li>未释放的资源</li>
<li>缓存未清理</li>
<li>循环引用</li>
<li>第三方库问题</li>
</ul>
<h4 id="解决方案-7"><a class="header" href="#解决方案-7">解决方案</a></h4>
<pre><code class="language-bash"># 1. 监控内存使用
$ watch -n 5 'free -h'
$ ps aux --sort=-%mem | head

# 2. 使用内存分析工具
$ valgrind --leak-check=full ./galaxy-ops

# 3. 检查缓存配置
$ yq eval '.cache.max_size' sys/vars.yml
$ yq eval '.cache.eviction_policy' sys/vars.yml

# 4. 重启服务
$ gsys restart

# 5. 分析内存转储
$ jmap -dump:format=b,file=dump.hprof &lt;pid&gt;
$ jhat dump.hprof
</code></pre>
<h2 id="安全问题"><a class="header" href="#安全问题">安全问题</a></h2>
<h3 id="1-认证失败"><a class="header" href="#1-认证失败">1. 认证失败</a></h3>
<h4 id="问题现象-8"><a class="header" href="#问题现象-8">问题现象</a></h4>
<pre><code class="language-bash">$ gsys auth
错误: 认证失败 - 无效的访问令牌
</code></pre>
<h4 id="可能原因-8"><a class="header" href="#可能原因-8">可能原因</a></h4>
<ul>
<li>令牌过期</li>
<li>令牌无效</li>
<li>密码错误</li>
<li>账户被锁定</li>
</ul>
<h4 id="解决方案-8"><a class="header" href="#解决方案-8">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查令牌状态
$ gsys token verify
$ gsys token info

# 2. 刷新令牌
$ gsys token refresh
$ gsys token login

# 3. 重置密码
$ gsys user reset-password

# 4. 检查账户状态
$ gsys user status
$ gsys user unlock
</code></pre>
<h3 id="2-权限不足"><a class="header" href="#2-权限不足">2. 权限不足</a></h3>
<h4 id="问题现象-9"><a class="header" href="#问题现象-9">问题现象</a></h4>
<pre><code class="language-bash">$ gsys admin
错误: 权限不足 - 需要管理员权限
</code></pre>
<h4 id="可能原因-9"><a class="header" href="#可能原因-9">可能原因</a></h4>
<ul>
<li>用户角色权限不足</li>
<li>系统配置错误</li>
<li>权限缓存过期</li>
<li>安全策略冲突</li>
</ul>
<h4 id="解决方案-9"><a class="header" href="#解决方案-9">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查用户权限
$ gsys user permissions
$ gsys user roles

# 2. 验证权限配置
$ yq eval '.security.roles' sys/vars.yml

# 3. 检查系统权限
$ ls -la /etc/galaxy-ops/
$ getfacl /etc/galaxy-ops/

# 4. 重新登录
$ gsys logout
$ gsys login --admin
</code></pre>
<h2 id="部署问题"><a class="header" href="#部署问题">部署问题</a></h2>
<h3 id="1-kubernetes-部署失败"><a class="header" href="#1-kubernetes-部署失败">1. Kubernetes 部署失败</a></h3>
<h4 id="问题现象-10"><a class="header" href="#问题现象-10">问题现象</a></h4>
<pre><code class="language-bash">$ gsys deploy
错误: Kubernetes部署失败 - 无法创建Pod
</code></pre>
<h4 id="可能原因-10"><a class="header" href="#可能原因-10">可能原因</a></h4>
<ul>
<li>资源不足</li>
<li>配置错误</li>
<li>权限不足</li>
<li>网络策略限制</li>
</ul>
<h4 id="解决方案-10"><a class="header" href="#解决方案-10">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查资源状态
$ kubectl get nodes
$ kubectl get pods --all-namespaces
$ kubectl describe pod &lt;pod-name&gt;

# 2. 检查事件
$ kubectl get events --sort-by='.metadata.creationTimestamp'

# 3. 检查日志
$ kubectl logs &lt;pod-name&gt;
$ kubectl logs &lt;pod-name&gt; --previous

# 4. 验证配置
$ helm template . &gt; rendered.yaml
$ kubectl apply -f rendered.yaml --dry-run=client

# 5. 检查权限
$ kubectl auth can-i create deployments
$ kubectl auth can-i create pods
</code></pre>
<h3 id="2-容器镜像拉取失败"><a class="header" href="#2-容器镜像拉取失败">2. 容器镜像拉取失败</a></h3>
<h4 id="问题现象-11"><a class="header" href="#问题现象-11">问题现象</a></h4>
<pre><code class="language-bash">$ kubectl describe pod
镜像拉取失败: 无法拉取镜像 registry.example.com/image:latest
</code></pre>
<h4 id="可能原因-11"><a class="header" href="#可能原因-11">可能原因</a></h4>
<ul>
<li>镜像不存在</li>
<li>仓库认证失败</li>
<li>网络连接问题</li>
<li>镜像标签错误</li>
</ul>
<h4 id="解决方案-11"><a class="header" href="#解决方案-11">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查镜像存在性
$ docker pull registry.example.com/image:latest

# 2. 检查认证配置
$ cat ~/.docker/config.json
$ kubectl get secret docker-registry

# 3. 测试网络连接
$ curl -I https://registry.example.com/v2/

# 4. 使用本地镜像
$ docker tag local-image:latest registry.example.com/image:latest
$ docker push registry.example.com/image:latest
$ kubectl set image deployment/my-app my-app=registry.example.com/image:latest
</code></pre>
<h2 id="监控问题"><a class="header" href="#监控问题">监控问题</a></h2>
<h3 id="1-指标收集失败"><a class="header" href="#1-指标收集失败">1. 指标收集失败</a></h3>
<h4 id="问题现象-12"><a class="header" href="#问题现象-12">问题现象</a></h4>
<pre><code class="language-bash">$ gsys metrics
警告: 无法收集系统指标 - 指标服务不可用
</code></pre>
<h4 id="可能原因-12"><a class="header" href="#可能原因-12">可能原因</a></h4>
<ul>
<li>监控服务未启动</li>
<li>配置错误</li>
<li>权限不足</li>
<li>存储空间不足</li>
</ul>
<h4 id="解决方案-12"><a class="header" href="#解决方案-12">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查监控服务
$ kubectl get deployment -n monitoring
$ kubectl logs deployment/prometheus -n monitoring

# 2. 检查配置
$ yq eval '.monitoring.enabled' sys/vars.yml
$ yq eval '.monitoring.endpoints' sys/vars.yml

# 3. 测试指标端点
$ curl http://localhost:8080/metrics
$ curl http://localhost:9090/api/v1/query?query=up

# 4. 检查存储空间
$ df -h
$ kubectl exec -it prometheus-0 -n monitoring -- df -h
</code></pre>
<h3 id="2-告警规则误报"><a class="header" href="#2-告警规则误报">2. 告警规则误报</a></h3>
<h4 id="问题现象-13"><a class="header" href="#问题现象-13">问题现象</a></h4>
<pre><code class="language-bash">$ gsys alerts
警告: 大量误报告警 - CPU使用率过高
</code></pre>
<h4 id="可能原因-13"><a class="header" href="#可能原因-13">可能原因</a></h4>
<ul>
<li>阈值设置不合理</li>
<li>告警规则配置错误</li>
<li>数据采集异常</li>
<li>环境波动</li>
</ul>
<h4 id="解决方案-13"><a class="header" href="#解决方案-13">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查告警配置
$ yq eval '.alerts.rules' sys/vars.yml

# 2. 查看告警历史
$ gsys alerts history
$ kubectl logs deployment/alertmanager -n monitoring

# 3. 调整阈值
$ yq eval '.alerts.rules[].condition' sys/vars.yml

# 4. 添加抑制规则
$ yq eval '.alertmanager.suppress_rules' sys/vars.yml
</code></pre>
<h2 id="数据问题"><a class="header" href="#数据问题">数据问题</a></h2>
<h3 id="1-数据库连接失败"><a class="header" href="#1-数据库连接失败">1. 数据库连接失败</a></h3>
<h4 id="问题现象-14"><a class="header" href="#问题现象-14">问题现象</a></h4>
<pre><code class="language-bash">$ gsql
错误: 连接数据库失败 - 访问被拒绝
</code></pre>
<h4 id="可能原因-14"><a class="header" href="#可能原因-14">可能原因</a></h4>
<ul>
<li>数据库服务未启动</li>
<li>认证信息错误</li>
<li>网络连接问题</li>
<li>数据库权限不足</li>
</ul>
<h4 id="解决方案-14"><a class="header" href="#解决方案-14">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查数据库服务
$ kubectl get deployment -n database
$ kubectl logs deployment/postgres -n database

# 2. 验证连接信息
$ yq eval '.database' sys/vars.yml

# 3. 测试连接
$ nc -zv postgres 5432
$ telnet postgres 5432

# 4. 检查权限
$ psql -h postgres -U postgres -c "\du"
$ psql -h postgres -U postgres -c "\l"
</code></pre>
<h3 id="2-数据不一致"><a class="header" href="#2-数据不一致">2. 数据不一致</a></h3>
<h4 id="问题现象-15"><a class="header" href="#问题现象-15">问题现象</a></h4>
<pre><code class="language-bash">$ gsql check-consistency
错误: 数据一致性检查失败 - 发现不一致
</code></pre>
<h4 id="可能原因-15"><a class="header" href="#可能原因-15">可能原因</a></h4>
<ul>
<li>并发操作冲突</li>
<li>数据损坏</li>
<li>同步延迟</li>
<li>应用逻辑错误</li>
</ul>
<h4 id="解决方案-15"><a class="header" href="#解决方案-15">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查数据完整性
$ gsql check-integrity

# 2. 查看同步状态
$ gsql replication status

# 3. 检查并发操作
$ gsql show-processlist

# 4. 执行数据修复
$ gsql repair-consistency

# 5. 优化应用逻辑
$ vi src/business_logic.rs
# - 添加事务隔离
# - 优化并发控制
# - 增加重试机制
</code></pre>
<h2 id="模块问题"><a class="header" href="#模块问题">模块问题</a></h2>
<h3 id="1-模块依赖冲突"><a class="header" href="#1-模块依赖冲突">1. 模块依赖冲突</a></h3>
<h4 id="问题现象-16"><a class="header" href="#问题现象-16">问题现象</a></h4>
<pre><code class="language-bash">$ gsys validate
错误: 依赖冲突 - 模块A需要v1.0，模块B需要v2.0
</code></pre>
<h4 id="可能原因-16"><a class="header" href="#可能原因-16">可能原因</a></h4>
<ul>
<li>版本不兼容</li>
<li>依赖循环</li>
<li>传递依赖冲突</li>
<li>环境差异</li>
</ul>
<h4 id="解决方案-16"><a class="header" href="#解决方案-16">解决方案</a></h4>
<pre><code class="language-bash"># 1. 分析依赖树
$ gsys dependency-tree

# 2. 检查版本冲突
$ gsys version-check

# 3. 升级依赖
$ gsys upgrade module-A --version v2.0

# 4. 解决循环依赖
# 重构代码或重新设计依赖关系

# 5. 使用多版本依赖
$ gsys multi-version enable
</code></pre>
<h3 id="2-模块热更新失败"><a class="header" href="#2-模块热更新失败">2. 模块热更新失败</a></h3>
<h4 id="问题现象-17"><a class="header" href="#问题现象-17">问题现象</a></h4>
<pre><code class="language-bash">$ gsys update-module
错误: 模块热更新失败 - 服务中断
</code></pre>
<h4 id="可能原因-17"><a class="header" href="#可能原因-17">可能原因</a></h4>
<ul>
<li>配置错误</li>
<li>依赖问题</li>
<li>资源冲突</li>
<li>服务状态异常</li>
</ul>
<h4 id="解决方案-17"><a class="header" href="#解决方案-17">解决方案</a></h4>
<pre><code class="language-bash"># 1. 检查模块状态
$ gsys module status

# 2. 验证配置
$ gsys module validate

# 3. 测试更新
$ gsys module test-update

# 4. 执行更新
$ gsys module update --force

# 5. 滚回更新
$ gsys module rollback
</code></pre>
<h2 id="最佳实践-9"><a class="header" href="#最佳实践-9">最佳实践</a></h2>
<h3 id="1-问题诊断流程"><a class="header" href="#1-问题诊断流程">1. 问题诊断流程</a></h3>
<pre><code class="language-bash"># 1. 收集问题信息
$ gsys info --verbose

# 2. 检查系统状态
$ gsys status
$ gsys health

# 3. 查看日志
$ gsys logs --follow
$ journalctl -u galaxy-ops

# 4. 分析资源使用
$ gsys metrics
$ top
$ df -h

# 5. 检查网络状态
$ netstat -tlnp
$ ping target-server

# 6. 验证配置
$ gsys validate --deep

# 7. 执行修复
$ gsys repair

# 8. 验证修复结果
$ gsys health
</code></pre>
<h3 id="2-性能调优"><a class="header" href="#2-性能调优">2. 性能调优</a></h3>
<pre><code class="language-bash"># 1. 基准测试
$ gsys benchmark --test load

# 2. 性能分析
$ gsys profile --cpu
$ gsys profile --memory

# 3. 配置优化
$ gsys optimize --auto
$ gsys optimize --manual

# 4. 负载测试
$ gsys stress-test --concurrent 1000

# 5. 容量规划
$ gsys capacity-plan
</code></pre>
<h3 id="3-自动化运维"><a class="header" href="#3-自动化运维">3. 自动化运维</a></h3>
<pre><code class="language-bash"># 1. 设置监控告警
$ gsys alerts configure --auto

# 2. 自动扩缩容
$ gscale auto
$ gscale policy add

# 3. 自动备份
$ gbackup schedule --daily
$ gbackup verify

# 4. 自动恢复
$ gscale auto-restore
</code></pre>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<p>通过本文档提供的故障排除指南，你可以快速诊断和解决 Sys-Operator 系统运行中的各种问题。记住：</p>
<h3 id="问题解决原则"><a class="header" href="#问题解决原则">问题解决原则</a></h3>
<ol>
<li><strong>系统化</strong>: 遵循标准的诊断流程</li>
<li><strong>数据驱动</strong>: 基于指标和日志进行分析</li>
<li><strong>逐步排除</strong>: 逐一排查可能的原因</li>
<li><strong>测试验证</strong>: 每一步操作都要验证结果</li>
</ol>
<h3 id="预防建议"><a class="header" href="#预防建议">预防建议</a></h3>
<ol>
<li><strong>定期维护</strong>: 执行系统健康检查和优化</li>
<li><strong>监控预警</strong>: 建立完善的监控和告警体系</li>
<li><strong>文档记录</strong>: 详细记录问题和解决方案</li>
<li><strong>团队协作</strong>: 建立问题响应和解决机制</li>
</ol>
<h3 id="持续改进"><a class="header" href="#持续改进">持续改进</a></h3>
<ol>
<li><strong>经验积累</strong>: 总结常见问题和解决方案</li>
<li><strong>工具优化</strong>: 开发自动化诊断工具</li>
<li><strong>知识共享</strong>: 建立问题库和最佳实践</li>
<li><strong>培训提升</strong>: 团队技能持续提升</li>
</ol>
<p>通过系统化的故障排除和持续改进，确保 Sys-Operator 系统稳定可靠地运行，为业务发展提供强有力的技术保障。</p>
<hr />
<p><em>更多技术支持请参考 <a href="operator/sys/troubleshooting/../README.html">官方文档</a> 或联系技术支持团队。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-开发指南"><a class="header" href="#mod-operator-开发指南">Mod-Operator 开发指南</a></h1>
<h2 id="概述-11"><a class="header" href="#概述-11">概述</a></h2>
<p>Mod-Operator 是 Galaxy Ops 框架的核心组件，用于定义和管理可复用的运维模块。每个 Mod-Operator 代表一个独立的软件组件或服务，包含完整的生命周期管理能力，包括安装、配置、启动、停止、监控等操作。</p>
<h3 id="核心特性"><a class="header" href="#核心特性">核心特性</a></h3>
<ul>
<li><strong>多平台支持</strong>: 支持不同的 CPU 架构、操作系统和运行环境组合</li>
<li><strong>模块化设计</strong>: 每个模块都是独立的，可单独开发和版本管理</li>
<li><strong>工作流驱动</strong>: 使用 GXL 语言定义复杂的运维操作流程</li>
<li><strong>模板本地化</strong>: 支持配置模板渲染和环境适配</li>
<li><strong>依赖管理</strong>: 处理模块间的依赖关系</li>
<li><strong>构件管理</strong>: 统一的软件包下载、缓存和分发机制</li>
</ul>
<h3 id="在-galaxy-ops-生态系统中的位置"><a class="header" href="#在-galaxy-ops-生态系统中的位置">在 Galaxy Ops 生态系统中的位置</a></h3>
<pre><code>gmod (创建模块) → gsys (组合系统) → gops (工程管理) → gflow (执行工作流)
</code></pre>
<p>Mod-Operator 是整个运维体系的基础构建块，由 <code>gmod</code> 工具创建和管理，最终通过 <code>gflow</code> 执行具体的运维操作。</p>
<h2 id="文档索引"><a class="header" href="#文档索引">文档索引</a></h2>
<p>本指南被拆分为以下文档以便于维护：</p>
<ul>
<li><strong><a href="operator/mod/./CONFIGURATION.html">配置说明</a></strong> - 核心配置文件详细说明</li>
<li><strong><a href="operator/mod/./DEVELOPMENT.html">开发指南</a></strong> - 开发工作流和最佳实践</li>
<li><strong><a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a></strong> - 调试和故障排除</li>
<li><strong><a href="operator/mod/./REFERENCE.html">API 参考</a></strong> - API 和枚举参考</li>
</ul>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<h3 id="创建新模块"><a class="header" href="#创建新模块">创建新模块</a></h3>
<pre><code class="language-bash"># 创建基础模块
gmod new postgresql

# 创建带目标的模块
gmod new postgresql --targets arm-mac14-host,x86-ubt22-k8s

# 从模板创建
gmod new postgresql --template database
</code></pre>
<h3 id="基本文件结构"><a class="header" href="#基本文件结构">基本文件结构</a></h3>
<pre><code>module_name/
├── mod/                              # 模块定义目录
│   ├── arm-mac14-host/              # ARM + macOS14 + Host 环境
│   │   ├── _gal/                    # 项目配置目录
│   │   ├── local/                   # 本地化生成的配置
│   │   ├── spec/                    # 规范文件目录
│   │   ├── values/                  # 值文件目录
│   │   ├── vars.yml                 # 变量定义
│   │   ├── setting.yml              # 本地化设置
│   │   └── workflows/               # 工作流定义
│   └── x86-ubt22-k8s/              # x86 + Ubuntu22 + K8s 环境
│       └── [相同的子目录结构]
├── mod-prj.yml                      # 模块项目配置
├── version.txt                      # 版本文件
├── .gitignore                       # Git 忽略文件
└── test_res/                        # 测试资源目录
</code></pre>
<h3 id="支持的目标平台"><a class="header" href="#支持的目标平台">支持的目标平台</a></h3>
<div class="table-wrapper"><table><thead><tr><th>组合</th><th>CPU架构</th><th>操作系统</th><th>运行环境</th><th>适用场景</th></tr></thead><tbody>
<tr><td><code>arm-mac14-host</code></td><td>ARM</td><td>macOS 14+</td><td>Host 宿主机</td><td>Apple Silicon Mac 本地开发</td></tr>
<tr><td><code>x86-ubt22-host</code></td><td>x86_64</td><td>Ubuntu 22.04</td><td>Host 宿主机</td><td>Linux 服务器本地部署</td></tr>
<tr><td><code>x86-ubt22-k8s</code></td><td>x86_64</td><td>Ubuntu 22.04</td><td>Kubernetes</td><td>K8s 集群容器化部署</td></tr>
</tbody></table>
</div>
<h2 id="开发工作流"><a class="header" href="#开发工作流">开发工作流</a></h2>
<h3 id="1-定义模块规范"><a class="header" href="#1-定义模块规范">1. 定义模块规范</a></h3>
<ul>
<li>编辑 <code>spec/artifact.yml</code> - 构件定义</li>
<li>编辑 <code>spec/depends.yml</code> - 依赖定义</li>
</ul>
<h3 id="2-配置变量"><a class="header" href="#2-配置变量">2. 配置变量</a></h3>
<ul>
<li>编辑 <code>vars.yml</code> - 变量定义</li>
<li>编辑 <code>values/_value.yml</code> - 默认值</li>
</ul>
<h3 id="3-编写工作流"><a class="header" href="#3-编写工作流">3. 编写工作流</a></h3>
<ul>
<li>编辑 <code>workflows/operators.gxl</code> - 使用 GXL 定义工作流</li>
</ul>
<h3 id="4-测试和验证"><a class="header" href="#4-测试和验证">4. 测试和验证</a></h3>
<ul>
<li>使用 <code>gflow</code> 测试工作流</li>
<li>使用 <code>gmod validate</code> 验证配置</li>
</ul>
<h3 id="5-本地化模块"><a class="header" href="#5-本地化模块">5. 本地化模块</a></h3>
<ul>
<li>使用 <code>gmod localize</code> 生成特定环境配置</li>
</ul>
<h2 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h2>
<h3 id="modelstd-标准型号"><a class="header" href="#modelstd-标准型号">ModelSTD 标准型号</a></h3>
<p>Mod-Operator 使用 <code>ModelSTD</code> 标准型号来定义目标平台，格式为 <code>arch-os-spc</code>：</p>
<ul>
<li><strong>CPU 架构</strong>: X86 (x86_64), ARM</li>
<li><strong>操作系统</strong>: MAC14 (macOS 14+), UBT22 (Ubuntu 22.04), WIN10 (Windows 10+), COS7 (CentOS 7)</li>
<li><strong>运行空间</strong>: Host (宿主机环境), K8S (Kubernetes 环境)</li>
</ul>
<h3 id="构件管理"><a class="header" href="#构件管理">构件管理</a></h3>
<p>构件定义了模块所需的软件包和下载资源，包括：</p>
<ul>
<li>名称 (name)</li>
<li>版本 (version)</li>
<li>原始地址 (origin_addr)</li>
<li>缓存地址 (cache_addr)</li>
<li>缓存启用 (cache_enable)</li>
<li>本地文件名 (local)</li>
</ul>
<h3 id="依赖管理-2"><a class="header" href="#依赖管理-2">依赖管理</a></h3>
<p>模块可以依赖其他模块或资源，支持：</p>
<ul>
<li>本地路径依赖</li>
<li>Git 仓库依赖</li>
<li>条件依赖（根据变量启用/禁用）</li>
<li>版本约束</li>
</ul>
<h3 id="工作流引擎"><a class="header" href="#工作流引擎">工作流引擎</a></h3>
<p>使用 GXL (Galaxy eXecution Language) 定义运维操作：</p>
<ul>
<li>支持任务定义和执行</li>
<li>变量模板渲染</li>
<li>条件分支和循环</li>
<li>外部命令执行</li>
<li>错误处理和重试机制</li>
</ul>
<h2 id="相关工具"><a class="header" href="#相关工具">相关工具</a></h2>
<ul>
<li><strong>gmod</strong>: 模块创建和管理工具</li>
<li><strong>gops</strong>: 工程管理工具</li>
<li><strong>gflow</strong>: 工作流执行工具</li>
<li><strong>gsys</strong>: 系统组合工具</li>
</ul>
<h2 id="更多信息"><a class="header" href="#更多信息">更多信息</a></h2>
<p>查看详细文档：</p>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./DEVELOPMENT.html">开发指南</a> - 开发最佳实践</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>📖 <a href="operator/mod/./EXAMPLES.html">示例参考</a> - 完整的模块示例</li>
<li>📖 <a href="operator/mod/./REFERENCE.html">API 参考</a> - API 和枚举定义</li>
</ul>
<hr />
<p><em>Mod-Operator 是 Galaxy Ops 框架的核心构建块，通过标准化的文件结构、配置管理和工作流定义，实现了软件组件的模块化运维管理。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-开发指南-1"><a class="header" href="#mod-operator-开发指南-1">Mod-Operator 开发指南</a></h1>
<p>本文档详细介绍 Mod-Operator 的开发工作流程、最佳实践和技巧，帮助开发者高效地创建高质量的运维模块。</p>
<h2 id="开发工作流-1"><a class="header" href="#开发工作流-1">开发工作流</a></h2>
<h3 id="1-创建新模块"><a class="header" href="#1-创建新模块">1. 创建新模块</a></h3>
<p>使用 <code>gmod</code> 工具快速创建新模块的骨架结构。</p>
<h4 id="基础模块创建"><a class="header" href="#基础模块创建">基础模块创建</a></h4>
<pre><code class="language-bash"># 创建基础模块
//fix: use gmod cmd and args

</code></pre>
<h4 id="生成的模块结构"><a class="header" href="#生成的模块结构">生成的模块结构</a></h4>
<pre><code class="language-bash">postgresql/
├── mod/
│   ├── arm-mac14-host/
│   │   ├── spec/
│   │   │   ├── artifact.yml
│   │   │   └── depends.yml
│   │   ├── vars.yml
│   │   ├── setting.yml
│   │   ├── values/
│   │   │   ├── _value.yml
│   │   │   └── _used.yml
│   │   ├── workflows/
│   │   │   └── operators.gxl
│   │   └── _gal/
│   │       ├── work.gxl
│   │       └── project.toml
│   └── x86-ubt22-k8s/
│       └── [相同结构]
├── mod-prj.yml
├── version.txt
├── .gitignore
└── README.md
</code></pre>
<h3 id="2-模块开发步骤"><a class="header" href="#2-模块开发步骤">2. 模块开发步骤</a></h3>
<h4 id="步骤-1定义构件和依赖"><a class="header" href="#步骤-1定义构件和依赖">步骤 1：定义构件和依赖</a></h4>
<p>编辑 <code>spec/artifact.yml</code> 和 <code>spec/depends.yml</code>：</p>
<pre><code class="language-bash"># 编辑构件配置
vim mod/arm-mac14-host/spec/artifact.yml

# 编辑依赖配置
vim mod/arm-mac14-host/spec/depends.yml
</code></pre>
<p><strong>artifact.yml 示例：</strong></p>
<pre><code class="language-yaml">- name: postgresql
  version: 17.4
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz

- name: pcre
  version: 8.45
  origin_addr:
    url: https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz
  local: pcre-8.45.tar.gz
</code></pre>
<p><strong>depends.yml 示例：</strong></p>
<pre><code class="language-yaml">dep_root: ./depends

deps:
- addr:
    path: ./common_libs
  local: common_libs
  enable: true

- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "3.0.0"
  local: openssl
  enable: true
</code></pre>
<h4 id="步骤-2配置变量和默认值"><a class="header" href="#步骤-2配置变量和默认值">步骤 2：配置变量和默认值</a></h4>
<p>编辑变量配置文件：</p>
<pre><code class="language-bash"># 定义环境变量
vim mod/arm-mac14-host/vars.yml

</code></pre>
<p><strong>vars.yml 示例：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  desp: "数据库端口号"
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: MAX_CONNECTIONS
  type: integer
  min: 1
  max: 1000
  value: 100

- name: DATA_DIR
  value: "/var/lib/postgresql"

- name: ENABLE_SSL
  type: boolean
  value: false
</code></pre>
<h4 id="步骤-3编写工作流"><a class="header" href="#步骤-3编写工作流">步骤 3：编写工作流</a></h4>
<p>编辑 <code>workflows/operators.gxl</code> 定义运维操作：</p>
<pre><code class="language-bash"># 编写操作工作流
vim mod/arm-mac14-host/workflows/operators.gxl
</code></pre>
<h4 id="步骤-4配置本地化设置按需"><a class="header" href="#步骤-4配置本地化设置按需">步骤 4：配置本地化设置[按需]</a></h4>
<p>编辑 <code>setting.yml</code> 配置模板渲染：</p>
<pre><code class="language-bash"># 配置本地化设置
vim mod/arm-mac14-host/setting.yml
</code></pre>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - LICENSE
    - "*.log"

  templatize_cust:
    label_beg: '{{'
    label_end: '}}'
</code></pre>
<h4 id="步骤-5验证和测试"><a class="header" href="#步骤-5验证和测试">步骤 5：验证和测试</a></h4>
<pre><code class="language-bash">
# 生成本地化配置
gmod localize

# 测试工作流
gflow install --dry-run
</code></pre>
<h3 id="3-开发工具使用"><a class="header" href="#3-开发工具使用">3. 开发工具使用</a></h3>
<h4 id="gmod---模块管理工具"><a class="header" href="#gmod---模块管理工具">gmod - 模块管理工具</a></h4>
<pre><code class="language-bash"># 创建模块
gmod new module_name


# 生成本地化配置
gmod localize

</code></pre>
<h4 id="gflow---工作流执行工具"><a class="header" href="#gflow---工作流执行工具">gflow - 工作流执行工具</a></h4>
<pre><code class="language-bash"># 执行工作流
gflow install
gflow start
gflow stop
gflow restart

# 调试模式
gflow install -d 1  # 详细输出
gflow install -d 2  # 更详细输出
gflow install -d 3  # 最详细输出

# 试运行模式
gflow install --dry-run

</code></pre>
<h2 id="最佳实践-10"><a class="header" href="#最佳实践-10">最佳实践</a></h2>
<h3 id="1-模块设计原则"><a class="header" href="#1-模块设计原则">1. 模块设计原则</a></h3>
<h4 id="单一职责原则"><a class="header" href="#单一职责原则">单一职责原则</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 专注单一组件
name: postgresql
description: "PostgreSQL 数据库管理模块"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 职责混乱
name: database_stack
description: "数据库、缓存、消息队列管理模块"
</code></pre>
<h4 id="接口一致性"><a class="header" href="#接口一致性">接口一致性</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 统一的任务命名
#[task(name="gops@install")]
flow install { ... }

#[task(name="gops@start")]
flow start { ... }

#[task(name="gops@stop")]
flow stop { ... }

#[task(name="gops@restart")]
flow restart { ... }
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 不一致的命名
#[task(name="install")]
flow install { ... }

#[task(name="startup")]
flow start { ... }

#[task(name="halt")]
flow stop { ... }
</code></pre>
<h4 id="配置外部化"><a class="header" href="#配置外部化">配置外部化</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 所有配置参数提取到变量
vars:
- name: DATABASE_PORT
  value: 5432

- name: MAX_CONNECTIONS
  value: 100

- name: DATA_DIR
  value: "/var/lib/postgresql"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 硬编码配置
flow install {
    gx.cmd("postgres -p 5432 -d /var/lib/postgresql");
}
</code></pre>
<h3 id="2-工作流设计"><a class="header" href="#2-工作流设计">2. 工作流设计</a></h3>
<h4 id="幂等性设计"><a class="header" href="#幂等性设计">幂等性设计</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-gxl">flow install {
    // 检查是否已安装
    if gx.defined("/usr/local/bin/postgres") {
        gx.echo("PostgreSQL 已安装，跳过安装步骤");
        return;
    }

    // 执行安装
    gx.cmd("./install.sh");

    // 验证安装
    gx.assert(gx.path_exists("/usr/local/bin/postgres"));
}
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-gxl">flow install {
    // 没有检查，可能重复安装
    gx.cmd("./install.sh");
}
</code></pre>
<h3 id="3-变量管理"><a class="header" href="#3-变量管理">3. 变量管理</a></h3>
<h4 id="命名规范-1"><a class="header" href="#命名规范-1">命名规范</a></h4>
<p><strong>✅ 好的命名：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: 5432

- name: MAX_CONNECTIONS
  value: 100

- name: DATA_DIRECTORY
  value: "/var/lib/postgresql"
</code></pre>
<p><strong>❌ 不好的命名：</strong></p>
<pre><code class="language-yaml">vars:
- name: port
  value: 5432

- name: max_conn
  value: 100

- name: data_dir
  value: "/var/lib/postgresql"
</code></pre>
<h4 id="类型安全"><a class="header" href="#类型安全">类型安全</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: ENABLE_SSL
  type: boolean
  value: false

- name: LOG_LEVEL
  type: enum
  values: [debug, info, warn, error]
  value: info
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: "5432"  # 字符串而不是数字

- name: ENABLE_SSL
  value: "false"  # 字符串而不是布尔值
</code></pre>
<h4 id="环境变量支持"><a class="header" href="#环境变量支持">环境变量支持</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: "${POSTGRES_PORT:5432}"  # 默认值 5432

- name: INSTALL_PREFIX
  value: "${PREFIX:/usr/local}"  # 默认 /usr/local

- name: DEBUG_MODE
  type: boolean
  value: "${DEBUG:false}"  # 默认 false
</code></pre>
<h3 id="4-依赖管理"><a class="header" href="#4-依赖管理">4. 依赖管理</a></h3>
<h4 id="版本约束"><a class="header" href="#版本约束">版本约束</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "3.0.0"  # 语义化版本
  enable: true

- addr:
    repo: https://github.com/pcre/pcre.git
    tag: "8.45"
  enable: true
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "latest"  # 不稳定的版本
  enable: true
</code></pre>
<h4 id="条件依赖"><a class="header" href="#条件依赖">条件依赖</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: "${USE_FEATURES:true}"

- addr:
    repo: https://github.com/debug/tools.git
    branch: main
  local: debug_tools
  enable: "${BUILD_MODE:debug}" == "debug"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: true  # 应该根据条件启用
</code></pre>
<h4 id="本地依赖优先"><a class="header" href="#本地依赖优先">本地依赖优先</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
# 本地依赖优先
- addr:
    path: ./local_libs
  local: common_libs
  enable: true

# 外部依赖作为后备
- addr:
    repo: https://github.com/external/lib.git
    tag: "1.0.0"
  local: common_libs
  enable: false  # 默认禁用
</code></pre>
<h3 id="5-文档和维护"><a class="header" href="#5-文档和维护">5. 文档和维护</a></h3>
<h4 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># mod-prj.yml
name: postgresql
version: "17.4.0"
description: "PostgreSQL 数据库管理模块"

# version.txt
17.4.0
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 没有版本管理
name: postgresql
version: "latest"
description: "PostgreSQL 数据库管理模块"
</code></pre>
<h2 id="调试和故障排除"><a class="header" href="#调试和故障排除">调试和故障排除</a></h2>
<h3 id="常见问题诊断"><a class="header" href="#常见问题诊断">常见问题诊断</a></h3>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<p>遵循本开发指南，可以创建出高质量、可维护、可扩展的 Mod-Operator 模块。关键要点：</p>
<ol>
<li><strong>标准化开发流程</strong>：遵循一致的模块创建和开发流程</li>
<li><strong>最佳实践设计</strong>：采用单一职责、幂等性、错误处理等设计原则</li>
<li><strong>有效的调试策略</strong>：使用详细的日志、断言和分步调试</li>
<li><strong>性能优化</strong>：利用并行执行和缓存机制</li>
<li><strong>高级功能</strong>：掌握条件工作流、模板系统</li>
</ol>
<p>通过合理应用这些技巧和最佳实践，可以显著提升模块开发效率和质量，为复杂的系统运维提供坚实的基础。</p>
<h2 id="相关资源"><a class="header" href="#相关资源">相关资源</a></h2>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>📖 <a href="operator/mod/./EXAMPLES.html">示例参考</a> - 完整的模块示例</li>
<li>📖 <a href="operator/mod/./REFERENCE.html">API 参考</a> - API 和枚举定义</li>
<li>🛠️ <a href="operator/mod/../gmod/">gmod 工具文档</a> - 模块管理工具使用指南</li>
<li>🛠️ <a href="operator/mod/../gflow/">gflow 工具文档</a> - 工作流执行工具使用指南</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-配置文件详解"><a class="header" href="#mod-operator-配置文件详解">Mod-Operator 配置文件详解</a></h1>
<p>本文档详细介绍 Mod-Operator 的各个配置文件及其使用方法。</p>
<h2 id="配置文件概览"><a class="header" href="#配置文件概览">配置文件概览</a></h2>
<p>Mod-Operator 使用多种配置文件来定义模块的行为和属性：</p>
<div class="table-wrapper"><table><thead><tr><th>文件</th><th>位置</th><th>作用</th><th>格式</th></tr></thead><tbody>
<tr><td><code>spec/artifact.yml</code></td><td><code>mod/{platform}/spec/</code></td><td>定义软件包和资源</td><td>YAML</td></tr>
<tr><td><code>spec/depends.yml</code></td><td><code>mod/{platform}/spec/</code></td><td>定义依赖关系</td><td>YAML</td></tr>
<tr><td><code>vars.yml</code></td><td><code>mod/{platform}/</code></td><td>定义环境变量</td><td>YAML</td></tr>
<tr><td><code>setting.yml</code></td><td><code>mod/{platform}/</code></td><td>配置本地化行为</td><td>YAML</td></tr>
<tr><td><code>workflows/operators.gxl</code></td><td><code>mod/{platform}/workflows/</code></td><td>工作流定义</td><td>GXL</td></tr>
<tr><td><code>mod-prj.yml</code></td><td>根目录</td><td>项目配置</td><td>YAML</td></tr>
</tbody></table>
</div>
<h2 id="specartifactyml---构件定义"><a class="header" href="#specartifactyml---构件定义">spec/artifact.yml - 构件定义</a></h2>
<p><code>artifact.yml</code> 是 Mod-Operator 中最重要的配置文件之一，它定义了模块所需的软件包、资源及其下载配置。</p>
<h3 id="基本格式"><a class="header" href="#基本格式">基本格式</a></h3>
<pre><code class="language-yaml"># 单个构件定义
- name: postgresql
  version: 0.1.0
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz
</code></pre>
<h3 id="字段说明"><a class="header" href="#字段说明">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>是</td><td>构件名称</td></tr>
<tr><td><code>version</code></td><td>String</td><td>是</td><td>构件版本</td></tr>
<tr><td><code>origin_addr</code></td><td>Object</td><td>是</td><td>原始下载地址</td></tr>
<tr><td><code>cache_addr</code></td><td>Object</td><td>否</td><td>缓存地址（可选）</td></tr>
<tr><td><code>cache_enable</code></td><td>Boolean</td><td>否</td><td>是否启用缓存（默认 false）</td></tr>
<tr><td><code>local</code></td><td>String</td><td>是</td><td>本地存储文件名</td></tr>
</tbody></table>
</div>
<h3 id="地址类型支持"><a class="header" href="#地址类型支持">地址类型支持</a></h3>
<h4 id="http-地址"><a class="header" href="#http-地址">HTTP 地址</a></h4>
<pre><code class="language-yaml">- name: nginx
  version: 1.25.3
  origin_addr:
    url: https://nginx.org/download/nginx-1.25.3.tar.gz
  local: nginx-1.25.3.tar.gz
</code></pre>
<h4 id="git-仓库"><a class="header" href="#git-仓库">Git 仓库</a></h4>
<pre><code class="language-yaml">- name: galaxy-flow
  version: 0.1.0
  origin_addr:
    repo: https://github.com/galaxy-sec/galaxy-flow.git
    branch: main
  local: galaxy-flow
</code></pre>
<h4 id="本地路径"><a class="header" href="#本地路径">本地路径</a></h4>
<pre><code class="language-yaml">- name: custom-library
  version: 1.0.0
  origin_addr:
    path: /path/to/local/library.tar.gz
  local: custom-library.tar.gz
</code></pre>
<h3 id="多构件定义"><a class="header" href="#多构件定义">多构件定义</a></h3>
<pre><code class="language-yaml">- name: postgresql
  version: 17.4
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz

- name: pcre
  version: 8.45
  origin_addr:
    url: https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz
  local: pcre-8.45.tar.gz

- name: openssl
  version: 3.0.0
  origin_addr:
    repo: https://github.com/openssl/openssl.git
    tag: openssl-3.0.0
  local: openssl-3.0.0
</code></pre>
<h3 id="缓存配置"><a class="header" href="#缓存配置">缓存配置</a></h3>
<pre><code class="language-yaml">- name: large-package
  version: 2.0.0
  origin_addr:
    url: https://example.com/large-package.tar.gz
  cache_addr:
    url: https://cache.example.com/large-package.tar.gz
  cache_enable: true
  local: large-package.tar.gz
</code></pre>
<h2 id="specdependsyml---依赖定义"><a class="header" href="#specdependsyml---依赖定义">spec/depends.yml - 依赖定义</a></h2>
<p><code>depends.yml</code> 定义模块依赖的其他模块或资源，支持多种依赖类型和条件依赖。</p>
<h3 id="基本格式-1"><a class="header" href="#基本格式-1">基本格式</a></h3>
<pre><code class="language-yaml">dep_root: ./depends

deps:
- addr:
    path: ./data
  local: data_resources
  enable: true
</code></pre>
<h3 id="字段说明-1"><a class="header" href="#字段说明-1">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>dep_root</code></td><td>String</td><td>是</td><td>依赖根目录</td></tr>
<tr><td><code>deps</code></td><td>Array</td><td>是</td><td>依赖列表</td></tr>
<tr><td><code>addr</code></td><td>Object</td><td>是</td><td>依赖地址配置</td></tr>
<tr><td><code>local</code></td><td>String</td><td>是</td><td>本地化名称</td></tr>
<tr><td><code>enable</code></td><td>Boolean</td><td>是</td><td>是否启用</td></tr>
</tbody></table>
</div>
<h3 id="依赖地址类型"><a class="header" href="#依赖地址类型">依赖地址类型</a></h3>
<h4 id="本地路径依赖"><a class="header" href="#本地路径依赖">本地路径依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    path: ./common_libs          # 相对路径
  local: common_libs
  enable: true

- addr:
    path: /usr/local/lib        # 绝对路径
  local: system_libs
  enable: false
</code></pre>
<h4 id="git-仓库依赖"><a class="header" href="#git-仓库依赖">Git 仓库依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/user/module.git
    tag: "1.0.0"                # 版本标签
  local: external_module
  enable: true
</code></pre>
<h4 id="条件依赖-1"><a class="header" href="#条件依赖-1">条件依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: "${ENABLE_FEATURES:false}"  # 条件启用

- addr:
    repo: https://github.com/debug/debug-tools.git
    branch: main
  local: debug_tools
  enable: "${BUILD_MODE:debug}" == "debug"
</code></pre>
<h4 id="http-url-依赖"><a class="header" href="#http-url-依赖">HTTP URL 依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    url: https://example.com/dependencies.zip
  local: external_deps
  enable: true
</code></pre>
<h2 id="varsyml---变量定义"><a class="header" href="#varsyml---变量定义">vars.yml - 变量定义</a></h2>
<p><code>vars.yml</code> 定义模块使用的环境变量和配置参数，支持类型安全和验证规则。</p>
<h3 id="基本格式-2"><a class="header" href="#基本格式-2">基本格式</a></h3>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  desp: "数据库端口号"
  value: 5432

- name: MAX_CONNECTIONS
  value: 100
</code></pre>
<h3 id="字段说明-2"><a class="header" href="#字段说明-2">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>是</td><td>变量名</td></tr>
<tr><td><code>desp</code></td><td>String</td><td>否</td><td>描述（可选）</td></tr>
<tr><td><code>value</code></td><td>String</td><td>是</td><td>默认值</td></tr>
<tr><td><code>type</code></td><td>String</td><td>否</td><td>类型（string, integer, boolean, enum）</td></tr>
<tr><td><code>min</code></td><td>Number</td><td>否</td><td>最小值（数字类型）</td></tr>
<tr><td><code>max</code></td><td>Number</td><td>否</td><td>最大值（数字类型）</td></tr>
<tr><td><code>values</code></td><td>Array</td><td>否</td><td>枚举值（枚举类型）</td></tr>
</tbody></table>
</div>
<h3 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h3>
<h4 id="字符串变量"><a class="header" href="#字符串变量">字符串变量</a></h4>
<pre><code class="language-yaml">vars:
- name: MODULE_NAME
  desp: "模块名称"
  value: postgresql

- name: DATA_DIR
  value: "/var/lib/postgresql"
</code></pre>
<h4 id="整数变量"><a class="header" href="#整数变量">整数变量</a></h4>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: MAX_CONNECTIONS
  type: integer
  min: 1
  max: 1000
  value: 100
</code></pre>
<h4 id="布尔变量"><a class="header" href="#布尔变量">布尔变量</a></h4>
<pre><code class="language-yaml">vars:
- name: ENABLE_SSL
  type: boolean
  value: false

- name: ENABLE_DEBUG
  type: boolean
  value: true
</code></pre>
<h3 id="变量引用和模板"><a class="header" href="#变量引用和模板">变量引用和模板</a></h3>
<pre><code class="language-yaml"># 支持变量间引用
vars:
- name: INSTALL_PREFIX
  value: "/usr/local"

- name: MODULE_PATH
  value: "${INSTALL_PREFIX}/{{MODULE_NAME}}"

- name: CONFIG_FILE
  value: "${MODULE_PATH}/config.conf"
</code></pre>
<h3 id="环境变量支持-1"><a class="header" href="#环境变量支持-1">环境变量支持</a></h3>
<pre><code class="language-yaml"># 支持通过环境变量覆盖默认值
vars:
- name: DATABASE_PORT
  value: "${POSTGRES_PORT:5432}"    # 默认 5432，可被 POSTGRES_PORT 环境变量覆盖

- name: INSTALL_PREFIX
  value: "${PREFIX:/usr/local}"     # 默认 /usr/local，可被 PREFIX 环境变量覆盖

- name: DEBUG_MODE
  type: boolean
  value: "${DEBUG:false}"           # 默认 false，可被 DEBUG 环境变量覆盖
</code></pre>
<h2 id="settingyml---本地化设置"><a class="header" href="#settingyml---本地化设置">setting.yml - 本地化设置</a></h2>
<p><code>setting.yml</code> 配置模板渲染和本地化行为，定义哪些文件需要模板化以及模板标记格式。</p>
<h3 id="基本格式-3"><a class="header" href="#基本格式-3">基本格式</a></h3>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - LICENSE
    - "*.log"

  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h3 id="字段说明-3"><a class="header" href="#字段说明-3">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>templatize_path</code></td><td>Object</td><td>否</td><td>模板路径配置</td></tr>
<tr><td><code>templatize_cust</code></td><td>Object</td><td>否</td><td>自定义模板标记</td></tr>
<tr><td><code>excludes</code></td><td>Array</td><td>否</td><td>排除的文件列表</td></tr>
<tr><td><code>includes</code></td><td>Array</td><td>否</td><td>包含的文件列表（优先级高于 excludes）</td></tr>
<tr><td><code>label_beg</code></td><td>String</td><td>否</td><td>模板开始标记</td></tr>
<tr><td><code>label_end</code></td><td>String</td><td>否</td><td>模板结束标记</td></tr>
</tbody></table>
</div>
<h3 id="文件选择策略"><a class="header" href="#文件选择策略">文件选择策略</a></h3>
<h4 id="排除特定文件"><a class="header" href="#排除特定文件">排除特定文件</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - CHANGELOG.md
    - "*.log"
    - "*.tmp"
</code></pre>
<h4 id="仅包含特定类型文件"><a class="header" href="#仅包含特定类型文件">仅包含特定类型文件</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    includes:
    - "*.conf"
    - "*.yml"
    - "*.yaml"
    - "templates/*"
</code></pre>
<h4 id="混合使用"><a class="header" href="#混合使用">混合使用</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    includes:
    - "*.conf"
    - "*.template"
    excludes:
    - "examples/*"
    - "test/*"
</code></pre>
<h3 id="模板标记配置"><a class="header" href="#模板标记配置">模板标记配置</a></h3>
<h4 id="默认标记jinja2-风格"><a class="header" href="#默认标记jinja2-风格">默认标记（Jinja2 风格）</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '{{'
    label_end: '}}'
</code></pre>
<h4 id="自定义标记"><a class="header" href="#自定义标记">自定义标记</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h4 id="多种标记支持"><a class="header" href="#多种标记支持">多种标记支持</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '${'
    label_end: '}'
</code></pre>
<h3 id="本地化规则"><a class="header" href="#本地化规则">本地化规则</a></h3>
<pre><code class="language-yaml"># 为不同环境配置不同的本地化规则
localize:
  # 生产环境配置
  templatize_path:
    excludes:
    - "*.dev"
    - "*.test"

  templatize_cust:
    label_beg: '{{'
    label_end: '}}'

# 开发环境配置
localize:
  templatize_path:
    includes:
    - "*.dev"
    - "config.dev/*"

  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h2 id="values_valueyml---默认值定义"><a class="header" href="#values_valueyml---默认值定义">values/_value.yml - 默认值定义</a></h2>
<p><code>_value.yml</code> 存储模块的默认配置值，为模块提供合理的默认行为。</p>
<h2 id="values_usedyml---使用的值定义"><a class="header" href="#values_usedyml---使用的值定义">values/_used.yml - 使用的值定义</a></h2>
<p><code>_used.yml</code> 记录实际使用的配置值及其来源，便于配置审计和问题排查。</p>
<h3 id="基本格式-4"><a class="header" href="#基本格式-4">基本格式</a></h3>
<pre><code class="language-yaml">SPEED_LIMIT:
  origin: mod-default
  value: 1000
  source_file: "values/_value.yml"

MODULE_NAME:
  origin: mod-default
  value: postgresql

PORT:
  origin: user-override
  value: 5433
  source_file: "user-config.yml"

MAX_CONNECTIONS:
  origin: env-override
  value: 200
  environment_var: "MAX_CONNECTIONS"
</code></pre>
<h3 id="值来源类型"><a class="header" href="#值来源类型">值来源类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>来源类型</th><th>说明</th><th>示例</th></tr></thead><tbody>
<tr><td><code>mod-default</code></td><td>模块默认值</td><td>来自 <code>values/_value.yml</code></td></tr>
<tr><td><code>user-override</code></td><td>用户覆盖值</td><td>来自用户配置文件</td></tr>
<tr><td><code>env-override</code></td><td>环境变量覆盖</td><td>来自环境变量</td></tr>
<tr><td><code>cmd-line</code></td><td>命令行参数</td><td>来自命令行选项</td></tr>
<tr><td><code>template-render</code></td><td>模板渲染结果</td><td>运行时计算值</td></tr>
</tbody></table>
</div>
<h2 id="工作流配置"><a class="header" href="#工作流配置">工作流配置</a></h2>
<h3 id="workflowsoperatorsgxl---工作流定义"><a class="header" href="#workflowsoperatorsgxl---工作流定义">workflows/operators.gxl - 工作流定义</a></h3>
<p><code>operators.gxl</code> 使用 GXL 语言定义模块的运维操作流程，包括安装、配置、启动、停止等任务。</p>
<h4 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h4>
<pre><code class="language-gxl">// 引入外部模块
extern mod mod_ops {
    git = "https://github.com/galaxy-operators/ops-gxl.git",
    channel = "${GXL_CHANNEL_OPS:main}"
}

// 定义操作符模块
mod operators : empty_operators {
    // 自动加载入口
    #[auto_load(entry)]
    flow __into {
        // 加载配置文件
        gx.read_file(
            file : "./values/_used.json",
            name : "SETTING"
        );
    }

    // 任务定义...
}
</code></pre>
<pre><code>
#### 常见任务示例

##### 安装任务
```gxl
#[task(name="gops@install")]
flow install {
    };
}
</code></pre>
<h5 id="启动任务"><a class="header" href="#启动任务">启动任务</a></h5>
<pre><code class="language-gxl">#[task(name="gops@start")]
flow start {
}
</code></pre>
<h5 id="停止任务"><a class="header" href="#停止任务">停止任务</a></h5>
<pre><code class="language-gxl">#[task(name="gops@stop")]
flow stop {
}
</code></pre>
<h2 id="mod-prjyml---项目配置"><a class="header" href="#mod-prjyml---项目配置">mod-prj.yml - 项目配置</a></h2>
<p><code>mod-prj.yml</code> 定义模块的项目级别配置，包括模块信息、构建目标和发布配置。</p>
<h3 id="基本格式-5"><a class="header" href="#基本格式-5">基本格式</a></h3>
<pre><code class="language-yaml"># 模块项目配置
name: postgresql
version: 0.1.0
description: "PostgreSQL 数据库管理模块"
maintainer: "PostgreSQL Team &lt;team@example.com&gt;"
license: "Apache-2.0"

# 测试环境配置
test_envs:
  dep_root: "./test-deps"
  deps: []





## 总结

通过合理配置这些配置文件，可以实现：

1. **标准化管理**：统一的配置结构和命名规范
2. **灵活适配**：多平台和环境支持
3. **版本控制**：完整的版本管理和依赖追踪
4. **自动化**：工作流驱动的运维操作
5. **可维护性**：清晰的配置分层和验证机制

遵循本配置指南，可以开发出高质量、可维护、可扩展的 Mod-Operator 模块。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-api-和枚举参考"><a class="header" href="#mod-operator-api-和枚举参考">Mod-Operator API 和枚举参考</a></h1>
<p>本文档提供 Mod-Operator 的 API 接口、枚举定义和数据结构参考，是开发者进行二次开发和功能扩展的重要指南。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="operator/mod/REFERENCE.html#%E6%A8%A1%E5%9D%97-api">模块 API</a></li>
<li><a href="operator/mod/REFERENCE.html#%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89">枚举定义</a></li>
<li><a href="operator/mod/REFERENCE.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="operator/mod/REFERENCE.html#%E5%B7%A5%E4%BD%9C%E6%B5%81-api">工作流 API</a></li>
<li><a href="operator/mod/REFERENCE.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">配置文件格式</a></li>
<li><a href="operator/mod/REFERENCE.html#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81">错误代码</a></li>
<li><a href="operator/mod/REFERENCE.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li>
<li><a href="operator/mod/REFERENCE.html#api-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">API 使用示例</a></li>
</ul>
<h2 id="模块-api"><a class="header" href="#模块-api">模块 API</a></h2>
<h3 id="modulespec-接口"><a class="header" href="#modulespec-接口">ModuleSpec 接口</a></h3>
<p>模块的核心数据结构，定义了模块的基本信息和支持的目标平台。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Getters)]
pub struct ModuleSpec {
    /// 模块名称
    name: String,

    /// 目标平台配置映射
    targets: IndexMap&lt;ModelSTD, ModModelSpec&gt;,

    /// 本地化路径
    local: Option&lt;PathBuf&gt;,
}

impl ModuleSpec {
    /// 创建新模块
    pub fn init&lt;S: Into&lt;String&gt;&gt;(name: S, target_vec: Vec&lt;ModModelSpec&gt;) -&gt; Self

    /// 清理其他平台配置
    pub fn clean_other(&amp;mut self, node: &amp;ModelSTD) -&gt; MainResult&lt;()&gt;

    /// 保存主要配置
    pub fn save_main(&amp;self, path: &amp;Path, name: Option&lt;String&gt;) -&gt; MainResult&lt;()&gt;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="方法详解"><a class="header" href="#方法详解">方法详解</a></h4>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>参数</th><th>返回值</th><th>说明</th></tr></thead><tbody>
<tr><td><code>init</code></td><td><code>name: String</code>, <code>target_vec: Vec&lt;ModModelSpec&gt;</code></td><td><code>ModuleSpec</code></td><td>创建新的模块实例</td></tr>
<tr><td><code>clean_other</code></td><td><code>node: &amp;ModelSTD</code></td><td><code>MainResult&lt;()&gt;</code></td><td>清理指定平台外的其他平台配置</td></tr>
<tr><td><code>save_main</code></td><td><code>path: &amp;Path</code>, <code>name: Option&lt;String&gt;</code></td><td><code>MainResult&lt;()&gt;</code></td><td>保存模块主要配置文件</td></tr>
</tbody></table>
</div>
<h4 id="使用示例-1"><a class="header" href="#使用示例-1">使用示例</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建模块
let targets = vec![
    ModModelSpec::init(
        ModelSTD::x86_ubt22_k8s(),
        ArtifactPackage::default(),
        ModWorkflows::mod_k8s_tpl_init(),
        GxlProject::spec_k8s_tpl(),
        VarCollection::default(),
        None,
    ),
    ModModelSpec::init(
        ModelSTD::arm_mac14_host(),
        ArtifactPackage::default(),
        ModWorkflows::mod_host_tpl_init(),
        GxlProject::spec_host_tpl(),
        VarCollection::default(),
        None,
    ),
];

let module_spec = ModuleSpec::init("postgresql", targets);

// 清理其他平台
module_spec.clean_other(&amp;ModelSTD::x86_ubt22_k8s());
<span class="boring">}</span></code></pre></pre>
<h3 id="modmodelspec-接口"><a class="header" href="#modmodelspec-接口">ModModelSpec 接口</a></h3>
<p>模型规格定义，包含模块的具体实现配置。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Getters)]
pub struct ModModelSpec {
    /// 模型标准
    model: ModelSTD,

    /// 构件包定义
    artifact_pkg: ArtifactPackage,

    /// 工作流定义
    workflows: ModWorkflows,

    /// GXL 项目配置
    prj: GxlProject,

    /// 变量集合
    vars: VarCollection,

    /// 设置配置
    setting: Option&lt;Setting&gt;,
}

impl ModModelSpec {
    /// 创建新的模型规格
    pub fn init(
        model: ModelSTD,
        artifact_pkg: ArtifactPackage,
        workflows: ModWorkflows,
        prj: GxlProject,
        vars: VarCollection,
        setting: Option&lt;Setting&gt;,
    ) -&gt; Self

    /// 更新本地配置
    pub async fn update_local(
        &amp;self,
        accessor: Accessor,
        path: &amp;Path,
        options: &amp;DownloadOptions,
    ) -&gt; MainResult&lt;UpdateUnit&gt;

    /// 本地化处理
    pub async fn localize(
        &amp;self,
        dst_path: Option&lt;ValuePath&gt;,
        options: LocalizeOptions,
    ) -&gt; MainResult&lt;()&gt;

    /// 保存配置
    pub fn save_to(&amp;self, path: &amp;Path, name: Option&lt;String&gt;) -&gt; SerdeResult&lt;()&gt;

    /// 从文件加载
    pub fn load_from(path: &amp;Path) -&gt; SerdeResult&lt;Self&gt;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="主要方法"><a class="header" href="#主要方法">主要方法</a></h4>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td><code>init</code></td><td><code>model</code>, <code>artifact_pkg</code>, <code>workflows</code>, <code>prj</code>, <code>vars</code>, <code>setting</code></td><td>创建模型规格实例</td></tr>
<tr><td><code>update_local</code></td><td><code>accessor</code>, <code>path</code>, <code>options</code></td><td>更新本地构件配置</td></tr>
<tr><td><code>localize</code></td><td><code>dst_path</code>, <code>options</code></td><td>执行本地化处理</td></tr>
<tr><td><code>save_to</code></td><td><code>path</code>, <code>name</code></td><td>保存配置到文件</td></tr>
<tr><td><code>load_from</code></td><td><code>path</code></td><td>从文件加载配置</td></tr>
</tbody></table>
</div>
<h2 id="枚举定义"><a class="header" href="#枚举定义">枚举定义</a></h2>
<h3 id="modelstd-标准型号-1"><a class="header" href="#modelstd-标准型号-1">ModelSTD 标准型号</a></h3>
<p>模型标准定义，包含 CPU 架构、操作系统和运行环境。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// CPU 架构枚举
pub enum CpuArch {
    /// x86_64 架构
    X86,
    /// ARM 架构
    Arm,
}

/// 操作系统枚举
pub enum OsCPE {
    /// macOS 14+
    MAC14,
    /// Windows 10+
    WIN10,
    /// Ubuntu 22.04
    UBT22,
    /// CentOS 7
    COS7,
}

/// 运行环境枚举
pub enum RunSPC {
    /// 宿主机环境
    Host,
    /// Kubernetes 环境
    K8S,
}

/// 模型标准结构
#[derive(Debug, Clone, PartialEq, Eq, Hash, Getters)]
pub struct ModelSTD {
    /// CPU 架构
    arch: CpuArch,
    /// 操作系统
    os: OsCPE,
    /// 运行环境
    spc: RunSPC,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="常用预定义实例"><a class="header" href="#常用预定义实例">常用预定义实例</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 主流平台组合
impl ModelSTD {
    /// x86 + Ubuntu 22.04 + Kubernetes
    pub fn x86_ubt22_k8s() -&gt; Self

    /// x86 + Ubuntu 22.04 + Host
    pub fn x86_ubt22_host() -&gt; Self

    /// ARM + macOS 14 + Host
    pub fn arm_mac14_host() -&gt; Self

    /// ARM + Ubuntu 22.04 + Host
    pub fn arm_ubt22_host() -&gt; Self
}
<span class="boring">}</span></code></pre></pre>
<h3 id="artifact-枚举"><a class="header" href="#artifact-枚举">Artifact 枚举</a></h3>
<p>构件类型和状态枚举。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 构件类型
pub enum ArtifactType {
    /// HTTP/HTTPS 下载
    Http,
    /// Git 仓库
    Git,
    /// 本地文件
    Local,
    /// 容器镜像
    Container,
}

/// 构件状态
pub enum ArtifactStatus {
    /// 待下载
    Pending,
    /// 下载中
    Downloading,
    /// 已下载
    Downloaded,
    /// 解压中
    Extracting,
    /// 已解压
    Extracted,
    /// 已安装
    Installed,
    /// 错误
    Error,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="枚举比较和转换"><a class="header" href="#枚举比较和转换">枚举比较和转换</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 枚举比较
impl PartialEq for CpuArch {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (CpuArch::X86, CpuArch::X86) =&gt; true,
            (CpuArch::Arm, CpuArch::Arm) =&gt; true,
            _ =&gt; false,
        }
    }
}

// 枚举转字符串
impl ToString for CpuArch {
    fn to_string(&amp;self) -&gt; String {
        match self {
            CpuArch::X86 =&gt; "x86".to_string(),
            CpuArch::Arm =&gt; "arm".to_string(),
        }
    }
}

// 字符串转枚举
impl FromStr for CpuArch {
    type Err = ParseError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.to_lowercase().as_str() {
            "x86" | "x86_64" | "amd64" =&gt; Ok(CpuArch::X86),
            "arm" | "aarch64" =&gt; Ok(CpuArch::Arm),
            _ =&gt; Err(ParseError::InvalidCpuArch(s.to_string())),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h2>
<h3 id="artifactpackage-构件包"><a class="header" href="#artifactpackage-构件包">ArtifactPackage 构件包</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct ArtifactPackage {
    /// 构件列表
    artifacts: Vec&lt;Artifact&gt;,
}

impl ArtifactPackage {
    /// 创建默认构件包
    pub fn default() -&gt; Self

    /// 从构件列表创建
    pub fn from(artifacts: Vec&lt;Artifact&gt;) -&gt; Self

    /// 获取所有构件
    pub fn artifacts(&amp;self) -&gt; &amp;Vec&lt;Artifact&gt;

    /// 添加构件
    pub fn add_artifact(&amp;mut self, artifact: Artifact)

    /// 移除构件
    pub fn remove_artifact(&amp;mut self, name: &amp;str) -&gt; Option&lt;Artifact&gt;

    /// 查找构件
    pub fn find_artifact(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Artifact&gt;

    /// 验证构件包
    pub fn validate(&amp;self) -&gt; Result&lt;(), ValidationError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="varcollection-变量集合"><a class="header" href="#varcollection-变量集合">VarCollection 变量集合</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct VarCollection {
    /// 变量定义列表
    vars: Vec&lt;VarDefinition&gt;,
}

impl VarCollection {
    /// 定义变量
    pub fn define(vars: Vec&lt;VarDefinition&gt;) -&gt; Self

    /// 添加变量
    pub fn add_var(&amp;mut self, var: VarDefinition)

    /// 获取变量
    pub fn get_var(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;VarDefinition&gt;

    /// 设置变量值
    pub fn set_value(&amp;mut self, name: &amp;str, value: String) -&gt; Result&lt;(), VarError&gt;

    /// 解析变量值
    pub fn resolve_value(&amp;self, name: &amp;str, context: &amp;Context) -&gt; Result&lt;String, VarError&gt;

    /// 验证变量
    pub fn validate(&amp;self) -&gt; Result&lt;(), VarError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gxlproject-gxl-项目"><a class="header" href="#gxlproject-gxl-项目">GxlProject GXL 项目</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct GxlProject {
    /// 项目名称
    name: String,

    /// 工作流定义
    workflows: HashMap&lt;String, GxlWorkflow&gt;,

    /// 项目配置
    config: HashMap&lt;String, Value&gt;,
}

impl GxlProject {
    /// 创建项目配置模板
    pub fn spec_k8s_tpl() -&gt; Self

    /// 创建主机配置模板
    pub fn spec_host_tpl() -&gt; Self

    /// 添加工作流
    pub fn add_workflow(&amp;mut self, name: String, workflow: GxlWorkflow)

    /// 获取工作流
    pub fn get_workflow(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;GxlWorkflow&gt;

    /// 执行工作流
    pub async fn execute_workflow(
        &amp;self,
        name: &amp;str,
        context: &amp;Context,
    ) -&gt; Result&lt;WorkflowResult, WorkflowError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="工作流-api"><a class="header" href="#工作流-api">工作流 API</a></h2>
<h3 id="gxlworkflow-gxl-工作流"><a class="header" href="#gxlworkflow-gxl-工作流">GxlWorkflow GXL 工作流</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GxlWorkflow {
    /// 工作流名称
    name: String,

    /// 工作流描述
    description: Option&lt;String&gt;,

    /// 任务列表
    tasks: Vec&lt;GxlTask&gt;,

    /// 变量定义
    variables: HashMap&lt;String, GxlVariable&gt;,

    /// 条件分支
    conditions: Vec&lt;GxlCondition&gt;,

    /// 错误处理
    error_handler: Option&lt;GxlErrorHandler&gt;,
}

impl GxlWorkflow {
    /// 创建工作流
    pub fn new(name: String) -&gt; Self

    /// 添加任务
    pub fn add_task(&amp;mut self, task: GxlTask)

    /// 添加条件分支
    pub fn add_condition(&amp;mut self, condition: GxlCondition)

    /// 设置错误处理器
    pub fn set_error_handler(&amp;mut self, handler: GxlErrorHandler)

    /// 验证工作流
    pub fn validate(&amp;self) -&gt; Result&lt;(), WorkflowError&gt;

    /// 执行工作流
    pub async fn execute(&amp;self, context: &amp;mut Context) -&gt; Result&lt;WorkflowResult, WorkflowError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gxltask-gxl-任务"><a class="header" href="#gxltask-gxl-任务">GxlTask GXL 任务</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GxlTask {
    /// 命令任务
    Command(GxlCommandTask),

    /// 脚本任务
    Script(GxlScriptTask),

    /// 模板渲染任务
    Template(GxlTemplateTask),

    /// 下载任务
    Download(GxlDownloadTask),

    /// 并行任务
    Parallel(GxlParallelTask),

    /// 条件任务
    Conditional(GxlConditionalTask),

    /// 循环任务
    Loop(GxlLoopTask),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="任务执行上下文"><a class="header" href="#任务执行上下文">任务执行上下文</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct Context {
    /// 变量存储
    variables: HashMap&lt;String, Value&gt;,

    /// 工作目录
    working_dir: PathBuf,

    /// 执行状态
    status: ExecutionStatus,

    /// 错误收集
    errors: Vec&lt;ExecutionError&gt;,

    /// 日志输出
    logs: Vec&lt;LogEntry&gt;,
}

impl Context {
    /// 创建新上下文
    pub fn new() -&gt; Self

    /// 设置变量
    pub fn set_var(&amp;mut self, name: String, value: Value)

    /// 获取变量
    pub fn get_var(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Value&gt;

    /// 执行命令
    pub async fn execute_command(&amp;mut self, cmd: &amp;str) -&gt; Result&lt;CommandResult, CommandError&gt;

    /// 添加日志
    pub fn add_log(&amp;mut self, level: LogLevel, message: String)

    /// 保存状态
    pub fn save_state(&amp;self) -&gt; Result&lt;StateSnapshot, StateError&gt;

    /// 恢复状态
    pub fn restore_state(&amp;mut self, state: &amp;StateSnapshot) -&gt; Result&lt;(), StateError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="配置文件格式"><a class="header" href="#配置文件格式">配置文件格式</a></h2>
<h3 id="yaml-配置验证"><a class="header" href="#yaml-配置验证">YAML 配置验证</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 配置验证器
pub struct ConfigValidator;

impl ConfigValidator {
    /// 验证 artifact.yml
    pub fn validate_artifact(yaml_content: &amp;str) -&gt; Result&lt;Vec&lt;Artifact&gt;, ConfigError&gt;

    /// 验证 depends.yml
    pub fn validate_depends(yaml_content: &amp;str) -&gt; Result&lt;DependsConfig, ConfigError&gt;

    /// 验证 vars.yml
    pub fn validate_vars(yaml_content: &amp;str) -&gt; Result&lt;VarCollection, ConfigError&gt;

    /// 验证 setting.yml
    pub fn validate_setting(yaml_content: &amp;str) -&gt; Result&lt;Setting, ConfigError&gt;

    /// 验证 mod-prj.yml
    pub fn validate_project(yaml_content: &amp;str) -&gt; Result&lt;ProjectConfig, ConfigError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="配置生成器"><a class="header" href="#配置生成器">配置生成器</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 配置文件生成器
pub struct ConfigGenerator;

impl ConfigGenerator {
    /// 生成 artifact.yml
    pub fn generate_artifact(artifacts: &amp;[Artifact]) -&gt; String

    /// 生成 depends.yml
    pub fn generate_depends(deps: &amp;[Dependency]) -&gt; String

    /// 生成 vars.yml
    pub fn generate_vars(vars: &amp;[VarDefinition]) -&gt; String

    /// 生成 setting.yml
    pub fn generate_setting(setting: &amp;Setting) -&gt; String

    /// 生成 mod-prj.yml
    pub fn generate_project(project: &amp;ProjectConfig) -&gt; String
}
<span class="boring">}</span></code></pre></pre>
<h2 id="错误代码"><a class="header" href="#错误代码">错误代码</a></h2>
<h3 id="错误类型定义"><a class="header" href="#错误类型定义">错误类型定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 系统错误
#[derive(Debug, Error)]
pub enum SystemError {
    #[error("配置解析错误: {0}")]
    ConfigParse(String),

    #[error("文件操作错误: {0}")]
    FileOperation(String),

    #[error("网络错误: {0}")]
    Network(String),

    #[error("进程错误: {0}")]
    Process(String),

    #[error("权限错误: {0}")]
    Permission(String),

    #[error("资源不足: {0}")]
    Resource(String),
}

/// 业务错误
#[derive(Debug, Error)]
pub enum BusinessError {
    #[error("模块不存在: {0}")]
    ModuleNotFound(String),

    #[error("任务执行失败: {0}")]
    TaskFailed(String),

    #[error("验证失败: {0}")]
    ValidationFailed(String),

    #[error("状态错误: {0}")]
    InvalidState(String),

    #[error("依赖冲突: {0}")]
    DependencyConflict(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="错误处理模式"><a class="header" href="#错误处理模式">错误处理模式</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 错误处理结果
pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;

/// 错误处理工具
pub struct ErrorHandler;

impl ErrorHandler {
    /// 记录错误
    pub fn log_error(error: &amp;Error) {
        // 记录错误日志
    }

    /// 错误恢复
    pub fn recover(context: &amp;mut Context, error: &amp;Error) -&gt; Result&lt;()&gt; {
        // 执行错误恢复操作
        Ok(())
    }

    /// 错误通知
    pub fn notify(error: &amp;Error) -&gt; Result&lt;()&gt; {
        // 发送错误通知
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="环境变量-5"><a class="header" href="#环境变量-5">环境变量</a></h2>
<h2 id="api-使用示例"><a class="header" href="#api-使用示例">API 使用示例</a></h2>
<h3 id="创建自定义模块"><a class="header" href="#创建自定义模块">创建自定义模块</a></h3>
<pre><pre class="playground"><code class="language-rust">use galaxy_ops::{
    artifact::{Artifact, ArtifactPackage},
    model::{ModelSTD, CpuArch, OsCPE, RunSPC},
    module::ModuleSpec,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 定义目标平台
    let target_platforms = vec![
        ModelSTD::x86_ubt22_k8s(),
        ModelSTD::arm_mac14_host(),
    ];

    // 创建构件包
    let artifacts = vec![
        Artifact::new(
            "nginx",
            "1.25.3",
            "https://nginx.org/download/nginx-1.25.3.tar.gz".parse()?,
            "nginx-1.25.3.tar.gz",
        ),
        Artifact::new(
            "openssl",
            "3.0.0",
            "https://github.com/openssl/openssl.git".parse()?,
            "openssl-3.0.0",
        ),
    ];

    let artifact_pkg = ArtifactPackage::from(artifacts);

    // 为每个平台创建模型规格
    let mut target_specs = Vec::new();
    for platform in target_platforms {
        let model_spec = ModModelSpec::init(
            platform.clone(),
            artifact_pkg.clone(),
            ModWorkflows::mod_k8s_tpl_init(),
            GxlProject::spec_k8s_tpl(),
            VarCollection::define(vec![
                VarDefinition::new("MODULE_NAME", "nginx"),
                VarDefinition::new("VERSION", "1.25.3"),
            ]),
            None,
        );

        target_specs.push(model_spec);
    }

    // 创建模块规格
    let module_spec = ModuleSpec::init("nginx-server", target_specs);

    // 保存模块配置
    module_spec.save_main(&amp;std::path::Path::new("./nginx"), Some("nginx".to_string()))?;

    println!("自定义模块创建成功");
    Ok(())
}</code></pre></pre>
<h3 id="错误处理示例"><a class="header" href="#错误处理示例">错误处理示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use galaxy_ops::{error::{SystemError, BusinessError}, workflow::Context};

fn handle_error(context: &amp;mut Context, error: &amp;dyn std::error::Error) {
    match error.downcast_ref::&lt;SystemError&gt;() {
        Some(sys_error) =&gt; {
            match sys_error {
                SystemError::ConfigParse(msg) =&gt; {
                    eprintln!("配置解析错误: {}", msg);
                    // 执行配置错误恢复
                    ConfigErrorHandler::recover(context, msg);
                }
                SystemError::FileOperation(msg) =&gt; {
                    eprintln!("文件操作错误: {}", msg);
                    // 执行文件错误恢复
                    FileErrorHandler::recover(context, msg);
                }
                SystemError::Network(msg) =&gt; {
                    eprintln!("网络错误: {}", msg);
                    // 执行网络错误恢复
                    NetworkErrorHandler::recover(context, msg);
                }
                _ =&gt; {
                    eprintln!("未知系统错误: {}", msg);
                }
            }
        }
        None =&gt; {
            match error.downcast_ref::&lt;BusinessError&gt;() {
                Some(biz_error) =&gt; {
                    match biz_error {
                        BusinessError::ModuleNotFound(msg) =&gt; {
                            eprintln!("模块不存在: {}", msg);
                            ModuleErrorHandler::recover(context, msg);
                        }
                        BusinessError::TaskFailed(msg) =&gt; {
                            eprintln!("任务执行失败: {}", msg);
                            TaskErrorHandler::recover(context, msg);
                        }
                        BusinessError::ValidationFailed(msg) =&gt; {
                            eprintln!("验证失败: {}", msg);
                            ValidationErrorHandler::recover(context, msg);
                        }
                        _ =&gt; {
                            eprintln!("未知业务错误: {}", msg);
                        }
                    }
                }
                None =&gt; {
                    eprintln!("未分类错误: {}", error);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="总结-7"><a class="header" href="#总结-7">总结</a></h2>
<p>本 API 参考文档提供了 Mod-Operator 框架的完整接口和功能说明，包括：</p>
<ol>
<li><strong>模块管理 API</strong> - 用于创建和管理模块实例</li>
<li><strong>枚举定义</strong> - 标准化的平台和类型定义</li>
<li><strong>数据结构</strong> - 核心配置和数据类型</li>
<li><strong>工作流 API</strong> - 任务执行和流程控制</li>
<li><strong>配置处理</strong> - 配置文件的验证和生成</li>
<li><strong>错误处理</strong> - 完善的错误处理机制</li>
<li><strong>环境变量</strong> - 系统和用户配置变量</li>
<li><strong>实用示例</strong> - 常见场景的实现示例</li>
</ol>
<p>通过这些 API，开发者可以：</p>
<ul>
<li>创建自定义模块类型</li>
<li>扩展工作流功能</li>
<li>自定义配置验证</li>
<li>实现高级监控功能</li>
<li>集成第三方系统</li>
</ul>
<p>建议开发者在使用前仔细阅读相关章节，并根据实际需求选择合适的 API 接口。</p>
<h2 id="相关资源-1"><a class="header" href="#相关资源-1">相关资源</a></h2>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./DEVELOPMENT.html">开发指南</a> - 开发工作流和最佳实践</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>🛠️ <a href="operator/mod/../gmod/">gmod 工具文档</a> - 模块管理工具使用指南</li>
<li>🛠️ <a href="operator/mod/../gflow/">gflow 工具文档</a> - 工作流执行工具使用指南</li>
</ul>
<hr />
<p><em>本文档会根据框架发展持续更新，请关注最新版本。如需帮助，请参考示例代码或提交 Issue。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-故障排除指南"><a class="header" href="#mod-operator-故障排除指南">Mod-Operator 故障排除指南</a></h1>
<p>本文档提供 Mod-Operator 常见问题的诊断步骤、解决方案和调试技巧，帮助开发者快速定位和解决问题。</p>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<ul>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD">常见问题诊断</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%92%8C%E6%96%B9%E6%B3%95">调试工具和方法</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">错误代码解析</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">性能问题分析</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE">最佳实践建议</a></li>
</ul>
<h2 id="常见问题诊断-1"><a class="header" href="#常见问题诊断-1">常见问题诊断</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-netaccessctrl-简约配置指南非开发者版"><a class="header" href="#-netaccessctrl-简约配置指南非开发者版">📖 NetAccessCtrl 简约配置指南（非开发者版）</a></h1>
<h2 id="什么是-netaccessctrl"><a class="header" href="#什么是-netaccessctrl">什么是 NetAccessCtrl？</a></h2>
<p>NetAccessCtrl 是一个网络访问控制模块，可以在使用orino_variate 时自动将您的网络请求重定向到更快的镜像服务器，支持认证、超时设置和代理配置。它可以帮助您：</p>
<ul>
<li>🚀 加速 GitHub、GitLab 等国外服务访问</li>
<li>🔐 安全管理认证信息</li>
<li>⏱️ 控制网络请求超时时间</li>
<li>🌐 配置代理服务器</li>
<li>📝 使用环境变量动态配置</li>
</ul>
<h2 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h2>
<h3 id="1-创建配置文件"><a class="header" href="#1-创建配置文件">1. 创建配置文件</a></h3>
<p>在您的项目根目录创建 <code>net-accessor_ctrl.yaml</code> 文件：</p>
<pre><code class="language-yaml"># 基础配置示例
enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror.ghproxy.com/"
    # 可选：添加认证信息
    auth:
      username: "your_username"
      password: "your_token"
</code></pre>
<h3 id="2-常用场景配置"><a class="header" href="#2-常用场景配置">2. 常用场景配置</a></h3>
<h4 id="github-加速访问"><a class="header" href="#github-加速访问">GitHub 加速访问</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror.ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
</code></pre>
<h4 id="gitlab-镜像"><a class="header" href="#gitlab-镜像">GitLab 镜像</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://gitlab.com/*"
        target: "https://gitlab-mirror.com/"
</code></pre>
<h4 id="npm-包管理器加速"><a class="header" href="#npm-包管理器加速">NPM 包管理器加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://registry.npmjs.org/*"
        target: "https://registry.npmmirror.com/"
</code></pre>
<h3 id="3-完整配置示例"><a class="header" href="#3-完整配置示例">3. 完整配置示例</a></h3>
<pre><code class="language-yaml">enable: true
units:
  # GitHub 配置
  - rules:
      - pattern: "https://github.com/*"
        target: "https://ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
    auth:
      username: "${GITHUB_USER}"
      password: "${GITHUB_TOKEN}"
    timeout:
      connect-timeout: 30
      read-timeout: 60
      total-timeout: 300
    proxy:
      url: "http://proxy.company.com:8080"

  # 其他服务配置
  - rules:
      - pattern: "https://api.example.com/*"
        target: "https://internal-api.example.com/"
</code></pre>
<h2 id="配置参数说明"><a class="header" href="#配置参数说明">配置参数说明</a></h2>
<h3 id="基本参数"><a class="header" href="#基本参数">基本参数</a></h3>
<ul>
<li><code>enable</code>: <code>true</code> 或 <code>false</code>，是否启用网络访问控制</li>
<li><code>units</code>: 配置单元列表，每个单元包含重定向规则和配置</li>
</ul>
<h3 id="单元配置-units"><a class="header" href="#单元配置-units">单元配置 (units)</a></h3>
<p>每个 <code>unit</code> 包含：</p>
<ul>
<li><code>rules</code>: 重定向规则列表</li>
<li><code>auth</code>: 可选的认证信息（用户名和密码）</li>
<li><code>timeout</code>: 可选的超时设置</li>
<li><code>proxy</code>: 可选的代理配置</li>
</ul>
<h3 id="规则配置-rules"><a class="header" href="#规则配置-rules">规则配置 (rules)</a></h3>
<p>每个 <code>rule</code> 包含：</p>
<ul>
<li><code>pattern</code>: 要匹配的URL模式（支持 <code>*</code> 通配符）</li>
<li><code>target</code>: 重定向的目标地址</li>
</ul>
<h3 id="环境变量支持-2"><a class="header" href="#环境变量支持-2">环境变量支持</a></h3>
<p>您可以使用环境变量来动态配置，避免硬编码敏感信息：</p>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://${GITHUB_DOMAIN:github.com}/*"
        target: "https://${MIRROR_DOMAIN:ghproxy.com}/"
    auth:
      username: "${GITHUB_USER}"
      password: "${GITHUB_TOKEN}"
    proxy:
      url: "${PROXY_URL:http://proxy.default:8080}"
</code></pre>
<p>环境变量语法：</p>
<ul>
<li><code>${VARIABLE_NAME}</code>: 使用环境变量</li>
<li><code>${VARIABLE_NAME:default_value}</code>: 使用环境变量，如果不存在则使用默认值</li>
</ul>
<h2 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h2>
<h3 id="1-设置环境变量可选"><a class="header" href="#1-设置环境变量可选">1. 设置环境变量（可选）</a></h3>
<pre><code class="language-bash"># Linux/Mac
export GITHUB_USER="your_username"
export GITHUB_TOKEN="your_token"
export PROXY_URL="http://proxy.company.com:8080"

# Windows
set GITHUB_USER=your_username
set GITHUB_TOKEN=your_token
set PROXY_URL=http://proxy.company.com:8080
</code></pre>
<h3 id="2-将配置文件放在正确位置"><a class="header" href="#2-将配置文件放在正确位置">2. 将配置文件放在正确位置</a></h3>
<ul>
<li>系统级配置：<code>/etc/net-access.yaml</code></li>
<li>用户级配置：<code>~/.config/net-access.yaml</code></li>
<li>项目级配置：<code>项目根目录/net-access.yaml</code></li>
</ul>
<h3 id="3-验证配置"><a class="header" href="#3-验证配置">3. 验证配置</a></h3>
<p>配置完成后，您可以通过以下方式验证是否生效：</p>
<pre><code class="language-bash"># 测试 GitHub 访问
curl -I "https://github.com/user/repo/releases"

# 查看是否重定向到镜像服务器
</code></pre>
<h2 id="常见问题-6"><a class="header" href="#常见问题-6">常见问题</a></h2>
<h3 id="q-如何添加多个镜像服务器"><a class="header" href="#q-如何添加多个镜像服务器">Q: 如何添加多个镜像服务器？</a></h3>
<p>A: 在 <code>units</code> 中添加多个配置单元，系统会按顺序尝试：</p>
<pre><code class="language-yaml">enable: true
units:
  # 第一个镜像
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror1.github.com/"

  # 备用镜像
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror2.github.com/"
</code></pre>
<h3 id="q-如何设置不同的超时时间"><a class="header" href="#q-如何设置不同的超时时间">Q: 如何设置不同的超时时间？</a></h3>
<p>A: 在 <code>timeout</code> 部分配置：</p>
<pre><code class="language-yaml">timeout:
  connect-timeout: 30    # 连接超时（秒）
  read-timeout: 60       # 读取超时（秒）
  total-timeout: 300     # 总超时（秒）
</code></pre>
<h3 id="q-如何处理认证"><a class="header" href="#q-如何处理认证">Q: 如何处理认证？</a></h3>
<p>A: 在 <code>auth</code> 部分配置用户名和密码，推荐使用环境变量：</p>
<pre><code class="language-yaml">auth:
  username: "${YOUR_USERNAME}"
  password: "${YOUR_PASSWORD}"
</code></pre>
<h3 id="q-配置不生效怎么办"><a class="header" href="#q-配置不生效怎么办">Q: 配置不生效怎么办？</a></h3>
<p>A: 检查以下几点：</p>
<ol>
<li>确保 <code>enable: true</code></li>
<li>检查配置文件路径是否正确</li>
<li>验证 YAML 语法是否正确</li>
<li>检查 URL 模式是否匹配</li>
</ol>
<h3 id="q-如何配置代理"><a class="header" href="#q-如何配置代理">Q: 如何配置代理？</a></h3>
<p>A: 在 <code>proxy</code> 部分配置：</p>
<pre><code class="language-yaml">proxy:
  url: "http://proxy.example.com:8080"
</code></pre>
<h3 id="q-支持哪些通配符"><a class="header" href="#q-支持哪些通配符">Q: 支持哪些通配符？</a></h3>
<p>A: 目前支持 <code>*</code> 通配符，可以匹配任意字符序列。例如：</p>
<ul>
<li><code>https://github.com/*</code> 匹配所有 GitHub 地址</li>
<li><code>https://raw.githubusercontent.com/*</code> 匹配所有 GitHub 原始文件地址</li>
</ul>
<h2 id="配置示例合集"><a class="header" href="#配置示例合集">配置示例合集</a></h2>
<h3 id="常用镜像服务"><a class="header" href="#常用镜像服务">常用镜像服务</a></h3>
<h4 id="github-全家桶加速"><a class="header" href="#github-全家桶加速">GitHub 全家桶加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
      - pattern: "https://gist.github.com/*"
        target: "https://gist.ghproxy.com/"
</code></pre>
<h4 id="python-包管理器-pypi"><a class="header" href="#python-包管理器-pypi">Python 包管理器 (PyPI)</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://pypi.org/*"
        target: "https://pypi.doubanio.com/"
</code></pre>
<h4 id="docker-镜像加速"><a class="header" href="#docker-镜像加速">Docker 镜像加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://registry-1.docker.io/*"
        target: "https://dockerhub.azk8s.cn/"
</code></pre>
<h4 id="rubygems-加速"><a class="header" href="#rubygems-加速">RubyGems 加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://rubygems.org/*"
        target: "https://gems.ruby-china.com/"
</code></pre>
<h3 id="企业内部配置"><a class="header" href="#企业内部配置">企业内部配置</a></h3>
<h4 id="内部服务映射"><a class="header" href="#内部服务映射">内部服务映射</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://external-api.company.com/*"
        target: "https://internal-api.company.com/"
    auth:
      username: "${INTERNAL_API_USER}"
      password: "${INTERNAL_API_PASSWORD}"
    timeout:
      connect-timeout: 10
      read-timeout: 30
      total-timeout: 60
</code></pre>
<h4 id="多环境配置"><a class="header" href="#多环境配置">多环境配置</a></h4>
<pre><code class="language-yaml"># 开发环境配置
enable: ${ENABLE_NET_ACCESS:true}
units:
  - rules:
      - pattern: "https://api.${ENV:dev}.company.com/*"
        target: "http://localhost:8080/"
    timeout:
      connect-timeout: 5
      read-timeout: 15
      total-timeout: 30
</code></pre>
<h2 id="故障排除-6"><a class="header" href="#故障排除-6">故障排除</a></h2>
<h3 id="检查配置文件语法"><a class="header" href="#检查配置文件语法">检查配置文件语法</a></h3>
<p>使用在线 YAML 验证工具检查配置文件语法：</p>
<ol>
<li>访问 https://www.yamllint.com/</li>
<li>粘贴您的配置文件内容</li>
<li>检查是否有语法错误</li>
</ol>
<h3 id="常见错误及解决方案"><a class="header" href="#常见错误及解决方案">常见错误及解决方案</a></h3>
<h4 id="1-配置文件不生效"><a class="header" href="#1-配置文件不生效">1. 配置文件不生效</a></h4>
<p><strong>症状</strong>: 配置修改后没有效果
<strong>解决方案</strong>:</p>
<ul>
<li>检查配置文件路径是否正确</li>
<li>确认 <code>enable: true</code></li>
<li>重启应用程序</li>
<li>检查文件权限</li>
</ul>
<h4 id="2-环境变量未生效"><a class="header" href="#2-环境变量未生效">2. 环境变量未生效</a></h4>
<p><strong>症状</strong>: 环境变量没有正确替换
<strong>解决方案</strong>:</p>
<ul>
<li>确认环境变量已正确设置</li>
<li>检查环境变量名称是否正确</li>
<li>使用 <code>echo $VARIABLE_NAME</code> 验证环境变量</li>
<li>重新启动终端或应用程序</li>
</ul>
<h4 id="3-网络连接超时"><a class="header" href="#3-网络连接超时">3. 网络连接超时</a></h4>
<p><strong>症状</strong>: 请求经常超时
<strong>解决方案</strong>:</p>
<ul>
<li>增加 <code>timeout</code> 配置中的时间值</li>
<li>检查网络连接状态</li>
<li>尝试更换镜像服务器</li>
</ul>
<h4 id="4-认证失败"><a class="header" href="#4-认证失败">4. 认证失败</a></h4>
<p><strong>症状</strong>: 401 或 403 错误
<strong>解决方案</strong>:</p>
<ul>
<li>检查用户名和密码是否正确</li>
<li>确认认证信息是否有权限访问目标服务</li>
<li>检查 token 是否已过期</li>
</ul>
<h3 id="调试技巧-2"><a class="header" href="#调试技巧-2">调试技巧</a></h3>
<h4 id="启用详细日志"><a class="header" href="#启用详细日志">启用详细日志</a></h4>
<p>如果应用程序支持日志，可以启用详细日志来查看重定向过程：</p>
<pre><code class="language-bash"># 示例：启用调试日志
export RUST_LOG=debug
your_application
</code></pre>
<h4 id="手动测试重定向"><a class="header" href="#手动测试重定向">手动测试重定向</a></h4>
<p>使用 <code>curl</code> 命令手动测试重定向是否工作：</p>
<pre><code class="language-bash"># 测试重定向
curl -v "https://github.com/user/repo"

# 查看是否被重定向到镜像服务器
</code></pre>
<h4 id="检查配置加载"><a class="header" href="#检查配置加载">检查配置加载</a></h4>
<p>如果可能，查看应用程序启动时的日志，确认配置文件是否正确加载。</p>
<h2 id="最佳实践-11"><a class="header" href="#最佳实践-11">最佳实践</a></h2>
<h3 id="安全性建议"><a class="header" href="#安全性建议">安全性建议</a></h3>
<ol>
<li><strong>使用环境变量</strong>: 避免在配置文件中硬编码敏感信息</li>
<li><strong>设置文件权限</strong>: 确保配置文件只有授权用户可读
<pre><code class="language-bash">chmod 600 net-access.yaml
</code></pre>
</li>
<li><strong>定期更新认证信息</strong>: 定期更换密码和访问令牌</li>
<li><strong>使用 HTTPS</strong>: 确保所有目标地址使用 HTTPS 协议</li>
</ol>
<h3 id="性能优化建议"><a class="header" href="#性能优化建议">性能优化建议</a></h3>
<ol>
<li><strong>规则排序</strong>: 将最常用的规则放在前面</li>
<li><strong>合理设置超时</strong>: 根据网络环境调整超时时间</li>
<li><strong>使用就近镜像</strong>: 选择地理位置较近的镜像服务器</li>
<li><strong>避免过度重定向</strong>: 不要配置过多的重定向层级</li>
</ol>
<h3 id="维护建议"><a class="header" href="#维护建议">维护建议</a></h3>
<ol>
<li><strong>版本控制</strong>: 将配置文件纳入版本控制（排除敏感信息）</li>
<li><strong>文档记录</strong>: 记录配置文件的用途和变更历史</li>
<li><strong>定期测试</strong>: 定期测试配置是否仍然有效</li>
<li><strong>备份配置</strong>: 保留配置文件的备份</li>
</ol>
<h2 id="获取帮助"><a class="header" href="#获取帮助">获取帮助</a></h2>
<p>如果遇到问题，可以通过以下方式获取帮助：</p>
<h3 id="检查清单"><a class="header" href="#检查清单">检查清单</a></h3>
<p>在寻求帮助前，请先检查：</p>
<ul>
<li><input disabled="" type="checkbox"/>
配置文件语法是否正确</li>
<li><input disabled="" type="checkbox"/>
环境变量是否正确设置</li>
<li><input disabled="" type="checkbox"/>
网络连接是否正常</li>
<li><input disabled="" type="checkbox"/>
认证信息是否有效</li>
<li><input disabled="" type="checkbox"/>
目标服务器是否可访问</li>
</ul>
<h3 id="常见资源"><a class="header" href="#常见资源">常见资源</a></h3>
<ul>
<li><strong>YAML 语法验证</strong>: https://www.yamllint.com/</li>
<li><strong>环境变量设置指南</strong>: 搜索 "环境变量设置 [您的操作系统]"</li>
<li><strong>网络连接测试</strong>: 使用 <code>ping</code> 和 <code>curl</code> 命令测试</li>
<li><strong>镜像服务状态</strong>: 查看镜像服务的官方状态页面</li>
</ul>
<h3 id="联系支持"><a class="header" href="#联系支持">联系支持</a></h3>
<p>如果以上方法都无法解决问题，请联系技术支持并提供以下信息：</p>
<ol>
<li>操作系统和版本</li>
<li>配置文件内容（去除敏感信息）</li>
<li>错误信息或日志</li>
<li>重现问题的步骤</li>
</ol>
<hr />
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="配置文件模板"><a class="header" href="#配置文件模板">配置文件模板</a></h3>
<h4 id="基础模板"><a class="header" href="#基础模板">基础模板</a></h4>
<pre><code class="language-yaml"># NetAccessCtrl 基础配置模板
enable: true
units:
  - rules:
      - pattern: "https://example.com/*"
        target: "https://mirror.example.com/"
</code></pre>
<h4 id="完整模板"><a class="header" href="#完整模板">完整模板</a></h4>
<pre><code class="language-yaml"># NetAccessCtrl 完整配置模板
enable: true
units:
  - rules:
      - pattern: "https://service1.com/*"
        target: "https://mirror1.service1.com/"
      - pattern: "https://service2.com/*"
        target: "https://mirror2.service2.com/"
    auth:
      username: "${SERVICE1_USER}"
      password: "${SERVICE1_PASSWORD}"
    timeout:
      connect-timeout: 30
      read-timeout: 60
      total-timeout: 300
    proxy:
      url: "${PROXY_URL:http://proxy.default:8080}"

  - rules:
      - pattern: "https://another-service.com/*"
        target: "https://internal.another-service.com/"
    # 此单元无认证、超时和代理配置
</code></pre>
<h3 id="常用镜像服务器列表"><a class="header" href="#常用镜像服务器列表">常用镜像服务器列表</a></h3>
<div class="table-wrapper"><table><thead><tr><th>服务类型</th><th>原地址</th><th>推荐镜像地址</th></tr></thead><tbody>
<tr><td>GitHub</td><td><code>https://github.com/*</code></td><td><code>https://ghproxy.com/</code></td></tr>
<tr><td>GitHub Raw</td><td><code>https://raw.githubusercontent.com/*</code></td><td><code>https://raw.ghproxy.com/</code></td></tr>
<tr><td>PyPI</td><td><code>https://pypi.org/*</code></td><td><code>https://pypi.doubanio.com/</code></td></tr>
<tr><td>NPM</td><td><code>https://registry.npmjs.org/*</code></td><td><code>https://registry.npmmirror.com/</code></td></tr>
<tr><td>Docker Hub</td><td><code>https://registry-1.docker.io/*</code></td><td><code>https://dockerhub.azk8s.cn/</code></td></tr>
<tr><td>RubyGems</td><td><code>https://rubygems.org/*</code></td><td><code>https://gems.ruby-china.com/</code></td></tr>
</tbody></table>
</div>
<p><em>注意：镜像服务地址可能会发生变化，请以最新信息为准。</em></p>
<hr />
<p><strong>快速开始总结</strong>：</p>
<ol>
<li>创建 <code>net-access.yaml</code> 文件</li>
<li>复制相应场景的配置示例</li>
<li>设置环境变量（可选）</li>
<li>放置配置文件到正确位置</li>
<li>验证配置是否生效</li>
</ol>
<p>祝您使用愉快！🎉</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl---语法"><a class="header" href="#gxl---语法">GXL   语法</a></h1>
<h2 id="结构"><a class="header" href="#结构">结构</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
 env dev {
 }
}

mod main {
    flow conf {
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>mod   模块</li>
<li>env   环境</li>
<li>flow  处理流</li>
</ul>
<h2 id="flow"><a class="header" href="#flow">flow</a></h2>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<h4 id="简单使用"><a class="header" href="#简单使用">简单使用</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>flow test {
  gx.echo (  "hello world" );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="增加描述"><a class="header" href="#增加描述">增加描述</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[usage(desp="test flow")]
flow test() {
  gx.echo (  "hello world" );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="编排"><a class="header" href="#编排">编排</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>flow head {
  gx.echo ( "head"; )
}
flow tail {
  gx.echo ( "tail"; )
}

// 执行过程为: test -&gt; head -&gt; tail
flow  @test | head | tail  { }
flow  test | head | tail  { }


// 执行过程为: head -&gt; tail -&gt; test
flow  | head | tail  |@test { }

//执行过程为: head -&gt; test -&gt; tail
flow  head | @test | tail {
  gx.echo ( "test"; )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  flow [ &lt;flows&gt;|]  @&lt;flow_name&gt;  [|&lt;flows&gt;] {
  }
<span class="boring">}</span></code></pre></pre>
<h3 id="分支"><a class="header" href="#分支">分支</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {
  api = "1.0"
  flow conf {
    if  ${API} == "1.0" {
        gx.echo ( value : "this is if true cond " );
    }
    else {
        gx.echo ( value : "this is if false cond" );
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="通配比较"><a class="header" href="#通配比较">通配比较</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {
  api = "1.0"
  flow conf {
    if  ${API} =* "1*" {
        gx.echo ( value : "this is if true cond " );
    }
    else {
        gx.echo ( value : "this is if false cond" );
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="env"><a class="header" href="#env">env</a></h2>
<p>环境设定集合</p>
<h3 id="示例-4"><a class="header" href="#示例-4">示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env dev {
    root = "./" ;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[useage(desp="开发环境")]
env dev {
    root = "./" ;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="mix-env"><a class="header" href="#mix-env">mix env</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env base {}
env dev  : base {
    root = "./" ;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>默认env: default  , 可以省去 gflow -e 参数 ;</li>
</ul>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env &lt;name&gt; [: &lt;mix-envs&gt;] {
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>name  :</li>
<li>mix-envs : 可继承的env</li>
</ul>
<h2 id="mod"><a class="header" href="#mod">mod</a></h2>
<p>mod 是顶级的组织结构</p>
<p>只有 envs,main 两个mod 中的 env 和 flow  cli 直接load</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
  prop1 = "prop1"
  env dev {}
}
mod main {
  prop1 = "prop1"
  flow test {}
}
<span class="boring">}</span></code></pre></pre>
<p>执行</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gflow -e dev test 
<span class="boring">}</span></code></pre></pre>
<h3 id="mod-注解"><a class="header" href="#mod-注解">mod 注解</a></h3>
<h3 id="mod继承"><a class="header" href="#mod继承">mod继承</a></h3>
<h3 id="示例-5"><a class="header" href="#示例-5">示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<h1 id="activity"><a class="header" href="#activity">Activity</a></h1>
<ul>
<li>包装shell  成为 activity</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> activity copy {
     src = "" ;
     dst = "" ;
     log = "1" ;
     out = "true"
     executer = "copy_act.sh" ;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量定义"><a class="header" href="#变量定义">变量定义</a></h1>
<h2 id="示例-6"><a class="header" href="#示例-6">示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    one= "one";
    sys_a = { mod1 : "A", mod2 : "B" , mod3: 1 , mod4 : 2};
    sys_b =  [ "C", "D" ];
    sys_c = ${SYS_B[1]} ;
    sys_d = ${SYS_A.MOD1} ;
<span class="boring">}</span></code></pre></pre>
<h2 id="规则"><a class="header" href="#规则">规则</a></h2>
<p>在GXL内 变量名不区分大小写</p>
<h2 id="使用示例-2"><a class="header" href="#使用示例-2">使用示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
    env default   {
      data_list =  [ "JAVA", "RUST", "PYTHON"] ;
      data_obj =  { 
        JAVA : { NAME: "JAVA", SCORE: 80 }, 
        RUST : { NAME: "RUST", SCORE: 100 }, 
        PYTHON : { NAME: "PYTHON", SCORE: 200} 
        } ;
    }
}
mod main   {
  flow array_do{
    for ${CUR} in ${ENV_DATA_LIST} {
      gx.echo( "CUR:${CUR}" );
    }
  }
  flow obj_do{
    for ${CUR} in ${ENV_DATA_OBJ} {
      gx.echo( "CUR:${CUR.NAME} : ${CUR.SCORE}" );
    }
  }

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="内置常量"><a class="header" href="#内置常量">内置常量</a></h2>
<ul>
<li>GXL_PRJ_ROOT:   最近定义了 _gal/project.toml 的目录</li>
<li>GXL_START_ROOT:  GXL 启动处理的目录</li>
<li>GXL_CUR_DIR:  GXL 当前所在目录，在调用gx.run时，与GXL_START_ROOT可能不同</li>
<li>GXL_CMD_ARG:  gflow -- &lt;cmd_arg&gt;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="flow-1"><a class="header" href="#flow-1">flow</a></h1>
<h2 id="注解"><a class="header" href="#注解">注解</a></h2>
<h3 id="task---v060"><a class="header" href="#task---v060">task   (v0.6.0)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(name="setup")]
flow setup{
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dryrun--v070"><a class="header" href="#dryrun--v070">dryrun  (v0.7.0)</a></h3>
<pre><code>#[dryrun(_pub_dryrun)]
flow _pub_dysec {
    ...
}
flow _pub_dryrun {
    ...
}
</code></pre>
<h3 id="transcation-undo-v070"><a class="header" href="#transcation-undo-v070">transcation undo (v0.7.0)</a></h3>
<pre><code>flow trans1 | step1 | step2 | step3 ;
  #[transaction,undo(_undo_step1)]
  flow step1 {
    gx.echo (" step1 ");
  }
  #[undo(_undo_step2)]
  flow step2 {
    gx.echo (" step2 ");
  }
  #[undo(_undo_step3)]
  flow step3 {
    gx.echo (" step3 ");
    gx.assert ( value : "true" , expect : "false" );
  }

  flow _undo_step1 {
    gx.echo (" undo step1 ");
  }
  flow _undo_step2 {
    gx.echo (" undo step2 ");
  }
  flow _undo_step3 {
    gx.echo (" undo step3 ");
  }
</code></pre>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[usage(desp="test")]
flow test_1 {

}
<span class="boring">}</span></code></pre></pre>
<h3 id="auto_load"><a class="header" href="#auto_load">auto_load</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[auto_load(entry,exit)] 

//entry: 进入flow 
//exit : 退出flow
示例:

mod main {

  flow start {
    gx.echo ( value : "hello" );
  }
  #[auto_load(entry)]
  flow conf {
    gx.echo ( value : "hello" );
  }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defined"><a class="header" href="#defined">defined</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if defined(${PRJ_ROOT}) {
        gx.echo (  "${PRJ_ROOT}/test/main.py"  );
        }
        else {
        gx.echo (  "${PRJ_ROOT}/test/main.py"  );
    }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl-文件语法"><a class="header" href="#gxl-文件语法">GXL 文件语法</a></h1>
<h2 id="gxl-语法定义"><a class="header" href="#gxl-语法定义">GXL 语法定义</a></h2>
<p>GXL（Galaxy Flow Language）是一种为 DevSecOps 自动化工作流设计的领域特定语言。根据代码库中的信息，GXL 的语法定义主要在 galaxy-sec/galaxy-flow 仓库的解析器模块中实现。</p>
<h3 id="gxl-语法结构"><a class="header" href="#gxl-语法结构">GXL 语法结构</a></h3>
<p>GXL 语言遵循模块化、层次化的结构，主要由以下核心组件组成：</p>
<ul>
<li>模块（Modules）：使用 mod 关键字定义，是 GXL 的顶层组织单元</li>
<li>环境（Environments）：使用 env 关键字定义，用于配置不同的执行上下文</li>
<li>流程（Flows）：使用 flow 关键字定义，表示工作流程序</li>
<li>活动（Activities）：可重用的操作单元，在流程中调用</li>
</ul>
<h2 id="ebnf-语法"><a class="header" href="#ebnf-语法">EBNF 语法</a></h2>
<pre><code class="language-EBNF">
; GXL 文件由一系列模块定义组成
GXL-File = *Module


(* GXL 文件由一系列模块定义组成 *)
GXL-File = {Module};

(* 模块定义 *)
Module = "mod", whitespace, ModuleName, whitespace, "{", whitespace, ModuleContent, whitespace, "}", whitespace, ";";
ModuleName = Identifier;
ModuleContent = {Property | Environment | Flow};

(* 属性定义 (键值对) *)
Property = PropertyName, whitespace, "=", whitespace, PropertyValue, whitespace, ";";
PropertyName = Identifier;
PropertyValue = String;

(* 环境定义 *)
Environment = "env", whitespace, EnvName, [whitespace, ":", whitespace, EnvRefList], whitespace, "{", whitespace, EnvContent, whitespace, "}";
EnvName = Identifier;
EnvContent = {Property};
EnvRefList = EnvRef, {",", whitespace, EnvRef};
EnvRef = Identifier;

(* 流程定义 - 两种形式：直接定义或引用其他流程 *)
Flow = DirectFlow | ReferenceFlow;

(* 直接定义流程 *)
DirectFlow = "flow", whitespace, FlowName, [whitespace, ":", whitespace, FlowRefList [ whitespace , ":" whitespace, FlowRefList ] ], whitespace, "{", whitespace, FlowContent, whitespace, "}", whitespace, ";";
FlowName = Identifier;
FlowContent = {Command};

(* 引用其他流程 *)
ReferenceFlow = "flow", whitespace, FlowName, whitespace, ":", whitespace, FlowRefList, whitespace, ";";
FlowRefList = FlowRef, {",", whitespace, FlowRef};
FlowRef = Identifier;


(* 命令定义 *)
Command = (BuiltinCommand | ActivityCall), whitespace, ";";

(* 内置命令 *)
BuiltinCommand = "gx.", CommandName, whitespace, "{", whitespace, CommandProps, whitespace, "}";
CommandName = "echo" | "vars" | "cmd" | "read" | "tpl" | "assert" | "ver";
CommandProps = {PropertyAssignment};
PropertyAssignment = PropertyName, whitespace, "=", whitespace, PropertyValue, whitespace,  ",";

(* 活动调用 *)
ActivityCall = ActivityName, whitespace, "{", whitespace, CommandProps, whitespace, "}";
ActivityName = Identifier, {".", Identifier};

(* 标识符 *)
Identifier = Alpha, {Alpha | Digit | "_"};
Alpha = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z";
Digit = "0" | "1" | ... | "9";

(* 字符串 *)
String = '"', {StringChar}, '"';
StringChar = UnescapedChar | EscapedChar;
UnescapedChar = ? 除了 " 和 \ 的任何字符 ?;
EscapedChar = "\", ("\" | '"');

(* 变量引用 *)
VariableRef = "${", VariableName, "}";
VariableName = Identifier;

(* 空白字符 *)
whitespace = {" " | "\t" | "\r" | "\n"};

(* 外部模块引用 *)
ExternModule = "extern", whitespace, "mod", whitespace, ModuleNameList, whitespace, "{", whitespace, ModuleSource, whitespace, "}", whitespace, ";";
ModuleNameList = ModuleName, {",", whitespace, ModuleName};
ModuleSource = PathSource | GitSource;
PathSource = "path", whitespace, "=", whitespace, String;
GitSource = "git", whitespace, "=", whitespace, String, whitespace, ",", whitespace, "channel", whitespace, "=", whitespace, String;


(* 注解 *)
Annotation = "#[", AnnotationName, ("(", AnnotationParams, ")")?, "]";
AnnotationName = Identifier;
AnnotationParams = AnnotationParam, {",", whitespace, AnnotationParam};
AnnotationParam = Identifier, whitespace, "=", whitespace, String;
</code></pre>
<h2 id="示例-7"><a class="header" href="#示例-7">示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env dev {
	root = "${HOME}/my_project";
	gx.read_cmd {
		name = "MY_PATH" ;
		cmd  = "pwd" ;
	};
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod my_module {
    -- 模块属性
    author = "John Doe";
    version = "1.0";

    -- 环境定义
    env test {
        root = "${HOME}/test_project";
        gx.read_cmd {
            name = "TEST_PATH";
            cmd = "ls";
        };
    }

    -- 流程定义
    flow my_flow {
        step1 = "execute_task";
        task1.run {
            param1 = "value1";
            param2 = "value2";
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示例-8"><a class="header" href="#示例-8">示例</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-示例"><a class="header" href="#assert-示例">Assert 示例</a></h1>
<h2 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path= "../../_gal/mods"; }
mod base_env {
    env _common {
      gx.vars {
        DOMAIN    = "domain" ;
      }
    }
    env cli : _common {
      ROOT   = "./";

    }
    env unit_test : _common {
      ROOT   = "./example";
    }
}
mod envs : base_env {
    #[usage(desp="default")]
    env default : cli ;
    env empty {}
    env ut : unit_test  ;
}
mod base{
  mod_val = "1";
  flow define {
    base = "BASE";
  }
  #[auto_load(entry)]
  flow base_into  {
    base_begin = "BASE_INTO";
  }
  #[auto_load(exit)]
  flow base_exit {
    base_end = "BASE_EXIT";
  }
}
mod other {
  flow def1 {
    other_val = "OTHER_DEF";
  }
  flow def2{
    other_val = "OTHER_DEF2";
  }
}
mod main   {
  conf = "${ENV_ROOT}/conf" ;

  #[auto_load(entry)]
  flow __into  | other.def1  {
    other_val = "OTHER_DE1";
  }
  #[auto_load(exit)]
  flow __exit | other.def2 ;
  #[usage(desp="main")]
  flow assert_main {
    one= "one";
    sys_a = { mod1 : "A", mod2 : "B" };
    sys_b =  [ "C", "D" ];
    sys_c = ${SYS_B[1]} ;
    sys_d = ${SYS_A.MOD1} ;
    gx.assert ( value : "${MAIN_CONF}" , expect : "${ENV_ROOT}/conf" );
    gx.assert ( value : "${OTHER_VAL}" , expect : "OTHER_DEF" );
    gx.assert ( value : "${SYS_A.MOD1}" , expect : "A" );
    gx.assert ( value : "${sys_a.mod1}" , expect : "A" );
    gx.assert ( value : "${sys_b[0]}" , expect : "C" );
    gx.assert ( value : "${sys_d}" , expect : "A" );
  }

  flow base.define | @assert_parent   {
    gx.assert ( value : "${MAIN_CONF}" , expect : "${ENV_ROOT}/conf" );
    gx.assert ( value : "${BASE_MOD_VAL}" , expect : "1" );
    gx.assert ( value : "${OTHER_VAL}" , expect : "OTHER_DEF" );
    gx.assert ( value : "${BASE}" , expect : "BASE" );
    gx.assert ( value : "${BASE_BEGIN}" , expect : "BASE_INTO" );
  }

}
<span class="boring">}</span></code></pre></pre>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.assert</code> 命令进行断言检查。在 <code>assert_main</code> 流程中，多个 <code>gx.assert</code> 命令用于验证变量的值是否符合预期。在 <code>base.define</code> 流程中，也使用了 <code>gx.assert</code> 来验证环境变量和模块变量的值。</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load base_env]
    B --&gt; C[Load envs]
    C --&gt; D[Load base module]
    D --&gt; E[Load other module]
    E --&gt; F[Load main module]
    F --&gt; G[Execute __into flow]
    G --&gt; H[Execute assert_main flow]
    H --&gt; I[Execute gx.assert commands]
    I --&gt; J[Execute base.define flow]
    J --&gt; K[Execute more gx.assert commands]
    K --&gt; L[Execute __exit flow]
    L --&gt; M[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dryrun-example"><a class="header" href="#dryrun-example">Dryrun Example</a></h1>
<p>This example demonstrates the dryrun functionality in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {

env default {}

flow _step1 {
    gx.echo ("step1");
}

#[dryrun(_step3)]
flow _step2 {
    gx.echo ("step2");
    gx.assert ( value : "true" , expect : "false" );
}

flow _step3 {
    gx.echo ("dryrun setp2");
}

flow start | _step1 | _step2 ;

}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load main module]
    B --&gt; C[Execute start flow]
    C --&gt; D[Execute _step1 flow]
    D --&gt; E[Execute _step2 flow]
    E --&gt; F{Assertion fails?}
    F --&gt;|Yes| G[Execute _step3 flow]
    F --&gt;|No| H[End]
    G --&gt; I[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fun-example"><a class="header" href="#fun-example">Fun Example</a></h1>
<p>This example demonstrates how to define and use functions in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod sys {
    fun echo(name) {
        gx.echo("echo:${name}");
    }
    fun echo_obj(obj) {
        gx.echo("echo_obj:${obj}");
    }
    fun echo_list(list) {
        gx.echo("echo_list:${list}");
    }
}

mod envs {
    env default {
        DATA = [
            "JAVA",
            "RUST",
            "PYTHON",
        ];
        OBJ = {
            name: "test",
            value: "value",
        };
    }
}

mod main {
    flow conf {
        sys.echo("test");
        sys.echo_obj("${OBJ}");
        sys.echo_list("${DATA}");
    }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load sys module]
    B --&gt; C[Define echo functions]
    C --&gt; D[Load envs module]
    D --&gt; E[Load main module]
    E --&gt; F[Execute conf flow]
    F --&gt; G[Call sys.echo function]
    G --&gt; H[Call sys.echo_obj function]
    H --&gt; I[Call sys.echo_list function]
    I --&gt; J[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-示例"><a class="header" href="#read-示例">Read 示例</a></h1>
<h2 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path= "../../_gal/mods"; }
mod envs {
    env _dev_local {
        gx.read_file ( file : "./var.ini" );
    }
    env default : _dev_local ;
}
mod main   {
  flow conf  {
    gx.echo (  "${RUST}" );
    gx.echo (  "${JAVA}" );
    gx.assert ( value : "${JAVA}" , expect : "90"  );

    gx.read_cmd (
        //fail!
        //cmd  : r#"git branch --show-current |  sed -E "s/(feature|develop|ver-dev|release|master|issue)(\/\.*)?/_branch_\1/g" "# ,
        //suc!
        cmd  : "git branch --show-current | sed -E 's/release/rls/g'" ,
        name : "GIT_BRANCH" );

    gx.echo ( "what:${GIT_BRANCH}" );

    gx.read_file ( file : "./var2.ini" , name : "DATA");

    for ${CUR} in ${DATA} {
        gx.echo ( value : "${CUR}" );
    }
  }



}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Execute _dev_local env]
    C --&gt; D[Execute gx.read_file command]
    D --&gt; E[Load main module]
    E --&gt; F[Execute conf flow]
    F --&gt; G[Execute gx.echo commands]
    G --&gt; H[Execute gx.read_cmd command]
    H --&gt; I[Execute gx.echo command]
    I --&gt; J[Execute gx.read_file command]
    J --&gt; K[Loop through DATA]
    K --&gt; L[Execute gx.echo command for each item]
    L --&gt; M[End]
</pre>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.read</code> 命令从不同来源读取数据。在 <code>_dev_local</code> 环境中，使用 <code>gx.read_file</code> 从 <code>var.ini</code> 文件读取数据。在 <code>conf</code> 流程中，使用 <code>gx.read_cmd</code> 执行 Git 命令并捕获输出，以及使用 <code>gx.read_file</code> 从 <code>var2.ini</code> 文件读取数据。还展示了如何遍历读取的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-example"><a class="header" href="#shell-example">Shell Example</a></h1>
<p>This example demonstrates how to execute shell commands in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod envs {
    env _dev_local {}
    env default : _dev_local;
}

mod main {
    flow conf {
        gx.read_file(file: "./var.yml", name: "VAR");
        gx.echo("what:${VAR.MEMBER.JAVA}");

        gx.shell(
            arg_file: "./var.json",
            shell: "./demo.sh",
            out_var: "SYS_OUT");

        gx.echo("what:${SYS_OUT}");

        gx.read_file(file: "./var_list.yml", name: "DATA");
        for ${CUR} in ${DATA.DEV_LANG} {
            gx.shell(
                shell: "./demo_ex.sh ${CUR}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }

        gx.read_file(file: "./var_obj.yml", name: "DATA");
        for ${CUR} in ${DATA} {
            gx.shell(
                shell: "./demo_ex.sh ${CUR.SYS.NAME}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }
    }
    flow do_obj {
        gx.read_file(file: "./var_obj.yml", name: "DATA");
        for ${CUR} in ${DATA} {
            //gx.echo( "CUR:${CUR.SYS.NAME}" );
            gx.shell(
                shell: "./demo_ex.sh ${CUR.SYS.NAME}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="说明-2"><a class="header" href="#说明-2">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.shell</code> 命令执行 shell 脚本。在 <code>conf</code> 流程中，首先从 <code>var.yml</code> 文件读取数据，然后使用 <code>gx.shell</code> 执行 <code>demo.sh</code> 脚本，并通过 <code>arg_file</code> 参数传递 <code>var.json</code> 文件。还展示了如何在循环中执行 shell 脚本，并处理列表和对象数据。</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Load main module]
    C --&gt; D[Execute conf flow]
    D --&gt; E[Execute gx.read_file command]
    E --&gt; F[Execute gx.echo command]
    F --&gt; G[Execute gx.shell command]
    G --&gt; H[Execute gx.echo command]
    H --&gt; I[Execute gx.read_file command]
    I --&gt; J[Loop through DATA.DEV_LANG]
    J --&gt; K[Execute gx.shell command for each item]
    K --&gt; L[Execute gx.echo command]
    L --&gt; M[Execute gx.read_file command]
    M --&gt; N[Loop through DATA]
    N --&gt; O[Execute gx.shell command for each item]
    O --&gt; P[Execute gx.echo command]
    P --&gt; Q[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-example"><a class="header" href="#template-example">Template Example</a></h1>
<p>This example demonstrates how to use templates in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod base_env {
    env _common {
        gx.vars {
            DOMAIN = "domain";
            SOCK_FILE = "socket";
            GXL_PRJ_ROOT = "./";
        }
    }
    env cli : _common {
        ROOT = "./";
    }
    env unit_test : _common {
        ROOT = "./example";
    }
}

mod envs : base_env {
    #[usage(desp = "default")]
    env default : cli;
    env empty {}
    env ut : unit_test;
}

mod main {
    conf = "${ENV_ROOT}/conf";
    flow conf {
        os.path(dst: "${MAIN_CONF}/used", keep: "true");
        gx.tpl(
            tpl: "${MAIN_CONF}/tpls/",
            dst: "${MAIN_CONF}/used/",
            file: "${MAIN_CONF}/value.json");

        ```cmd
        echo "hello";
        cp ./conf/value.json ./conf/used/back.json;
        ```
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>This example shows how to use the <code>gx.tpl</code> command to process template files. In the <code>conf</code> flow, the <code>os.path</code> command is first used to create the target directory, then the <code>gx.tpl</code> command renders template files from the <code>tpls</code> directory based on values in the <code>value.json</code> file and outputs them to the <code>used</code> directory. Finally, an inline shell command block is shown to copy a file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-example"><a class="header" href="#transaction-example">Transaction Example</a></h1>
<p>This example demonstrates how to use transactions in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod base { path = "./_gal/"; }

mod envs {
    env default {};
}

mod main {
    flow trans1 | step1 | step2 | base.base_step1 | step3;
    flow trans2 | step1 | step3 | step2;

    #[transaction, undo(_undo_step1)]
    flow step1 {
        gx.echo(" step1 ");
    }
    #[undo(_undo_step2)]
    flow step2 {
        gx.echo(" step2 ");
    }
    #[undo(_undo_step3)]
    flow step3 {
        gx.echo(" step3 ");
        gx.assert(value: "true", expect: "false");
    }

    flow _undo_step1 {
        gx.echo(" undo step1 ");
    }
    flow _undo_step2 {
        gx.echo(" undo step2 ");
    }
    flow _undo_step3 {
        gx.echo(" undo step3 ");
    }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load base module]
    B --&gt; C[Load envs module]
    C --&gt; D[Load main module]
    D --&gt; E[Define flows]
    E --&gt; F[Execute trans1 flow]
    F --&gt; G[Execute step1 flow]
    G --&gt; H[Execute step2 flow]
    H --&gt; I[Execute base.base_step1 flow]
    I --&gt; J[Execute step3 flow]
    J --&gt; K[Execute trans2 flow]
    K --&gt; L[Execute step1 flow]
    L --&gt; M[Execute step3 flow]
    M --&gt; N[Execute step2 flow]
    N --&gt; O[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vars-example"><a class="header" href="#vars-example">Vars Example</a></h1>
<p>This example demonstrates how to define and use variables in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
    env default {
        data_list = [
            "JAVA",
            "RUST",
            "PYTHON",
        ];
        data_obj = {
            JAVA: { NAME: "JAVA", SCORE: 80 },
            RUST: { NAME: "RUST", SCORE: 100 },
            PYTHON: { NAME: "PYTHON", SCORE: 200 },
        };
    }
}

mod main {
    flow array_do {
        for ${CUR} in ${ENV.DATA_LIST} {
            gx.echo("CUR:${CUR}");
        }
    }
    flow obj_do {
        for ${CUR} in ${ENV.DATA_OBJ} {
            gx.echo("CUR:${CUR.NAME} : ${CUR.SCORE}");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>This example shows how to define variables in an environment and how to use these variables in flows. In the <code>default</code> environment, a list <code>data_list</code> and an object <code>data_obj</code> are defined. In the <code>array_do</code> flow, the <code>data_list</code> list is iterated over and each element is output. In the <code>obj_do</code> flow, the <code>data_obj</code> object is iterated over and the properties of each object are output.</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Define data_list and data_obj variables]
    C --&gt; D[Load main module]
    D --&gt; E[Execute array_do flow]
    E --&gt; F[Loop through ENV.DATA_LIST]
    F --&gt; G[Execute gx.echo command for each item]
    G --&gt; H[Execute obj_do flow]
    H --&gt; I[Loop through ENV.DATA_OBJ]
    I --&gt; J[Execute gx.echo command for each item]
    J --&gt; K[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="galaxy-flow-内置能力文档"><a class="header" href="#galaxy-flow-内置能力文档">Galaxy Flow 内置能力文档</a></h1>
<p>本文档详细描述了Galaxy Flow中所有内置能力的语法定义和使用示例。</p>
<h2 id="gxassert"><a class="header" href="#gxassert">gx.assert</a></h2>
<h3 id="功能描述"><a class="header" href="#功能描述">功能描述</a></h3>
<p>执行断言检查，验证表达式的值是否符合预期。</p>
<h3 id="语法定义"><a class="header" href="#语法定义">语法定义</a></h3>
<pre><code class="language-gxl">gx.assert {
  value: &lt;表达式&gt;,      // 要检查的值
  expect: &lt;期望值&gt;,     // 期望的值
  err: &lt;错误信息&gt;,      // 断言失败时的错误信息（可选）
  result: &lt;变量名&gt;      // 存储断言结果的变量名（可选）
}
</code></pre>
<h3 id="示例代码-2"><a class="header" href="#示例代码-2">示例代码</a></h3>
<pre><code class="language-gxl">// 检查变量值是否等于期望值
gx.assert {
  value: ${MY_VAR},
  expect: "expected_value",
  err: "MY_VAR值不正确"
}

// 检查表达式结果并存储结果
gx.assert {
  value: ${CALC_RESULT},
  expect: 42,
  result: "assert_result"
}
</code></pre>
<h2 id="gxcmd"><a class="header" href="#gxcmd">gx.cmd</a></h2>
<h3 id="功能描述-1"><a class="header" href="#功能描述-1">功能描述</a></h3>
<p>执行系统命令或脚本。</p>
<h3 id="语法定义-1"><a class="header" href="#语法定义-1">语法定义</a></h3>
<pre><code class="language-gxl">gx.cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  shell: &lt;Shell类型&gt;,    // 指定使用的Shell（可选）
  out: &lt;输出变量名&gt;,     // 捕获命令标准输出的变量名（可选）
  err: &lt;错误变量名&gt;,     // 捕获命令错误输出的变量名（可选）
  suc: &lt;成功标识&gt;,       // 命令执行成功的标识（可选）
  sudo: &lt;布尔值&gt;,        // 是否使用sudo权限执行（可选）
  log: &lt;日志级别&gt;,       // 日志记录级别（可选）
  silence: &lt;布尔值&gt;      // 是否静默执行（可选）
}
</code></pre>
<h3 id="示例代码-3"><a class="header" href="#示例代码-3">示例代码</a></h3>
<pre><code class="language-gxl">// 执行简单命令
gx.cmd {
  cmd: "ls -la"
}

// 执行命令并捕获输出
gx.cmd {
  cmd: "date",
  out: "current_date"
}

// 使用sudo权限执行命令
gx.cmd {
  cmd: "systemctl restart nginx",
  sudo: true
}
</code></pre>
<h2 id="gxecho"><a class="header" href="#gxecho">gx.echo</a></h2>
<h3 id="功能描述-2"><a class="header" href="#功能描述-2">功能描述</a></h3>
<p>输出文本信息到控制台。</p>
<h3 id="语法定义-2"><a class="header" href="#语法定义-2">语法定义</a></h3>
<pre><code class="language-gxl">gx.echo {
  value: &lt;文本内容&gt;,     // 要输出的文本内容
  file: &lt;文件路径&gt;,      // 输出到文件的路径（可选）
  export: &lt;变量名&gt;,      // 导出为环境变量的名称（可选）
  inc: &lt;布尔值&gt;          // 是否追加到文件末尾（可选）
}
</code></pre>
<h3 id="示例代码-4"><a class="header" href="#示例代码-4">示例代码</a></h3>
<pre><code class="language-gxl">// 输出简单文本
gx.echo {
  value: "Hello, Galaxy Flow!"
}

// 输出到文件
gx.echo {
  value: "This is a log entry",
  file: "app.log"
}

// 追加到文件
gx.echo {
  value: "Additional information",
  file: "app.log",
  inc: true
}

// 导出为环境变量
gx.echo {
  value: "production",
  export: "ENV_TYPE"
}
</code></pre>
<h2 id="gxread"><a class="header" href="#gxread">gx.read</a></h2>
<h3 id="功能描述-3"><a class="header" href="#功能描述-3">功能描述</a></h3>
<p>从不同来源读取数据并存储到变量中。</p>
<h3 id="语法定义-3"><a class="header" href="#语法定义-3">语法定义</a></h3>
<pre><code class="language-gxl">// 从文件读取
gx.read_file {
  file: &lt;文件路径&gt;,      // 要读取的文件路径
  name: &lt;变量名&gt;         // 存储文件内容的变量名
}

// 从标准输入读取
gx.read_stdin {
  name: &lt;变量名&gt;,        // 存储输入内容的变量名
  prompt: &lt;提示文本&gt;     // 输入提示文本（可选）
}

// 从命令输出读取
gx.read_cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  name: &lt;变量名&gt;,        // 存储命令输出的变量名
  shell: &lt;Shell类型&gt;     // 指定使用的Shell（可选）
}
</code></pre>
<h3 id="示例代码-5"><a class="header" href="#示例代码-5">示例代码</a></h3>
<pre><code class="language-gxl">// 从文件读取内容
gx.read_file {
  file: "config.json",
  name: "config_data"
}

// 从标准输入读取
gx.read_stdin {
  name: "user_input",
  prompt: "请输入您的姓名: "
}

// 从命令输出读取
gx.read_cmd {
  cmd: "git rev-parse HEAD",
  name: "commit_hash"
}
</code></pre>
<h2 id="gxvars"><a class="header" href="#gxvars">gx.vars</a></h2>
<h3 id="功能描述-4"><a class="header" href="#功能描述-4">功能描述</a></h3>
<p>定义和设置多个变量。</p>
<h3 id="语法定义-4"><a class="header" href="#语法定义-4">语法定义</a></h3>
<pre><code class="language-gxl">gx.vars {
  &lt;变量名1&gt;: &lt;值1&gt;,      // 变量名和对应的值
  &lt;变量名2&gt;: &lt;值2&gt;,      // 可以定义多个变量
  // ...
}
</code></pre>
<h3 id="示例代码-6"><a class="header" href="#示例代码-6">示例代码</a></h3>
<pre><code class="language-gxl">// 定义多个变量
gx.vars {
  app_name: "MyApp",
  version: "1.0.0",
  debug: true
}

// 使用变量引用
gx.vars {
  project_root: "${HOME}/projects",
  config_file: "${project_root}/config.yaml"
}
</code></pre>
<h2 id="gxtpl"><a class="header" href="#gxtpl">gx.tpl</a></h2>
<h3 id="功能描述-5"><a class="header" href="#功能描述-5">功能描述</a></h3>
<p>使用模板引擎处理文件模板。</p>
<h3 id="语法定义-5"><a class="header" href="#语法定义-5">语法定义</a></h3>
<pre><code class="language-gxl">gx.tpl {
  tpl: &lt;模板内容&gt;,       // 模板内容
  dst: &lt;目标文件路径&gt;,   // 生成文件的路径
  data: &lt;数据变量名&gt;,    // 模板数据变量名（可选）
  engine: &lt;引擎类型&gt;,    // 模板引擎类型（可选）
  file: &lt;模板文件路径&gt;   // 模板文件路径（可选，与tpl互斥）
}
</code></pre>
<h3 id="示例代码-7"><a class="header" href="#示例代码-7">示例代码</a></h3>
<pre><code class="language-gxl">// 使用内联模板
gx.tpl {
  tpl: "Hello, {{name}}! Welcome to {{app_name}}.",
  dst: "output.txt",
  data: "user_data"
}

// 使用模板文件
gx.tpl {
  file: "template.txt",
  dst: "output.txt",
  data: "template_data"
}
</code></pre>
<h2 id="gxver"><a class="header" href="#gxver">gx.ver</a></h2>
<h3 id="功能描述-6"><a class="header" href="#功能描述-6">功能描述</a></h3>
<p>管理和操作版本信息。</p>
<h3 id="语法定义-6"><a class="header" href="#语法定义-6">语法定义</a></h3>
<pre><code class="language-gxl">gx.ver {
  value: &lt;版本值&gt;,       // 版本值
  default: &lt;默认值&gt;,     // 默认版本值（可选）
  file: &lt;文件路径&gt;,      // 版本文件路径（可选）
  export: &lt;变量名&gt;,      // 导出版本信息的变量名（可选）
  inc: &lt;递增类型&gt;        // 版本递增类型（可选，可选值：build/bugfix/feature/main）
}
</code></pre>
<h3 id="示例代码-8"><a class="header" href="#示例代码-8">示例代码</a></h3>
<pre><code class="language-gxl">// 设置版本值
gx.ver {
  value: "1.2.3"
}

// 从文件读取版本并递增
gx.ver {
  file: "VERSION",
  inc: "feature"
}

// 导出版本信息
gx.ver {
  value: "2.0.0",
  export: "APP_VERSION"
}
</code></pre>
<h2 id="gxshell"><a class="header" href="#gxshell">gx.shell</a></h2>
<h3 id="功能描述-7"><a class="header" href="#功能描述-7">功能描述</a></h3>
<p>执行Shell脚本文件。</p>
<h3 id="语法定义-7"><a class="header" href="#语法定义-7">语法定义</a></h3>
<pre><code class="language-gxl">gx.shell {
  shell: &lt;脚本文件路径&gt;,  // 要执行的Shell脚本文件路径
  arg_file: &lt;参数文件&gt;,   // 参数文件路径（可选）
  out_var: &lt;输出变量名&gt;,  // 捕获脚本输出的变量名（可选）
  default: &lt;默认脚本&gt;     // 默认脚本文件路径（可选，与shell互斥）
}
</code></pre>
<h3 id="示例代码-9"><a class="header" href="#示例代码-9">示例代码</a></h3>
<pre><code class="language-gxl">// 执行Shell脚本
gx.shell {
  shell: "deploy.sh"
}

// 执行脚本并捕获输出
gx.shell {
  shell: "build.sh",
  out_var: "build_output"
}

// 使用参数文件
gx.shell {
  shell: "install.sh",
  arg_file: "install.args"
}
</code></pre>
<h2 id="gxdownload-和-gxupload"><a class="header" href="#gxdownload-和-gxupload">gx.download 和 gx.upload</a></h2>
<h3 id="功能描述-8"><a class="header" href="#功能描述-8">功能描述</a></h3>
<p>下载和上传文件。</p>
<h3 id="语法定义-8"><a class="header" href="#语法定义-8">语法定义</a></h3>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: &lt;下载URL&gt;,        // 文件下载URL
  local_file: &lt;本地路径&gt;, // 保存到本地的文件路径
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}

// 上传文件
gx.upload {
  url: &lt;上传URL&gt;,        // 文件上传URL
  local_file: &lt;本地路径&gt;, // 要上传的本地文件路径
  method: &lt;HTTP方法&gt;,     // HTTP方法（如POST、PUT等，默认POST）
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}
</code></pre>
<h3 id="示例代码-10"><a class="header" href="#示例代码-10">示例代码</a></h3>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: "https://example.com/file.zip",
  local_file: "downloaded_file.zip"
}

// 上传文件
gx.upload {
  url: "https://example.com/upload",
  local_file: "local_file.txt",
  method: "POST"
}
</code></pre>
<h2 id="gxtar-和-gxuntar"><a class="header" href="#gxtar-和-gxuntar">gx.tar 和 gx.untar</a></h2>
<h3 id="功能描述-9"><a class="header" href="#功能描述-9">功能描述</a></h3>
<p>创建和解压tar归档文件。</p>
<h3 id="语法定义-9"><a class="header" href="#语法定义-9">语法定义</a></h3>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: &lt;源文件/目录&gt;,     // 要归档的源文件或目录
  file: &lt;归档文件名&gt;      // 生成的归档文件名
}

// 解压tar归档
gx.untar {
  file: &lt;归档文件名&gt;,     // 要解压的归档文件
  dst: &lt;目标目录&gt;         // 解压到的目标目录
}
</code></pre>
<h3 id="示例代码-11"><a class="header" href="#示例代码-11">示例代码</a></h3>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: "src/",
  file: "source.tar"
}

// 解压tar归档
gx.untar {
  file: "source.tar",
  dst: "extracted/"
}
</code></pre>
<h2 id="gxartifact"><a class="header" href="#gxartifact">gx.artifact</a></h2>
<h3 id="功能描述-10"><a class="header" href="#功能描述-10">功能描述</a></h3>
<p>处理构建产物文件。</p>
<h3 id="语法定义-10"><a class="header" href="#语法定义-10">语法定义</a></h3>
<pre><code class="language-gxl">gx.artifact {
  file: &lt;文件路径&gt;,       // 构建产物文件路径
  dst_path: &lt;目标路径&gt;    // 目标存储路径
}
</code></pre>
<h3 id="示例代码-12"><a class="header" href="#示例代码-12">示例代码</a></h3>
<pre><code class="language-gxl">// 处理构建产物
gx.artifact {
  file: "target/release/myapp",
  dst_path: "artifacts/v1.0.0/"
}
</code></pre>
<h2 id="gxrun"><a class="header" href="#gxrun">gx.run</a></h2>
<h3 id="功能描述-11"><a class="header" href="#功能描述-11">功能描述</a></h3>
<p>运行其他GXL工作流文件。</p>
<h3 id="语法定义-11"><a class="header" href="#语法定义-11">语法定义</a></h3>
<pre><code class="language-gxl">gx.run {
  local: &lt;工作流路径&gt;,    // 要运行的工作流文件路径
  env: &lt;环境配置&gt;,        // 环境配置（可选）
  flow: &lt;流程列表&gt;,       // 要执行的流程列表（可选）
  conf: &lt;配置文件&gt;,       // 配置文件路径（可选）
  isolate: &lt;布尔值&gt;       // 是否隔离环境（可选）
}
</code></pre>
<h3 id="示例代码-13"><a class="header" href="#示例代码-13">示例代码</a></h3>
<pre><code class="language-gxl">// 运行其他工作流
gx.run {
  local: "./subflow.gxl"
}

// 在特定环境中运行工作流
gx.run {
  local: "./deploy.gxl",
  env: "production",
  flow: "build,deploy"
}

// 隔离环境运行
gx.run {
  local: "./test.gxl",
  isolate: true
}
</code></pre>
<h2 id="gxdefined"><a class="header" href="#gxdefined">gx.defined</a></h2>
<h3 id="功能描述-12"><a class="header" href="#功能描述-12">功能描述</a></h3>
<p>检查变量是否已定义。</p>
<h3 id="语法定义-12"><a class="header" href="#语法定义-12">语法定义</a></h3>
<pre><code class="language-gxl">gx.defined(${变量名})
</code></pre>
<h3 id="示例代码-14"><a class="header" href="#示例代码-14">示例代码</a></h3>
<pre><code class="language-gxl">// 检查变量是否已定义
if (gx.defined(${MY_VAR})) {
  gx.echo { value: "MY_VAR已定义，值为: ${MY_VAR}" }
} else {
  gx.echo { value: "MY_VAR未定义" }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxartifact-1"><a class="header" href="#gxartifact-1">gx.artifact</a></h1>
<h2 id="功能描述-13"><a class="header" href="#功能描述-13">功能描述</a></h2>
<p>处理构建产物文件。</p>
<h2 id="语法定义-13"><a class="header" href="#语法定义-13">语法定义</a></h2>
<pre><code class="language-gxl">gx.artifact {
  file: &lt;文件路径&gt;,       // 构建产物文件路径
  dst_path: &lt;目标路径&gt;    // 目标存储路径
}
</code></pre>
<h2 id="示例代码-15"><a class="header" href="#示例代码-15">示例代码</a></h2>
<pre><code class="language-gxl">// 处理构建产物
gx.artifact {
  file: "target/release/myapp",
  dst_path: "artifacts/v1.0.0/"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxassert-1"><a class="header" href="#gxassert-1">gx.assert</a></h1>
<h2 id="功能描述-14"><a class="header" href="#功能描述-14">功能描述</a></h2>
<p>执行断言检查，验证表达式的值是否符合预期。</p>
<h2 id="语法定义-14"><a class="header" href="#语法定义-14">语法定义</a></h2>
<pre><code class="language-gxl">gx.assert {
  value: &lt;表达式&gt;,      // 要检查的值
  expect: &lt;期望值&gt;,     // 期望的值
  err: &lt;错误信息&gt;,      // 断言失败时的错误信息（可选）
  result: &lt;变量名&gt;      // 存储断言结果的变量名（可选）
}
</code></pre>
<h2 id="示例代码-16"><a class="header" href="#示例代码-16">示例代码</a></h2>
<pre><code class="language-gxl">// 检查变量值是否等于期望值
gx.assert {
  value: ${MY_VAR},
  expect: "expected_value",
  err: "MY_VAR值不正确"
}

// 检查表达式结果并存储结果
gx.assert {
  value: ${CALC_RESULT},
  expect: 42,
  result: "assert_result"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxcmd-1"><a class="header" href="#gxcmd-1">gx.cmd</a></h1>
<h2 id="功能描述-15"><a class="header" href="#功能描述-15">功能描述</a></h2>
<p>执行系统命令或脚本。</p>
<h2 id="语法定义-15"><a class="header" href="#语法定义-15">语法定义</a></h2>
<pre><code class="language-gxl">gx.cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  shell: &lt;Shell类型&gt;,    // 指定使用的Shell（可选）
  out: &lt;输出变量名&gt;,     // 捕获命令标准输出的变量名（可选）
  err: &lt;错误变量名&gt;,     // 捕获命令错误输出的变量名（可选）
  suc: &lt;成功标识&gt;,       // 命令执行成功的标识（可选）
  sudo: &lt;布尔值&gt;,        // 是否使用sudo权限执行（可选）
  log: &lt;日志级别&gt;,       // 日志记录级别（可选）
  silence: &lt;布尔值&gt;      // 是否静默执行（可选）
}
</code></pre>
<h2 id="示例代码-17"><a class="header" href="#示例代码-17">示例代码</a></h2>
<pre><code class="language-gxl">// 执行简单命令
gx.cmd {
  cmd: "ls -la"
}

// 执行命令并捕获输出
gx.cmd {
  cmd: "date",
  out: "current_date"
}

// 使用sudo权限执行命令
gx.cmd {
  cmd: "systemctl restart nginx",
  sudo: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxdefined-1"><a class="header" href="#gxdefined-1">gx.defined</a></h1>
<h2 id="功能描述-16"><a class="header" href="#功能描述-16">功能描述</a></h2>
<p>检查变量是否已定义。</p>
<h2 id="语法定义-16"><a class="header" href="#语法定义-16">语法定义</a></h2>
<pre><code class="language-gxl">gx.defined(${变量名})
</code></pre>
<h2 id="示例代码-18"><a class="header" href="#示例代码-18">示例代码</a></h2>
<pre><code class="language-gxl">// 检查变量是否已定义
if (gx.defined(${MY_VAR})) {
  gx.echo { value: "MY_VAR已定义，值为: ${MY_VAR}" }
} else {
  gx.echo { value: "MY_VAR未定义" }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxdownload-和-gxupload-1"><a class="header" href="#gxdownload-和-gxupload-1">gx.download 和 gx.upload</a></h1>
<h2 id="功能描述-17"><a class="header" href="#功能描述-17">功能描述</a></h2>
<p>下载和上传文件。</p>
<h2 id="语法定义-17"><a class="header" href="#语法定义-17">语法定义</a></h2>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: &lt;下载URL&gt;,        // 文件下载URL
  local_file: &lt;本地路径&gt;, // 保存到本地的文件路径
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}

// 上传文件
gx.upload {
  url: &lt;上传URL&gt;,        // 文件上传URL
  local_file: &lt;本地路径&gt;, // 要上传的本地文件路径
  method: &lt;HTTP方法&gt;,     // HTTP方法（如POST、PUT等，默认POST）
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}
</code></pre>
<h2 id="示例代码-19"><a class="header" href="#示例代码-19">示例代码</a></h2>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: "https://example.com/file.zip",
  local_file: "downloaded_file.zip"
}

// 上传文件
gx.upload {
  url: "https://example.com/upload",
  local_file: "local_file.txt",
  method: "POST"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxecho-1"><a class="header" href="#gxecho-1">gx.echo</a></h1>
<h2 id="功能描述-18"><a class="header" href="#功能描述-18">功能描述</a></h2>
<p>输出文本信息到控制台。</p>
<h2 id="语法定义-18"><a class="header" href="#语法定义-18">语法定义</a></h2>
<pre><code class="language-gxl">gx.echo {
  value: &lt;文本内容&gt;,     // 要输出的文本内容
  file: &lt;文件路径&gt;,      // 输出到文件的路径（可选）
  export: &lt;变量名&gt;,      // 导出为环境变量的名称（可选）
  inc: &lt;布尔值&gt;          // 是否追加到文件末尾（可选）
}
</code></pre>
<h2 id="示例代码-20"><a class="header" href="#示例代码-20">示例代码</a></h2>
<pre><code class="language-gxl">// 输出简单文本
gx.echo {
  value: "Hello, Galaxy Flow!"
}

// 输出到文件
gx.echo {
  value: "This is a log entry",
  file: "app.log"
}

// 追加到文件
gx.echo {
  value: "Additional information",
  file: "app.log",
  inc: true
}

// 导出为环境变量
gx.echo {
  value: "production",
  export: "ENV_TYPE"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxread-1"><a class="header" href="#gxread-1">gx.read</a></h1>
<h2 id="功能描述-19"><a class="header" href="#功能描述-19">功能描述</a></h2>
<p>从不同来源读取数据并存储到变量中。</p>
<h2 id="语法定义-19"><a class="header" href="#语法定义-19">语法定义</a></h2>
<pre><code class="language-gxl">// 从文件读取
gx.read_file {
  file: &lt;文件路径&gt;,      // 要读取的文件路径
  name: &lt;变量名&gt;         // 存储文件内容的变量名
}

// 从标准输入读取
gx.read_stdin {
  name: &lt;变量名&gt;,        // 存储输入内容的变量名
  prompt: &lt;提示文本&gt;     // 输入提示文本（可选）
}

// 从命令输出读取
gx.read_cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  name: &lt;变量名&gt;,        // 存储命令输出的变量名
  shell: &lt;Shell类型&gt;     // 指定使用的Shell（可选）
}
</code></pre>
<h2 id="示例代码-21"><a class="header" href="#示例代码-21">示例代码</a></h2>
<pre><code class="language-gxl">// 从文件读取内容
gx.read_file {
  file: "config.json",
  name: "config_data"
}

// 从标准输入读取
gx.read_stdin {
  name: "user_input",
  prompt: "请输入您的姓名: "
}

// 从命令输出读取
gx.read_cmd {
  cmd: "git rev-parse HEAD",
  name: "commit_hash"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxrun-1"><a class="header" href="#gxrun-1">gx.run</a></h1>
<h2 id="功能描述-20"><a class="header" href="#功能描述-20">功能描述</a></h2>
<p>运行其他GXL工作流文件。</p>
<h2 id="语法定义-20"><a class="header" href="#语法定义-20">语法定义</a></h2>
<pre><code class="language-gxl">gx.run {
  local: &lt;工作流路径&gt;,    // 要运行的工作流文件路径
  env: &lt;环境配置&gt;,        // 环境配置（可选）
  flow: &lt;流程列表&gt;,       // 要执行的流程列表（可选）
  conf: &lt;配置文件&gt;,       // 配置文件路径（可选）
  isolate: &lt;布尔值&gt;       // 是否隔离环境（可选）
}
</code></pre>
<h2 id="示例代码-22"><a class="header" href="#示例代码-22">示例代码</a></h2>
<pre><code class="language-gxl">// 运行其他工作流
gx.run {
  local: "./subflow.gxl"
}

// 在特定环境中运行工作流
gx.run {
  local: "./deploy.gxl",
  env: "production",
  flow: "build,deploy"
}

// 隔离环境运行
gx.run {
  local: "./test.gxl",
  isolate: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxshell-1"><a class="header" href="#gxshell-1">gx.shell</a></h1>
<h2 id="功能描述-21"><a class="header" href="#功能描述-21">功能描述</a></h2>
<p>执行Shell脚本文件。</p>
<h2 id="语法定义-21"><a class="header" href="#语法定义-21">语法定义</a></h2>
<pre><code class="language-gxl">gx.shell {
  shell: &lt;脚本文件路径&gt;,  // 要执行的Shell脚本文件路径
  arg_file: &lt;参数文件&gt;,   // 参数文件路径（可选）
  out_var: &lt;输出变量名&gt;,  // 捕获脚本输出的变量名（可选）
  default: &lt;默认脚本&gt;     // 默认脚本文件路径（可选，与shell互斥）
}
</code></pre>
<h2 id="示例代码-23"><a class="header" href="#示例代码-23">示例代码</a></h2>
<pre><code class="language-gxl">// 执行Shell脚本
gx.shell {
  shell: "deploy.sh"
}

// 执行脚本并捕获输出
gx.shell {
  shell: "build.sh",
  out_var: "build_output"
}

// 使用参数文件
gx.shell {
  shell: "install.sh",
  arg_file: "install.args"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxtar-和-gxuntar-1"><a class="header" href="#gxtar-和-gxuntar-1">gx.tar 和 gx.untar</a></h1>
<h2 id="功能描述-22"><a class="header" href="#功能描述-22">功能描述</a></h2>
<p>创建和解压tar归档文件。</p>
<h2 id="语法定义-22"><a class="header" href="#语法定义-22">语法定义</a></h2>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: &lt;源文件/目录&gt;,     // 要归档的源文件或目录
  file: &lt;归档文件名&gt;      // 生成的归档文件名
}

// 解压tar归档
gx.untar {
  file: &lt;归档文件名&gt;,     // 要解压的归档文件
  dst: &lt;目标目录&gt;         // 解压到的目标目录
}
</code></pre>
<h2 id="示例代码-24"><a class="header" href="#示例代码-24">示例代码</a></h2>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: "src/",
  file: "source.tar"
}

// 解压tar归档
gx.untar {
  file: "source.tar",
  dst: "extracted/"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxtpl-1"><a class="header" href="#gxtpl-1">gx.tpl</a></h1>
<h2 id="功能描述-23"><a class="header" href="#功能描述-23">功能描述</a></h2>
<p>使用模板引擎处理文件模板。</p>
<h2 id="语法定义-23"><a class="header" href="#语法定义-23">语法定义</a></h2>
<pre><code class="language-gxl">gx.tpl {
  tpl: &lt;模板内容&gt;,       // 模板内容
  dst: &lt;目标文件路径&gt;,   // 生成文件的路径
  data: &lt;数据变量名&gt;,    // 模板数据变量名（可选）
  engine: &lt;引擎类型&gt;,    // 模板引擎类型（可选）
  file: &lt;模板文件路径&gt;   // 模板文件路径（可选，与tpl互斥）
}
</code></pre>
<h2 id="示例代码-25"><a class="header" href="#示例代码-25">示例代码</a></h2>
<pre><code class="language-gxl">// 使用内联模板
gx.tpl {
  tpl: "Hello, {{name}}! Welcome to {{app_name}}.",
  dst: "output.txt",
  data: "user_data"
}

// 使用模板文件
gx.tpl {
  file: "template.txt",
  dst: "output.txt",
  data: "template_data"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxvars-1"><a class="header" href="#gxvars-1">gx.vars</a></h1>
<h2 id="功能描述-24"><a class="header" href="#功能描述-24">功能描述</a></h2>
<p>定义和设置多个变量。</p>
<h2 id="语法定义-24"><a class="header" href="#语法定义-24">语法定义</a></h2>
<pre><code class="language-gxl">gx.vars {
  &lt;变量名1&gt;: &lt;值1&gt;,      // 变量名和对应的值
  &lt;变量名2&gt;: &lt;值2&gt;,      // 可以定义多个变量
  // ...
}
</code></pre>
<h2 id="示例代码-26"><a class="header" href="#示例代码-26">示例代码</a></h2>
<pre><code class="language-gxl">// 定义多个变量
gx.vars {
  app_name: "MyApp",
  version: "1.0.0",
  debug: true
}

// 使用变量引用
gx.vars {
  project_root: "${HOME}/projects",
  config_file: "${project_root}/config.yaml"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxver-1"><a class="header" href="#gxver-1">gx.ver</a></h1>
<h2 id="功能描述-25"><a class="header" href="#功能描述-25">功能描述</a></h2>
<p>管理和操作版本信息。</p>
<h2 id="语法定义-25"><a class="header" href="#语法定义-25">语法定义</a></h2>
<pre><code class="language-gxl">gx.ver {
  value: &lt;版本值&gt;,       // 版本值
  default: &lt;默认值&gt;,     // 默认版本值（可选）
  file: &lt;文件路径&gt;,      // 版本文件路径（可选）
  export: &lt;变量名&gt;,      // 导出版本信息的变量名（可选）
  inc: &lt;递增类型&gt;        // 版本递增类型（可选，可选值：build/bugfix/feature/main）
}
</code></pre>
<h2 id="示例代码-27"><a class="header" href="#示例代码-27">示例代码</a></h2>
<pre><code class="language-gxl">// 设置版本值
gx.ver {
  value: "1.2.3"
}

// 从文件读取版本并递增
gx.ver {
  file: "VERSION",
  inc: "feature"
}

// 导出版本信息
gx.ver {
  value: "2.0.0",
  export: "APP_VERSION"
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./mermaid.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>

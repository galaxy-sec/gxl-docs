<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>galaxy-sec operator ecosystem</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mermaid.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">galaxy-sec operator ecosystem</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="galaxy-sec--operator--ecosystem"><a class="header" href="#galaxy-sec--operator--ecosystem">Galaxy-Sec  Operator  Ecosystem</a></h1>
<h2 id="包括"><a class="header" href="#包括">包括：</a></h2>
<ul>
<li>DSL语言: Gxl</li>
<li>维护器</li>
<li>命令工具
<ul>
<li>gflow :Gxl的执行器</li>
<li>gops : 维护工程</li>
<li>gsys ：系统维护器</li>
<li>gmod ：模块维护器</li>
</ul>
</li>
</ul>
<h2 id="核心流程"><a class="header" href="#核心流程">核心流程</a></h2>
<ul>
<li>1、gmod 创建模块维护器，用gxl 编写维护器的workflow</li>
<li>2、gsys 创建系统维护器，并组合多个模块维护器,用gxl 编写维护器的workflow</li>
<li>3、系统维护器 保存到配置管理库中，待发布到客户环境。</li>
<li>4、在客户环境中，使用gops 创建维护工程， 并加载系统维护器。</li>
<li>5、在客户环境中，使用gflow 执行维护器的workflow。</li>
<li>6、保存维护工程到配置管理库中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h1 id="galaxy-flow-v083--v086-发布说明"><a class="header" href="#galaxy-flow-v083--v086-发布说明">Galaxy Flow v0.8.3 → v0.8.6 发布说明</a></h1>
<h2 id="-版本信息"><a class="header" href="#-版本信息">🚀 版本信息</a></h2>
<ul>
<li>起始版本 : v0.8.3</li>
<li>目标版本 : v0.8.6</li>
<li>当前版本 : 0.8.6</li>
</ul>
<h2 id="-主要新功能"><a class="header" href="#-主要新功能">✨ 主要新功能</a></h2>
<h3 id="1-日志重定向系统重构"><a class="header" href="#1-日志重定向系统重构">1. 日志重定向系统重构</a></h3>
<ul>
<li>新增 : 使用管道(pip)进行日志重定向的全新实现</li>
<li>优化 : 改进了日志处理机制，提高了性能和稳定性</li>
<li>提交 : a5bf576 , deea236 , 2e1ce2c , be686b1 , 4e3f1a7</li>
</ul>
<h3 id="2-逻辑表达式支持"><a class="header" href="#2-逻辑表达式支持">2. 逻辑表达式支持</a></h3>
<ul>
<li>新增 : 逻辑表达式( logic_exp )功能实现</li>
<li>实现 : 完整的逻辑表达式解析和执行能力</li>
<li>提交 : d646fd4 , fc7c975</li>
</ul>
<h3 id="3-归档功能增强"><a class="header" href="#3-归档功能增强">3. 归档功能增强</a></h3>
<ul>
<li>新增 : gx.tar 和 gx.untar 命令支持</li>
<li>用途 : 提供原生的压缩和解压缩能力</li>
<li>提交 : 1755d4d</li>
</ul>
<h2 id="-改进与优化"><a class="header" href="#-改进与优化">🔧 改进与优化</a></h2>
<h3 id="代码质量"><a class="header" href="#代码质量">代码质量</a></h3>
<ul>
<li>重构 : 成功状态处理逻辑重构 ( 6dce866 )</li>
<li>优化 : 表达式逻辑更新 ( 73dcb46 )</li>
<li>清理 : 取消taskvalue中的日志信息 ( 523f85b )</li>
</ul>
<h3 id="依赖更新"><a class="header" href="#依赖更新">依赖更新</a></h3>
<ul>
<li>更新 : clap依赖升级到最新版本 ( 9246378 )</li>
<li>更新 : 多个crate依赖项更新 ( 1051001 , 352e19a )</li>
<li>维护 : 代码格式化和clippy修复 ( 08b51f2 , c57879b , b049906 )</li>
</ul>
<h2 id="-问题修复"><a class="header" href="#-问题修复">🐛 问题修复</a></h2>
<h3 id="关键修复"><a class="header" href="#关键修复">关键修复</a></h3>
<ul>
<li>修复 : 模块路径错误问题 (#61) - d099a55</li>
<li>修复 : 多个相关问题 (#62, #61) - 4419cad</li>
<li>修复 : 模块名称列表问题 - 19bfa32</li>
</ul>
<h3 id="其他修复"><a class="header" href="#其他修复">其他修复</a></h3>
<ul>
<li>修复 : 通道与启用状态的关联问题 - 5592286</li>
<li>修复 : 干运行参数传递给子gxl的问题 - 4644a1b</li>
</ul>
<h2 id="-其他变更"><a class="header" href="#-其他变更">📋 其他变更</a></h2>
<h3 id="构建和部署"><a class="header" href="#构建和部署">构建和部署</a></h3>
<ul>
<li>更新 : artifact构建更新 ( 9c1193d )</li>
<li>更新 : 管理配置更新 ( 3dcc127 )</li>
<li>维护 : 版本号更新到0.8.6 ( 2f4acfe , 5b4dbb0 )</li>
</ul>
<h3 id="内部改进"><a class="header" href="#内部改进">内部改进</a></h3>
<ul>
<li>重构 : 使用常量字符串优化 ( 64e7d30 , daf17ef )</li>
<li>新增 : 读取文件日志功能 ( 142b448 )</li>
</ul>
<h2 id="-升级建议"><a class="header" href="#-升级建议">📝 升级建议</a></h2>
<ol>
<li>
<ol>
<li></li>
</ol>
平滑升级 : 从v0.8.3升级到v0.8.6是向后兼容的</li>
<li>
<ol start="2">
<li></li>
</ol>
新功能试用 : 建议尝试新的日志重定向和逻辑表达式功能</li>
<li>
<ol start="3">
<li></li>
</ol>
依赖检查 : 确保所有依赖项已更新到兼容版本</li>
</ol>
<h2 id="-变更统计"><a class="header" href="#-变更统计">📊 变更统计</a></h2>
<ul>
<li>总提交数 : 30+ 次提交</li>
<li>功能新增 : 5个主要功能</li>
<li>问题修复 : 6个关键修复</li>
<li>代码优化 : 10+ 项改进
本次发布专注于提升系统稳定性、增加新功能，并修复已知问题，为用户提供更好的DevSecOps自动化体验。</li>
</ul>
<h1 id="083"><a class="header" href="#083">0.8.3</a></h1>
<h2 id="新增"><a class="header" href="#新增">新增</a></h2>
<ul>
<li>GXL 支持 数字、BOOL、数组、对象 数据类型</li>
<li>提供 defined 函数 - 检查变量是否已定义</li>
<li>提供 gx.shell 方便 shell 调用</li>
<li>支持 ${VAR:default} 变量定义默认值</li>
<li>gprj update mod 或 gflow --update mod 支持更新项目依赖的Mod</li>
</ul>
<h2 id="改进"><a class="header" href="#改进">改进</a></h2>
<ul>
<li>gx.read_file 读取内容到对象，便于后续处理</li>
<li>winnow 升级 0.7</li>
<li>对于远程Mod的获取，去掉外部Git 依赖</li>
<li>修改外部依赖</li>
</ul>
<h1 id="070"><a class="header" href="#070">0.7.0</a></h1>
<h2 id="新增-1"><a class="header" href="#新增-1">新增</a></h2>
<ul>
<li>支持事务机制</li>
<li>支持dryrun机制 - 允许预览操作结果而不实际执行</li>
</ul>
<h1 id="064"><a class="header" href="#064">0.6.4</a></h1>
<h2 id="新增-2"><a class="header" href="#新增-2">新增</a></h2>
<ul>
<li>支持 gx.cmd  quiet (静默） - 自定义控制cmd的日志输出与否</li>
</ul>
<h1 id="062"><a class="header" href="#062">0.6.2</a></h1>
<h2 id="新增-3"><a class="header" href="#新增-3">新增</a></h2>
<ul>
<li>优化日志输出，增加日志的重定向，支持捕获控制台标准日志输出</li>
</ul>
<h1 id="060"><a class="header" href="#060">0.6.0</a></h1>
<h2 id="新增-4"><a class="header" href="#新增-4">新增</a></h2>
<ul>
<li>生成任务报告 - 提供执行过程和结果的详细信息</li>
<li>支持flow上的Task注解 - 增强流程定义的灵活性</li>
</ul>
<h2 id="改进-1"><a class="header" href="#改进-1">改进</a></h2>
<ul>
<li>改进 flow 编排语法，由: 变为 |  符号</li>
</ul>
<h1 id="gflow-053"><a class="header" href="#gflow-053">gflow-0.5.3</a></h1>
<h2 id="内置环境变量"><a class="header" href="#内置环境变量">内置环境变量</a></h2>
<ul>
<li>GXL_PRJ_ROOT:    最近定义的 _gal/project.toml 的目录</li>
</ul>
<h2 id="extern-mod-支持变量"><a class="header" href="#extern-mod-支持变量">extern mod 支持变量</a></h2>
<pre><code>extern mod head { path = "${GXL_START_ROOT}/_gal/"; }
</code></pre>
<p><a href="https://github.com/galaxy-sec/galaxy-flow/releases/tag/v0.5.3">0.5.3 下载</a></p>
<h1 id="052"><a class="header" href="#052">0.5.2</a></h1>
<h2 id="内置环境变量-1"><a class="header" href="#内置环境变量-1">内置环境变量</a></h2>
<ul>
<li>GXL_START_ROOT:  GXL 启动处理的目录</li>
<li>GXL_CUR_DIR:  GXL 当前所在目录，在调用gx.run时，与GXL_START_ROOT可能不同</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gflow-命令使用文档"><a class="header" href="#gflow-命令使用文档">gflow 命令使用文档</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p><code>gflow</code> 是 Galaxy Flow 的核心执行引擎，用于运行 GXL 流程文件。</p>
<h2 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h2>
<pre><code class="language-bash">gflow [OPTIONS] [FLOW]...
</code></pre>
<h2 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h2>
<h3 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h3>
<ul>
<li><code>FLOW...</code>: 要执行的流程名称，例如：conf, test, package</li>
</ul>
<h3 id="选项参数"><a class="header" href="#选项参数">选项参数</a></h3>
<ul>
<li><code>-e, --env &lt;ENV&gt;</code>: 环境名称，例如：-e dev（默认：default）</li>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别，例如：-d 1（默认：0）</li>
<li><code>-f, --conf &lt;CONF&gt;</code>: 配置文件路径，默认为：
<ul>
<li>work: <code>./_rg/work.gxl</code></li>
<li>adm: <code>./_rg/adm.gxl</code></li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code>: 配置日志级别，例如：--log cmd=debug,parse=info</li>
<li><code>-q, --quiet</code>: 静默模式</li>
<li><code>-h, --help</code>: 显示帮助信息</li>
<li><code>-V, --version</code>: 显示版本信息</li>
</ul>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<h3 id="基本执行"><a class="header" href="#基本执行">基本执行</a></h3>
<pre><code class="language-bash"># 执行默认工作流
gflow

# 执行指定流程
gflow conf test package
</code></pre>
<h3 id="环境切换"><a class="header" href="#环境切换">环境切换</a></h3>
<pre><code class="language-bash"># 使用开发环境
gflow -e dev

# 使用生产环境
gflow -e prod
</code></pre>
<h3 id="调试模式"><a class="header" href="#调试模式">调试模式</a></h3>
<pre><code class="language-bash"># 启用调试模式
gflow -d 2

# 配置详细日志
gflow --log cmd=debug,parse=info
</code></pre>
<h3 id="指定配置"><a class="header" href="#指定配置">指定配置</a></h3>
<pre><code class="language-bash"># 使用自定义配置文件
gflow -f ./config/my-config.gxl
</code></pre>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<p>默认配置文件为：</p>
<ul>
<li><code>./_rg/work.gxl</code> - 工作流配置</li>
<li><code>./_rg/adm.gxl</code> - 管理配置</li>
</ul>
<p>配置文件包含：</p>
<ul>
<li>任务定义</li>
<li>变量配置</li>
<li>模块引用</li>
<li>执行策略</li>
</ul>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<ul>
<li><code>GALAXY_FLOW_HOME</code>: Galaxy Flow 主目录</li>
<li><code>RUST_LOG</code>: Rust 日志级别</li>
</ul>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<ul>
<li><code>0</code>: 执行成功</li>
<li><code>非0</code>: 执行失败，返回错误码</li>
</ul>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<h3 id="找不到配置文件"><a class="header" href="#找不到配置文件">找不到配置文件</a></h3>
<p>确保当前目录下有 <code>_rg/work.gxl</code> 或 <code>_rg/adm.gxl</code> 文件，或使用 <code>-f</code> 指定配置文件。</p>
<h3 id="权限问题"><a class="header" href="#权限问题">权限问题</a></h3>
<p>确保有执行权限：</p>
<pre><code class="language-bash">chmod +x gflow
</code></pre>
<h3 id="模块加载失败"><a class="header" href="#模块加载失败">模块加载失败</a></h3>
<p>检查网络连接和模块路径配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod---galaxy-module-management-tool"><a class="header" href="#gmod---galaxy-module-management-tool">gmod - Galaxy Module Management Tool</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p><code>gmod</code> 是 Galaxy 模块管理工具，用于创建、更新和本地化 Galaxy 模块。它提供了完整的模块生命周期管理功能，帮助开发者快速构建和维护 Galaxy 项目。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<pre><code class="language-bash"># 从源代码安装
cargo install --path .

# 或者使用二进制分发
curl -fsSL https://github.com/galaxy-sec/galaxy-ops/releases/latest/download/gmod.tar.gz | tar -xz
sudo mv gmod /usr/local/bin/
</code></pre>
<h2 id="基本用法-1"><a class="header" href="#基本用法-1">基本用法</a></h2>
<h3 id="显示版本信息"><a class="header" href="#显示版本信息">显示版本信息</a></h3>
<pre><code class="language-bash">gmod
# 输出示例：gmod: 1.0.0
</code></pre>
<h3 id="显示帮助信息"><a class="header" href="#显示帮助信息">显示帮助信息</a></h3>
<pre><code class="language-bash">gmod --help
gmod &lt;command&gt; --help
</code></pre>
<h2 id="命令详解"><a class="header" href="#命令详解">命令详解</a></h2>
<h3 id="gmod-example"><a class="header" href="#gmod-example">gmod example</a></h3>
<p>创建示例模块结构</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod example
</code></pre>
<p><strong>功能：</strong></p>
<ul>
<li>在当前目录创建完整的示例模块结构</li>
<li>包含所有必需的配置文件和模板</li>
<li>展示模块组织的最佳实践</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash">gmod example
# 创建示例模块到当前目录
</code></pre>
<h3 id="gmod-new"><a class="header" href="#gmod-new">gmod new</a></h3>
<p>定义新的模块规范</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 模块名称（字母数字，可包含连字符和下划线）【必填】</li>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li>0：关闭调试输出</li>
<li>1：基础调试信息</li>
<li>2：详细调试信息</li>
<li>3：跟踪调试信息</li>
<li>4：完整调试信息</li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置（格式：模块=级别,模块=级别）</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的新模块</li>
<li>初始化模块目录结构</li>
<li>生成所有必需的配置文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 "my-module" 的新模块
gmod new --name my-module

# 创建模块并启用调试输出
gmod new --name my-module --debug 2

# 创建模块并配置日志
gmod new --name my-module --log cmd=debug,parse=info
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>创建目录：my-module/
生成配置文件：my-module/mod.yml
生成配置文件：my-module/module.yaml
生成模板文件：my-module/templates/
生成示例文件：my-module/examples/
</code></pre>
<h3 id="gmod-update"><a class="header" href="#gmod-update">gmod update</a></h3>
<p>更新现有模块的依赖关系</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：正常更新</li>
<li>1：跳过确认</li>
<li>2：覆盖现有文件</li>
<li>3：强制 git pull</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新模块的依赖关系</li>
<li>下载远程引用的模块</li>
<li>支持强制更新模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新模块
gmod update

# 强制更新，跳过确认
gmod update --force 1

# 详细调试输出更新过程
gmod update --debug 3 --log all=debug
</code></pre>
<h3 id="gmod-localize"><a class="header" href="#gmod-localize">gmod localize</a></h3>
<p>本地化模块配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gmod localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 值文件路径（YAML/JSON）</li>
<li><code>--default</code> - 使用默认值，不使用用户提供的 value.yml</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>根据环境特定的值生成本地化配置</li>
<li>支持多环境配置管理</li>
<li>可选择使用自定义或默认值</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认值本地化
gmod localize --default

# 使用自定义值文件本地化
gmod localize --value prod-values.yml

# 使用自定义值文件并启用调试
gmod localize --value dev-values.yml --debug 2
</code></pre>
<h2 id="环境变量-1"><a class="header" href="#环境变量-1">环境变量</a></h2>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置</li>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态</li>
</ul>
<h2 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h2>
<h3 id="模块配置结构"><a class="header" href="#模块配置结构">模块配置结构</a></h3>
<pre><code>my-module/
├── mod.yml                    # 模块主配置文件
├── module.yaml               # 模块元数据
├── templates/                # 模板目录
├── examples/                # 示例文件
└── config/                  # 配置文件
    ├── default.yml          # 默认配置
    ├── local.yml            # 本地配置
    └── env/                  # 环境特定配置
        ├── dev.yml
        ├── staging.yml
        └── prod.yml
</code></pre>
<h3 id="modyml-示例"><a class="header" href="#modyml-示例">mod.yml 示例</a></h3>
<pre><code class="language-yaml">name: my-module
version: "1.0.0"
description: "My Galaxy Module"
author: "Your Name &lt;your.email@example.com&gt;"

dependencies:
  - galaxy/core: "&gt;=1.0.0"
  - galaxy/utils: "~2.0.0"

sources:
  - type: git
    url: "https://github.com/username/my-module.git"
    ref: main

outputs:
  - name: main
    path: "build/output"
    format: tar.gz
</code></pre>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<h3 id="模块命名"><a class="header" href="#模块命名">模块命名</a></h3>
<ul>
<li>使用小写字母、数字、连字符和下划线</li>
<li>避免特殊字符和空格</li>
<li>使用有意义的名称，如：<code>user-service-api</code></li>
</ul>
<h3 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h3>
<ul>
<li>使用语义化版本控制</li>
<li>定期更新依赖：<code>gmod update --force 1</code></li>
<li>在生产环境使用锁定版本</li>
</ul>
<h3 id="配置管理"><a class="header" href="#配置管理">配置管理</a></h3>
<ul>
<li>使用环境特定的配置文件</li>
<li>在 CI/CD 流程中自动本地化</li>
<li>使用默认配置作为后备</li>
</ul>
<h3 id="调试技巧"><a class="header" href="#调试技巧">调试技巧</a></h3>
<pre><code class="language-bash"># 启用完整调试输出
gmod update --debug 4 --log all=debug

# 检查模块依赖关系
gmod new --name debug-test --debug 2

# 使用详细日志进行故障排除
gmod localize --debug 3 --log cmd=debug,net=trace
</code></pre>
<h2 id="故障排除"><a class="header" href="#故障排除">故障排除</a></h2>
<h3 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h3>
<p><strong>Q: 创建模块失败</strong></p>
<pre><code>错误：无法创建目录 "my-module"
原因：目录已存在或权限不足
解决：删除现有目录或检查权限
</code></pre>
<p><strong>Q: 更新模块时网络错误</strong></p>
<pre><code>错误：无法下载依赖
解决：检查网络连接和 git 配置
gmod update --debug 3 --log net=debug
</code></pre>
<p><strong>Q: 本地化失败</strong></p>
<pre><code>错误：无法解析值文件
解决：检查 YAML/JSON 格式是否正确
gmod localize --value config.yml --debug 2
</code></pre>
<h3 id="调试模式-1"><a class="header" href="#调试模式-1">调试模式</a></h3>
<p>使用调试模式获取详细的执行信息：</p>
<pre><code class="language-bash"># 最高级别调试
gmod update --debug 4 --log all=debug

# 关键模块调试
gmod new --name test --debug 3 --log cmd=debug
</code></pre>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxmod_cmd_app_creation

# 运行测试并显示输出
cargo test -- --nocapture
</code></pre>
<h2 id="示例工作流"><a class="header" href="#示例工作流">示例工作流</a></h2>
<h3 id="开发新模块"><a class="header" href="#开发新模块">开发新模块</a></h3>
<pre><code class="language-bash"># 1. 创建新模块
gmod new --name user-service

# 2. 编辑模块配置
cd user-service
vim mod.yml

# 3. 开发功能
# ... 编码 ...

# 4. 更新依赖
cd ..
gmod update

# 5. 本地化配置
gmod localize --value dev-values.yml

# 6. 验证模块
gmod example
</code></pre>
<h3 id="部署到生产环境"><a class="header" href="#部署到生产环境">部署到生产环境</a></h3>
<pre><code class="language-bash"># 1. 创建生产模块
gmod new --name user-service-prod

# 2. 更新到最新版本
gmod update --force 3

# 3. 使用生产配置本地化
gmod localize --value prod-values.yml

# 4. 验证配置
ls -la user-service-prod/config/env/prod.yml
</code></pre>
<h2 id="版本历史"><a class="header" href="#版本历史">版本历史</a></h2>
<h3 id="当前版本100"><a class="header" href="#当前版本100">当前版本：1.0.0</a></h3>
<ul>
<li>初始版本</li>
<li>支持模块创建、更新和本地化</li>
<li>完整的错误处理和日志记录</li>
</ul>
<h2 id="贡献指南"><a class="header" href="#贡献指南">贡献指南</a></h2>
<p>欢迎贡献代码和建议：</p>
<ol>
<li>Fork 项目（https://github.com/galaxy-sec/galaxy-ops）</li>
<li>创建特性分支</li>
<li>提交更改</li>
<li>推送到分支</li>
<li>创建 Pull Request</li>
</ol>
<h2 id="许可证"><a class="header" href="#许可证">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gops---galaxy-operations-system-系统操作管理工具"><a class="header" href="#gops---galaxy-operations-system-系统操作管理工具">gops - Galaxy Operations System 系统操作管理工具</a></h1>
<h2 id="概述-2"><a class="header" href="#概述-2">概述</a></h2>
<p><code>gops</code> 是 Galaxy Operations System 的核心管理工具，用于管理系统配置、导入模块、更新引用等操作。它提供了完整的系统操作功能，帮助开发者高效地管理 Galaxy 系统的各种配置和操作。</p>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<pre><code class="language-bash"># 从源代码安装
cargo install --path .

# 或者使用二进制分发
https://github.com/galaxy-sec/galaxy-ops/releases/latest/
</code></pre>
<h2 id="基本用法-2"><a class="header" href="#基本用法-2">基本用法</a></h2>
<h3 id="显示版本信息-1"><a class="header" href="#显示版本信息-1">显示版本信息</a></h3>
<pre><code class="language-bash">gops
# 输出示例：gops: 1.0.0
</code></pre>
<h3 id="显示帮助信息-1"><a class="header" href="#显示帮助信息-1">显示帮助信息</a></h3>
<pre><code class="language-bash">gops --help
gops &lt;command&gt; --help
</code></pre>
<h2 id="命令详解-1"><a class="header" href="#命令详解-1">命令详解</a></h2>
<h3 id="gops-new"><a class="header" href="#gops-new">gops new</a></h3>
<p>创建新的系统配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 系统配置名称（必填）
<ul>
<li>系统配置的唯一标识名称</li>
<li>支持字母数字、连字符和下划线</li>
<li>必须为非空字符串</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的新系统配置</li>
<li>初始化系统配置目录结构</li>
<li>生成所有必需的配置文件</li>
<li>设置默认的系统配置参数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 "my-config" 的新系统配置
gops new --name my-config

# 创建带详细调试的系统配置
gops new --name debug-config --debug 2
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>创建目录：my-config/
生成配置文件：my-config/ops_config.yml
生成模板文件：my-config/templates/
生成示例文件：my-config/examples/
生成脚本文件：my-config/scripts/
</code></pre>
<h3 id="gops-import"><a class="header" href="#gops-import">gops import</a></h3>
<p>导入外部模块到当前系统</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops import [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li>0：关闭调试输出</li>
<li>1：基础调试信息</li>
<li>2：详细调试信息</li>
<li>3：跟踪调试信息</li>
<li>4：完整调试信息</li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置（格式：模块=级别,模块=级别）</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：不强制更新</li>
<li>1：强制更新引用</li>
<li>2：强制更新依赖</li>
<li>3：强制更新所有内容</li>
</ul>
</li>
<li><code>-p, --path &lt;PATH&gt;</code> - 模块导入路径（必填）
<ul>
<li>可以是相对路径或绝对路径</li>
<li>指定要导入的模块所在位置</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>从指定路径导入模块配置</li>
<li>将模块集成到当前系统</li>
<li>自动处理模块依赖关系</li>
<li>支持强制导入模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 从指定路径导入模块
gops import --path /path/to/module

# 跳过确认导入
gops import --path /path/to/module --force 1

# 详细调试导入过程
gops import --path /path/to/module --debug 3 --log import=debug

# 强制更新所有内容
gops import --path /path/to/module --force 3
</code></pre>
<h3 id="gops-update"><a class="header" href="#gops-update">gops update</a></h3>
<p>更新系统模块和引用</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：不强制更新</li>
<li>1：强制更新引用</li>
<li>2：强制更新依赖</li>
<li>3：强制更新所有内容</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新系统模块的引用关系</li>
<li>更新模块的依赖配置</li>
<li>下载远程资源引用</li>
<li>支持多种强制更新模式</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新系统
gops update

# 强制更新引用
gops update --force 1

# 详细调试更新过程
gops update --debug 3 --log all=debug
</code></pre>
<h3 id="gops-localize"><a class="header" href="#gops-localize">gops localize</a></h3>
<p>本地化模块配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 本地化值文件路径
<ul>
<li>指定用于本地化的值文件路径</li>
<li>通常是 YAML 格式的配置文件</li>
</ul>
</li>
<li><code>--default</code> - 使用默认模块配置
<ul>
<li>启用默认模块模式</li>
<li>不使用用户自定义的 value.yml 文件</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>根据环境特定的值本地化模块配置</li>
<li>适配不同环境的配置需求</li>
<li>支持多环境配置管理</li>
<li>可选择使用自定义或默认值</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认配置本地化
gops localize --default

# 使用自定义值文件本地化
gops localize --value prod-values.yml

# 使用自定义值文件并启用调试
gops localize --value dev-values.yml --debug 2
</code></pre>
<blockquote>
<p><strong>注意：</strong> 目前 <code>gops localize</code> 命令实现为 <code>todo!()</code>，功能尚未完成。</p>
</blockquote>
<h3 id="gops-setting"><a class="header" href="#gops-setting">gops setting</a></h3>
<p>系统设置管理</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gops setting [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置
<ul>
<li>格式：模块=级别,模块=级别</li>
<li>例如：--log setting=debug,system=info</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>管理系统级别的配置设置</li>
<li>查看和修改系统配置参数</li>
<li>提供系统状态信息</li>
<li>支持调试和日志配置</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 查看系统设置
gops setting

# 启用调试输出查看设置
gops setting --debug 2

# 配置日志级别查看设置
gops setting --log setting=debug,system=info
</code></pre>
<h2 id="环境变量-2"><a class="header" href="#环境变量-2">环境变量</a></h2>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置</li>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态</li>
<li><code>TEST_MODE</code> 和 <code>MOCK_SUCCESS</code> 用于测试环境，确保测试的安全性和隔离性</li>
</ul>
<h2 id="配置文件-2"><a class="header" href="#配置文件-2">配置文件</a></h2>
<h3 id="系统配置结构"><a class="header" href="#系统配置结构">系统配置结构</a></h3>
<pre><code>my-config/
├── ops_config.yml              # 系统主配置文件
├── templates/                  # 模板目录
├── examples/                  # 示例文件
├── scripts/                   # 脚本文件
├── modules/                   # 模块目录
├── config/                    # 配置文件
│   ├── default.yml           # 默认配置
│   ├── local.yml             # 本地配置
│   └── env/                  # 环境特定配置
│       ├── dev.yml
│       ├── staging.yml
│       └── prod.yml
└── settings/                  # 系统设置
    ├── system.yml
    ├── security.yml
    └── performance.yml
</code></pre>
<h3 id="ops_configyml-示例"><a class="header" href="#ops_configyml-示例">ops_config.yml 示例</a></h3>
<pre><code class="language-yaml"># 系统配置文件
system_name: my-ops-system
version: "1.0.0"
description: "My Galaxy Operations System"

# 模块配置
modules:
  - name: core
    type: system
    version: "1.0.0"
  - name: database
    type: external
    path: "/path/to/database-module"
    version: "2.1.0"

# 依赖配置
dependencies:
  - galaxy/core: "&gt;=1.0.0"
  - galaxy/utils: "~2.0.0"
  - galaxy/security: "^1.5.0"

# 导入配置
imports:
  - name: user-service
    path: "/path/to/user-service"
    version: "1.2.0"

# 输出配置
outputs:
  - name: artifacts
    path: "build/artifacts"
    format: tar.gz

# 系统设置
settings:
  debug_level: 1
  log_level: info
  auto_update: true
</code></pre>
<h2 id="最佳实践-1"><a class="header" href="#最佳实践-1">最佳实践</a></h2>
<h3 id="配置命名"><a class="header" href="#配置命名">配置命名</a></h3>
<ul>
<li>使用小写字母、数字、连字符和下划线</li>
<li>避免特殊字符和空格</li>
<li>使用有意义的名称，如：<code>production-config</code></li>
<li>区分环境和用途：<code>dev-api-config</code></li>
</ul>
<h3 id="模块管理"><a class="header" href="#模块管理">模块管理</a></h3>
<pre><code class="language-bash"># 导入新模块
gops import --path /path/to/new-module --force 1

# 更新现有模块
gops update --force 2

# 验证配置
gops setting --debug 2
</code></pre>
<h3 id="配置管理-1"><a class="header" href="#配置管理-1">配置管理</a></h3>
<pre><code class="language-bash"># 开发环境配置
gops localize --value dev-config.yml --debug 2

# 测试环境配置
gops localize --value test-config.yml

# 生产环境配置
gops localize --value prod-config.yml --default
</code></pre>
<h3 id="调试技巧-1"><a class="header" href="#调试技巧-1">调试技巧</a></h3>
<pre><code class="language-bash"># 启用完整调试输出
gops import --path /test --debug 4 --log all=debug

# 检查系统设置
gops setting --debug 3 --log setting=debug

# 使用详细日志进行故障排除
gops update --debug 2 --log cmd=debug,net=trace
</code></pre>
<h2 id="故障排除-1"><a class="header" href="#故障排除-1">故障排除</a></h2>
<h3 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h3>
<p><strong>Q: 创建配置失败</strong></p>
<pre><code>错误：无法创建目录 "my-config"
原因：目录已存在或权限不足
解决：删除现有目录或检查权限
</code></pre>
<p><strong>Q: 导入模块失败</strong></p>
<pre><code>错误：无法导入模块
原因：路径不存在或权限不足
解决：检查路径是否正确，确保有读取权限
gops import --path /test/path --debug 3 --log import=debug
</code></pre>
<p><strong>Q: 更新模块时网络错误</strong></p>
<pre><code>错误：无法下载依赖
解决：检查网络连接和 git 配置
gops update --debug 3 --log net=debug
</code></pre>
<p><strong>Q: 本地化功能未实现</strong></p>
<pre><code>错误：localize 功能尚未完成
原因：当前版本实现为 todo!()
解决：等待后续版本支持，或使用其他配置管理方式
</code></pre>
<h3 id="调试模式-2"><a class="header" href="#调试模式-2">调试模式</a></h3>
<p>使用调试模式获取详细的执行信息：</p>
<pre><code class="language-bash"># 最高级别调试
gops import --path /test --debug 4 --log all=debug

# 关键模块调试
gops new --name test --debug 3 --log cmd=debug

# 设置调试
gops setting --debug 2 --log setting=debug
</code></pre>
<h3 id="系统诊断"><a class="header" href="#系统诊断">系统诊断</a></h3>
<pre><code class="language-bash"># 检查配置文件
ls -la my-config/

# 验证系统配置
cat my-config/ops_config.yml

# 检查模块目录
ls -la my-config/modules/

# 查看系统设置
gops setting --debug 1
</code></pre>
<h2 id="测试-1"><a class="header" href="#测试-1">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxops_run_success

# 运行测试并显示输出
cargo test -- --nocapture

# 测试环境隔离
TEST_MODE=true cargo test
</code></pre>
<h2 id="示例工作流-1"><a class="header" href="#示例工作流-1">示例工作流</a></h2>
<h3 id="开发新系统"><a class="header" href="#开发新系统">开发新系统</a></h3>
<pre><code class="language-bash"># 1. 创建新系统配置
gops new --name my-ops-system

# 2. 导入外部模块
gops import --path /path/to/user-service --force 1

# 3. 导入数据库模块
gops import --path /path/to/database-module --force 2

# 4. 更新系统模块
gops update

# 5. 查看系统设置
gops setting --debug 1

# 6. 本地化配置（功能待实现）
gops localize --value dev-config.yml
</code></pre>
<h3 id="部署到生产环境-1"><a class="header" href="#部署到生产环境-1">部署到生产环境</a></h3>
<pre><code class="language-bash"># 1. 创建生产系统配置
gops new --name production-system

# 2. 导入生产模块
gops import --path /path/to/production-modules --force 3

# 3. 更新到最新版本
gops update --force 3

# 4. 查看生产设置
gops setting --log production=debug

# 5. 使用生产配置本地化
gops localize --value prod-config.yml --default
</code></pre>
<h2 id="版本历史-1"><a class="header" href="#版本历史-1">版本历史</a></h2>
<h3 id="当前版本100-1"><a class="header" href="#当前版本100-1">当前版本：1.0.0</a></h3>
<ul>
<li>初始版本</li>
<li>支持系统配置创建</li>
<li>支持模块导入功能</li>
<li>支持系统模块更新</li>
<li>支持系统设置管理</li>
<li>本地化功能标记为待实现（todo!()）</li>
<li>完整的错误处理和日志记录</li>
</ul>
<h2 id="功能开发状态"><a class="header" href="#功能开发状态">功能开发状态</a></h2>
<div class="table-wrapper"><table><thead><tr><th>功能</th><th>状态</th><th>说明</th></tr></thead><tbody>
<tr><td>new</td><td>✅ 完成</td><td>创建新的系统配置</td></tr>
<tr><td>import</td><td>✅ 完成</td><td>导入外部模块到当前系统</td></tr>
<tr><td>update</td><td>✅ 完成</td><td>更新系统模块和引用</td></tr>
<tr><td>localize</td><td>⏳ 待开发</td><td>本地化模块配置（当前为 todo!()）</td></tr>
<tr><td>setting</td><td>✅ 完成</td><td>系统设置管理</td></tr>
</tbody></table>
</div>
<h2 id="贡献指南-1"><a class="header" href="#贡献指南-1">贡献指南</a></h2>
<p>欢迎贡献代码和建议：</p>
<ol>
<li>Fork 项目</li>
<li>创建特性分支</li>
<li>提交更改</li>
<li>推送到分支</li>
<li>创建 Pull Request</li>
</ol>
<h2 id="许可证-1"><a class="header" href="#许可证-1">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gprj-命令使用文档"><a class="header" href="#gprj-命令使用文档">gprj 命令使用文档</a></h1>
<h2 id="概述-3"><a class="header" href="#概述-3">概述</a></h2>
<p><code>gprj</code> 是 Galaxy Flow 的项目管理工具，用于初始化和管理 Galaxy 项目环境。</p>
<h2 id="基本用法-3"><a class="header" href="#基本用法-3">基本用法</a></h2>
<pre><code class="language-bash">gprj &lt;COMMAND&gt; [OPTIONS]
</code></pre>
<h2 id="命令列表"><a class="header" href="#命令列表">命令列表</a></h2>
<h3 id="1-init---初始化命令"><a class="header" href="#1-init---初始化命令">1. init - 初始化命令</a></h3>
<p>用于初始化 Galaxy 环境和项目。</p>
<h4 id="init-env---初始化-galaxy-环境"><a class="header" href="#init-env---初始化-galaxy-环境">init env - 初始化 Galaxy 环境</a></h4>
<pre><code class="language-bash">gprj init env
</code></pre>
<p>初始化系统级的 Galaxy 运行环境。</p>
<h4 id="init-prj-with-local---使用本地模块初始化项目"><a class="header" href="#init-prj-with-local---使用本地模块初始化项目">init prj-with-local - 使用本地模块初始化项目</a></h4>
<pre><code class="language-bash">gprj init prj-with-local
</code></pre>
<p>创建新项目并使用本地模块作为依赖。</p>
<h4 id="init-prj---使用远程模板初始化项目"><a class="header" href="#init-prj---使用远程模板初始化项目">init prj - 使用远程模板初始化项目</a></h4>
<pre><code class="language-bash">gprj init prj [OPTIONS]
</code></pre>
<h5 id="参数"><a class="header" href="#参数">参数</a></h5>
<ul>
<li><code>--tpl &lt;TPL&gt;</code>: 选择模板名称（默认：simple）
<ul>
<li>可选值：simple, open_pages, rust_prj 等</li>
</ul>
</li>
<li><code>--branch &lt;BRANCH&gt;</code>: 指定模板仓库分支</li>
<li><code>--tag &lt;TAG&gt;</code>: 指定模板仓库标签
<ul>
<li>可选值：alpha, develop, beta, release/1.0</li>
</ul>
</li>
<li><code>--repo &lt;REPO&gt;</code>: 模板仓库地址（默认：https://gal-tpl.git）</li>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别（默认：0）</li>
<li><code>--log &lt;LOG&gt;</code>: 日志配置</li>
<li><code>-p, --cmd-print</code>: 打印执行的命令</li>
</ul>
<h5 id="示例"><a class="header" href="#示例">示例</a></h5>
<pre><code class="language-bash"># 使用默认模板初始化
gprj init prj

# 使用特定模板
gprj init prj --tpl rust_prj

# 使用特定分支
gprj init prj --branch develop

# 使用特定标签
gprj init prj --tag release/1.0
</code></pre>
<h3 id="2-update---更新命令"><a class="header" href="#2-update---更新命令">2. update - 更新命令</a></h3>
<p>用于更新项目模块。</p>
<h4 id="update-mod---更新模块"><a class="header" href="#update-mod---更新模块">update mod - 更新模块</a></h4>
<pre><code class="language-bash">gprj update mod [OPTIONS]
</code></pre>
<h5 id="参数-1"><a class="header" href="#参数-1">参数</a></h5>
<ul>
<li><code>-d, --debug &lt;DEBUG&gt;</code>: 调试级别（默认：0）</li>
<li><code>-f, --conf-work &lt;CONF_WORK&gt;</code>: 工作配置文件（默认：./_gal/work.gxl）</li>
<li><code>--conf-adm &lt;CONF_ADM&gt;</code>: 管理配置文件（默认：./_gal/adm.gxl）</li>
<li><code>--log &lt;LOG&gt;</code>: 日志配置</li>
<li><code>-q, --quiet</code>: 静默模式（默认：true）</li>
</ul>
<h5 id="示例-1"><a class="header" href="#示例-1">示例</a></h5>
<pre><code class="language-bash"># 更新模块
gprj update mod

# 使用自定义配置更新
gprj update mod -f ./config/work.gxl
</code></pre>
<h3 id="3-conf---配置管理"><a class="header" href="#3-conf---配置管理">3. conf - 配置管理</a></h3>
<p>用于管理配置文件。</p>
<h4 id="conf-init---初始化配置"><a class="header" href="#conf-init---初始化配置">conf init - 初始化配置</a></h4>
<pre><code class="language-bash">gprj conf init [OPTIONS]
</code></pre>
<h5 id="参数-2"><a class="header" href="#参数-2">参数</a></h5>
<ul>
<li><code>-r, --remote</code>: 使用远程配置（默认：false）</li>
</ul>
<h5 id="示例-2"><a class="header" href="#示例-2">示例</a></h5>
<pre><code class="language-bash"># 初始化本地配置
gprj conf init

# 初始化远程配置
gprj conf init --remote
</code></pre>
<h3 id="4-check---检查命令"><a class="header" href="#4-check---检查命令">4. check - 检查命令</a></h3>
<p>检查当前项目配置和环境。</p>
<pre><code class="language-bash">gprj check
</code></pre>
<h3 id="5-adm---管理命令"><a class="header" href="#5-adm---管理命令">5. adm - 管理命令</a></h3>
<p>执行管理任务，等同于 gflow 的管理模式。</p>
<pre><code class="language-bash">gprj adm [OPTIONS]
</code></pre>
<h2 id="配置文件-3"><a class="header" href="#配置文件-3">配置文件</a></h2>
<h3 id="默认配置文件"><a class="header" href="#默认配置文件">默认配置文件</a></h3>
<ul>
<li><code>./_gal/work.gxl</code> - 工作流配置</li>
<li><code>./_gal/adm.gxl</code> - 管理配置</li>
<li><code>./_gal/head.gxl</code> - 头部配置</li>
</ul>
<h3 id="配置内容"><a class="header" href="#配置内容">配置内容</a></h3>
<ul>
<li>项目元数据</li>
<li>模块依赖</li>
<li>环境变量</li>
<li>执行策略</li>
</ul>
<h2 id="使用流程"><a class="header" href="#使用流程">使用流程</a></h2>
<h3 id="1-初始化新项目"><a class="header" href="#1-初始化新项目">1. 初始化新项目</a></h3>
<pre><code class="language-bash"># 1. 初始化环境
gprj init env

# 2. 初始化项目
gprj init prj --tpl simple

# 3. 检查配置
gprj check
</code></pre>
<h3 id="2-更新项目"><a class="header" href="#2-更新项目">2. 更新项目</a></h3>
<pre><code class="language-bash"># 更新所有模块
gprj update mod

# 使用自定义配置更新
gprj update mod -f ./my-config.gxl
</code></pre>
<h3 id="3-配置管理"><a class="header" href="#3-配置管理">3. 配置管理</a></h3>
<pre><code class="language-bash"># 初始化配置
gprj conf init

# 使用远程配置
gprj conf init --remote
</code></pre>
<h2 id="模板仓库"><a class="header" href="#模板仓库">模板仓库</a></h2>
<h3 id="默认模板仓库"><a class="header" href="#默认模板仓库">默认模板仓库</a></h3>
<ul>
<li>地址：https://gal-tpl.git</li>
<li>包含模板：simple, open_pages, rust_prj 等</li>
</ul>
<h3 id="自定义模板仓库"><a class="header" href="#自定义模板仓库">自定义模板仓库</a></h3>
<pre><code class="language-bash">gprj init prj --repo https://my-tpl.git --tpl my-template
</code></pre>
<h2 id="环境变量-3"><a class="header" href="#环境变量-3">环境变量</a></h2>
<ul>
<li><code>GALAXY_FLOW_HOME</code>: Galaxy Flow 主目录</li>
<li><code>RUST_LOG</code>: Rust 日志级别</li>
</ul>
<h2 id="返回值-1"><a class="header" href="#返回值-1">返回值</a></h2>
<ul>
<li><code>0</code>: 执行成功</li>
<li><code>非0</code>: 执行失败，返回错误码</li>
</ul>
<h2 id="常见问题-3"><a class="header" href="#常见问题-3">常见问题</a></h2>
<h3 id="权限问题-1"><a class="header" href="#权限问题-1">权限问题</a></h3>
<p>确保有执行权限：</p>
<pre><code class="language-bash">chmod +x gprj
</code></pre>
<h3 id="网络连接"><a class="header" href="#网络连接">网络连接</a></h3>
<p>初始化项目时需要网络连接以下载模板。</p>
<h3 id="模板选择"><a class="header" href="#模板选择">模板选择</a></h3>
<p>使用 <code>gprj init prj --help</code> 查看所有可用模板。</p>
<h3 id="配置冲突"><a class="header" href="#配置冲突">配置冲突</a></h3>
<p>如果配置文件已存在，先备份再重新初始化：</p>
<pre><code class="language-bash">mv _gal/work.gxl _gal/work.gxl.backup
gprj conf init
</code></pre>
<h2 id="最佳实践-2"><a class="header" href="#最佳实践-2">最佳实践</a></h2>
<h3 id="项目初始化"><a class="header" href="#项目初始化">项目初始化</a></h3>
<ol>
<li>先初始化环境：<code>gprj init env</code></li>
<li>选择合适的模板：<code>gprj init prj --tpl &lt;template&gt;</code></li>
<li>检查配置：<code>gprj check</code></li>
<li>更新模块：<code>gprj update mod</code></li>
</ol>
<h3 id="团队协作"><a class="header" href="#团队协作">团队协作</a></h3>
<ul>
<li>使用统一的模板仓库</li>
<li>定期更新模块：<code>gprj update mod</code></li>
<li>使用版本控制管理配置文件</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gsys---galaxy-system-management-tool"><a class="header" href="#gsys---galaxy-system-management-tool">gsys - Galaxy System Management Tool</a></h1>
<h2 id="概述-4"><a class="header" href="#概述-4">概述</a></h2>
<p><code>gsys</code> 是 Galaxy 系统管理工具，用于创建、更新和本地化 Galaxy 系统配置。它提供了完整的系统生命周期管理功能，帮助开发者快速构建和维护 Galaxy 系统。</p>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<pre><code class="language-bash"># 从源代码安装
cargo install --path .

# 或者使用二进制分发
https://github.com/galaxy-sec/galaxy-ops/releases/latest/
</code></pre>
<h2 id="基本用法-4"><a class="header" href="#基本用法-4">基本用法</a></h2>
<h3 id="显示版本信息-2"><a class="header" href="#显示版本信息-2">显示版本信息</a></h3>
<pre><code class="language-bash">gsys
# 输出示例：gsys: 1.0.0
</code></pre>
<h3 id="显示帮助信息-2"><a class="header" href="#显示帮助信息-2">显示帮助信息</a></h3>
<pre><code class="language-bash">gsys --help
gsys &lt;command&gt; --help
</code></pre>
<h2 id="命令详解-2"><a class="header" href="#命令详解-2">命令详解</a></h2>
<h3 id="gsys-new"><a class="header" href="#gsys-new">gsys new</a></h3>
<p>创建新的系统操作符</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gsys new [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-n, --name &lt;NAME&gt;</code> - 系统名称（字母数字，可包含连字符和下划线）【必填】</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>创建指定名称的新系统</li>
<li>初始化系统目录结构</li>
<li>生成所有必需的配置文件</li>
<li>交互式选择系统型号配置</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 创建名为 "my-system" 的新系统
gsys new --name my-system

# 创建系统时交互式选择系统型号
# 系统会提示：请选择系统型号配置:
# 1. ModelSTD_1
# 2. ModelSTD_2
# ...
# 选择完成后会自动生成对应的配置文件
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>创建目录：my-system/
生成配置文件：my-system/sys/sys_model.yml
生成模板文件：my-system/templates/
生成示例文件：my-system/examples/
</code></pre>
<h3 id="gsys-update"><a class="header" href="#gsys-update">gsys update</a></h3>
<p>更新现有系统配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gsys update [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）
<ul>
<li>0：关闭调试输出</li>
<li>1：基础调试信息</li>
<li>2：详细调试信息</li>
<li>3：跟踪调试信息</li>
<li>4：完整调试信息</li>
</ul>
</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置（格式：模块=级别,模块=级别）</li>
<li><code>-f, --force &lt;LEVEL&gt;</code> - 强制更新级别
<ul>
<li>0：正常更新</li>
<li>1：跳过确认</li>
<li>2：覆盖文件</li>
<li>3：强制 git pull</li>
</ul>
</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>更新系统的配置和依赖关系</li>
<li>下载远程引用的系统资源</li>
<li>支持多种强制更新模式</li>
<li>自动处理系统版本冲突</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 正常更新系统
gsys update

# 跳过确认更新
gsys update --force 1

# 详细调试输出更新过程
gsys update --debug 3 --log all=debug

# 完整强制更新
gsys update --force 3 --debug 4
</code></pre>
<h3 id="gsys-localize"><a class="header" href="#gsys-localize">gsys localize</a></h3>
<p>本地化系统配置</p>
<p><strong>语法：</strong></p>
<pre><code class="language-bash">gsys localize [OPTIONS]
</code></pre>
<p><strong>选项：</strong></p>
<ul>
<li><code>-d, --debug &lt;LEVEL&gt;</code> - 调试级别（0-4）</li>
<li><code>--log &lt;LOG&gt;</code> - 日志配置</li>
<li><code>--value &lt;PATH&gt;</code> - 值文件路径（YAML/JSON）</li>
<li><code>--default</code> - 使用内置默认值，不使用用户提供的 value.yml</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li>根据环境特定的值生成本地化配置</li>
<li>支持多环境配置管理</li>
<li>可选择使用自定义或默认值</li>
<li>自动生成环境特定的配置文件</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-bash"># 使用默认值本地化
gsys localize --default

# 使用自定义值文件本地化
gsys localize --value prod-values.yml

# 使用自定义值文件并启用调试
gsys localize --value dev-values.yml --debug 2

# 使用详细日志进行本地化
gsys localize --value staging-values.yml --log cmd=debug,localize=info
</code></pre>
<h2 id="系统型号配置"><a class="header" href="#系统型号配置">系统型号配置</a></h2>
<h3 id="支持的系统型号"><a class="header" href="#支持的系统型号">支持的系统型号</a></h3>
<p><code>gsys</code> 支持多种系统型号配置，可通过以下方式查看：</p>
<pre><code class="language-bash"># 查看所有支持的系统型号
python3 -c "from galaxy_ops.module import ModelSTD; print('\n'.join(str(m) for m in ModelSTD.support()))"
</code></pre>
<h3 id="系统型号选择"><a class="header" href="#系统型号选择">系统型号选择</a></h3>
<p>在创建新系统时，<code>gsys</code> 会交互式提示选择系统型号：</p>
<pre><code>请选择系统型号配置:
1. ModelSTD_AWS
2. ModelSTD_Docker
3. ModelSTD_Kubernetes
4. ModelSTD_BareMetal
5. 从当前系统自动检测
请输入选项编号 [1-5]:
</code></pre>
<h3 id="当前系统检测"><a class="header" href="#当前系统检测">当前系统检测</a></h3>
<p>如果选择"从当前系统自动检测"，<code>gsys</code> 会自动检测当前运行环境并生成对应的配置：</p>
<pre><code class="language-bash"># 自动检测当前系统
ModelSTD::from_cur_sys()  # 内部调用的方法
</code></pre>
<h2 id="环境变量-4"><a class="header" href="#环境变量-4">环境变量</a></h2>
<ul>
<li><code>TEST_MODE</code> - 测试模式设置</li>
<li><code>MOCK_SUCCESS</code> - 模拟成功状态</li>
<li><code>TEST_MODE</code> 和 <code>MOCK_SUCCESS</code> 用于测试环境，确保测试的安全性和隔离性</li>
</ul>
<h2 id="配置文件-4"><a class="header" href="#配置文件-4">配置文件</a></h2>
<h3 id="系统配置结构-1"><a class="header" href="#系统配置结构-1">系统配置结构</a></h3>
<pre><code>my-system/
├── sys/                       # 系统配置目录
│   ├── sys_model.yml          # 系统型号配置
│   ├── dependencies.yml      # 依赖配置
│   └── config/               # 系统配置
│       ├── default.yml        # 默认配置
│       ├── local.yml          # 本地配置
│       └── env/               # 环境特定配置
│           ├── dev.yml
│           ├── staging.yml
│           └── prod.yml
├── templates/                 # 模板目录
├── examples/                 # 示例文件
├── scripts/                  # 脚本文件
└── deployment/               # 部署配置
    ├── docker/
    ├── kubernetes/
    └── terraform/
</code></pre>
<h3 id="sys_modelyml-示例"><a class="header" href="#sys_modelyml-示例">sys_model.yml 示例</a></h3>
<pre><code class="language-yaml"># AWS 系统型号配置
system_name: my-aws-system
model: ModelSTD_AWS
version: "1.0.0"

# 基础配置
base_config:
  region: us-east-1
  availability_zones:
    - us-east-1a
    - us-east-1b
    - us-east-1c

# 计算资源
compute:
  type: auto_scaling
  min_size: 2
  max_size: 10
  desired_capacity: 3
  instance_type: t3.large

# 存储配置
storage:
  type: ebs
  volume_size: 100
  volume_type: gp3
  encrypted: true

# 网络配置
network:
  vpc_cidr: "10.0.0.0/16"
  subnet_cidrs:
    - "10.0.1.0/24"
    - "10.0.2.0/24"
    - "10.0.3.0/24"

# 安全配置
security:
  enable_vpc: true
  enable_security_groups: true
  enable_iam: true
</code></pre>
<h3 id="docker-系统型号配置"><a class="header" href="#docker-系统型号配置">Docker 系统型号配置</a></h3>
<pre><code class="language-yaml"># Docker 系统型号配置
system_name: my-docker-system
model: ModelSTD_Docker
version: "1.0.0"

# 容器配置
containers:
  - name: main
    image: "my-app:latest"
    ports:
      - "8080:80"
    environment:
      - NODE_ENV=production
    volumes:
      - "/opt/app/data:/app/data"

# 网络配置
networks:
  - name: app-network
    driver: bridge
    internal: false

# 数据卷配置
volumes:
  - name: app-data
    driver: local
</code></pre>
<h2 id="最佳实践-3"><a class="header" href="#最佳实践-3">最佳实践</a></h2>
<h3 id="系统命名"><a class="header" href="#系统命名">系统命名</a></h3>
<ul>
<li>使用小写字母、数字、连字符和下划线</li>
<li>避免特殊字符和空格</li>
<li>使用有意义的名称，如：<code>production-web-app</code></li>
<li>区分环境和用途：<code>dev-api-gateway</code></li>
</ul>
<h3 id="系统型号选择-1"><a class="header" href="#系统型号选择-1">系统型号选择</a></h3>
<pre><code class="language-bash"># AWS 环境
gsys new --name aws-ecommerce -- 选择 ModelSTD_AWS

# Docker 环境
gsys new --name docker-microservices -- 选择 ModelSTD_Docker

# Kubernetes 环境
gsys new --name k8s-monitoring -- 选择 ModelSTD_Kubernetes

# 裸金属服务器
gsys new --name bare-metal-database -- 选择 ModelSTD_BareMetal
</code></pre>
<h3 id="依赖管理-1"><a class="header" href="#依赖管理-1">依赖管理</a></h3>
<ul>
<li>定期更新系统依赖：<code>gsys update --force 1</code></li>
<li>在生产环境使用锁定版本</li>
<li>使用版本控制管理配置变更</li>
</ul>
<h3 id="配置管理-2"><a class="header" href="#配置管理-2">配置管理</a></h3>
<pre><code class="language-bash"># 开发环境配置
gsys localize --value dev-config.yml --log cmd=debug

# 测试环境配置
gsys localize --value test-config.yml

# 生产环境配置
gsys localize --value prod-config.yml --default
</code></pre>
<h2 id="故障排除-2"><a class="header" href="#故障排除-2">故障排除</a></h2>
<h3 id="常见问题-4"><a class="header" href="#常见问题-4">常见问题</a></h3>
<p><strong>Q: 创建系统失败</strong></p>
<pre><code>错误：无法创建目录 "my-system"
原因：目录已存在或权限不足
解决：删除现有目录或检查权限
</code></pre>
<p><strong>Q: 系统型号选择失败</strong></p>
<pre><code>错误：无法解析系统型号
解决：检查系统型号配置文件是否正确
gsys new --name test-system -- 选择 1
</code></pre>
<p><strong>Q: 更新系统时网络错误</strong></p>
<pre><code>错误：无法下载依赖
解决：检查网络连接和 git 配置
gsys update --debug 3 --log net=debug
</code></pre>
<p><strong>Q: 本地化失败</strong></p>
<pre><code>错误：无法解析值文件
解决：检查 YAML/JSON 格式是否正确
gsys localize --value config.yml --debug 2
</code></pre>
<h3 id="调试模式-3"><a class="header" href="#调试模式-3">调试模式</a></h3>
<p>使用调试模式获取详细的执行信息：</p>
<pre><code class="language-bash"># 最高级别调试
gsys update --debug 4 --log all=debug

# 关键模块调试
gsys new --name test --debug 3 --log cmd=debug

# 网络调试
gsys update --debug 3 --log net=debug
</code></pre>
<h3 id="系统诊断-1"><a class="header" href="#系统诊断-1">系统诊断</a></h3>
<pre><code class="language-bash"># 检查系统配置
ls -la my-system/sys/

# 验证系统型号配置
cat my-system/sys/sys_model.yml

# 检查环境配置
ls -la my-system/sys/config/env/
</code></pre>
<h2 id="测试-2"><a class="header" href="#测试-2">测试</a></h2>
<p>项目包含完整的测试套件：</p>
<pre><code class="language-bash"># 运行所有测试
cargo test

# 运行特定测试
cargo test test_gxsys_run_success

# 运行测试并显示输出
cargo test -- --nocapture

# 测试环境隔离
TEST_MODE=true cargo test
</code></pre>
<h2 id="示例工作流-2"><a class="header" href="#示例工作流-2">示例工作流</a></h2>
<h3 id="开发新系统-1"><a class="header" href="#开发新系统-1">开发新系统</a></h3>
<pre><code class="language-bash"># 1. 创建新系统
gsys new --name my-system

# 2. 选择系统型号（交互式）
# 输入编号选择对应的系统型号

# 3. 编辑系统配置
cd my-system
vim sys/sys_model.yml

# 4. 更新系统资源
cd ..
gsys update

# 5. 本地化配置
gsys localize --value dev-config.yml

# 6. 验证系统配置
ls -la my-system/sys/config/env/
</code></pre>
<h3 id="部署到生产环境-2"><a class="header" href="#部署到生产环境-2">部署到生产环境</a></h3>
<pre><code class="language-bash"># 1. 创建生产系统
gsys new --name production-system

# 2. 选择生产环境系统型号
# 根据实际情况选择 AWS/Docker/K8s 等

# 3. 更新到最新版本
gsys update --force 3

# 4. 使用生产配置本地化
gsys localize --value prod-config.yml --default

# 5. 验证生产配置
cat my-system/sys/config/env/prod.yml
</code></pre>
<h2 id="版本历史-2"><a class="header" href="#版本历史-2">版本历史</a></h2>
<h3 id="当前版本100-2"><a class="header" href="#当前版本100-2">当前版本：1.0.0</a></h3>
<ul>
<li>初始版本</li>
<li>支持系统创建、更新和本地化</li>
<li>交互式系统型号选择</li>
<li>多种系统型号支持（AWS、Docker、Kubernetes、BareMetal）</li>
<li>完整的错误处理和日志记录</li>
</ul>
<h2 id="贡献指南-2"><a class="header" href="#贡献指南-2">贡献指南</a></h2>
<p>欢迎贡献代码和建议：</p>
<ol>
<li>Fork 项目</li>
<li>创建特性分支</li>
<li>提交更改</li>
<li>推送到分支</li>
<li>创建 Pull Request</li>
</ol>
<h2 id="许可证-2"><a class="header" href="#许可证-2">许可证</a></h2>
<p>本项目采用 MIT 许可证 - 详见 LICENSE 文件</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buildin"><a class="header" href="#buildin">BUILDIN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="维护器"><a class="header" href="#维护器">维护器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sys-operator-开发指南"><a class="header" href="#sys-operator-开发指南">Sys-Operator 开发指南</a></h1>
<h2 id="概述-5"><a class="header" href="#概述-5">概述</a></h2>
<p>Sys-Operator 是 Galaxy Ops 框架中的系统级操作符，用于定义和管理完整的系统环境。它通过组合多个 Mod-Operator 来构建复杂的软件系统，提供系统级的生命周期管理、配置协调和部署自动化能力。</p>
<h3 id="核心特性"><a class="header" href="#核心特性">核心特性</a></h3>
<ul>
<li><strong>模块组合</strong>: 将多个独立的 Mod-Operator 组合成完整的系统</li>
<li><strong>统一管理</strong>: 提供系统级别的统一配置和管理接口</li>
<li><strong>多环境支持</strong>: 支持不同目标环境（开发、测试、生产）的系统定义</li>
<li><strong>工作流协调</strong>: 协调系统中各个模块的操作流程</li>
<li><strong>版本控制</strong>: 系统级别的版本管理和发布机制</li>
<li><strong>依赖解析</strong>: 自动解析和管理模块间的依赖关系</li>
</ul>
<h3 id="在-galaxy-ops-生态系统中的位置"><a class="header" href="#在-galaxy-ops-生态系统中的位置">在 Galaxy Ops 生态系统中的位置</a></h3>
<pre><code>Mod-Operator (单个组件) → Sys-Operator (完整系统) → Ops-Project (客户环境)
</code></pre>
<p>Sys-Operator 作为连接单个组件管理和客户环境部署的桥梁，通过 <code>gsys</code> 工具创建和管理，最终通过 <code>gflow</code> 执行系统级别的运维操作。</p>
<h2 id="文件结构"><a class="header" href="#文件结构">文件结构</a></h2>
<h3 id="完整的-sys-operator-目录结构"><a class="header" href="#完整的-sys-operator-目录结构">完整的 Sys-Operator 目录结构</a></h3>
<pre><code>system_name/
├── _gal/                              # 项目配置目录
│   ├── adm.gxl                       # 系统管理配置
│   ├── work.gxl                      # 工作流环境配置
│   └── project.toml                  # 项目元数据配置
├── sys/                              # 系统定义目录
│   ├── sys_model.yml                 # 系统模型定义
│   ├── mod_list.yml                  # 模块列表定义
│   ├── vars.yml                      # 系统变量定义
│   ├── mods/                         # 模块本地化副本
│   │   ├── module1_name/
│   │   │   └── arm-mac14-host/       # 特定平台配置
│   │   │       ├── spec/             # 规范文件
│   │   │       ├── local/            # 本地化配置
│   │   │       ├── values/           # 值文件
│   │   │       ├── vars.yml          # 模块变量
│   │   │       ├── setting.yml       # 本地化设置
│   │   │       └── workflows/        # 模块工作流
│   │   └── module2_name/
│   │       └── x86-ubt22-k8s/        # 不同平台配置
│   │           └── [相同结构]
│   └── workflows/                    # 系统工作流定义
│       └── operators.gxl             # 系统操作符工作流
├── sys-prj.yml                       # 系统项目配置
├── version.txt                       # 系统版本信息
├── .gitignore                        # Git 忽略文件
└── test_res/                         # 测试资源目录
</code></pre>
<h3 id="目录说明"><a class="header" href="#目录说明">目录说明</a></h3>
<h4 id="_gal---项目配置目录"><a class="header" href="#_gal---项目配置目录"><code>_gal/</code> - 项目配置目录</a></h4>
<p>存储 Galaxy 项目的配置文件，包括版本管理、工作流定义和项目元数据。</p>
<h4 id="sys---系统定义目录"><a class="header" href="#sys---系统定义目录"><code>sys/</code> - 系统定义目录</a></h4>
<p>包含系统的核心定义文件和模块的本地化副本，是 Sys-Operator 的核心目录。</p>
<h4 id="mods---模块本地化副本"><a class="header" href="#mods---模块本地化副本"><code>mods/</code> - 模块本地化副本</a></h4>
<p>存储系统中包含的各个模块的本地化配置和文件，这些是从模块源地址复制或下载而来的。</p>
<h4 id="workflows---系统工作流目录"><a class="header" href="#workflows---系统工作流目录"><code>workflows/</code> - 系统工作流目录</a></h4>
<p>包含系统级别的操作流程定义，使用 GXL 语言编写。</p>
<h2 id="核心配置文件"><a class="header" href="#核心配置文件">核心配置文件</a></h2>
<h3 id="1-syssys_modelyml---系统模型定义"><a class="header" href="#1-syssys_modelyml---系统模型定义">1. <code>sys/sys_model.yml</code> - 系统模型定义</a></h3>
<p>定义系统的基本信息和目标环境。</p>
<pre><code class="language-yaml"># 基础系统定义
name: example_system                    # 系统名称
model: arm-mac14-host                  # 目标平台模型
vender: Galaxy-Ops                     # 厂商信息（可选）


**字段说明**：
- `name`: 系统名称，必须唯一
- `model`: 目标平台模型，格式为 `arch-os-spc`
- `vender`: 厂商或组织信息

### 2. `sys/mod_list.yml` - 模块列表定义

定义系统包含的模块列表及其配置信息。

```yaml
# 基础模块列表
- name: redis_mock                     # 模块名称
  addr:
    path: ./example/modules/redis_mock  # 模块地址（本地路径）
  model: arm-mac14-host                # 目标平台模型
  enable: true                         # 是否启用

- name: mysql_mock
  addr:
    path: ./example/modules/mysql_mock
  model: arm-mac14-host
  enable: true

# 高级模块列表（包含远程仓库和设置）
- name: nginx_stable
  addr:
    repo: https://github.com/galaxy-operators/nginx    # Git 仓库
    branch: main                                        # 分支
    tag: v1.25.3                                       # 标签（可选）
  model: x86-ubt22-host
  enable: true
  setting:
    src:  ${GXL_PRJ_ROOT}/sys/setting/
    dst:


                             # 默认禁用


</code></pre>
<p><strong>字段说明</strong>：</p>
<ul>
<li><code>name</code>: 模块名称，与 Mod-Operator 中的名称一致</li>
<li><code>addr</code>: 模块地址
<ul>
<li><code>path</code>: 本地路径（相对或绝对路径）</li>
<li><code>repo</code>: Git 仓库 URL</li>
<li><code>branch</code>: Git 分支名称</li>
<li><code>tag</code>: Git 标签</li>
<li><code>channel</code>: 仓库通道</li>
</ul>
</li>
<li><code>model</code>: 目标平台模型</li>
<li><code>enable</code>: 是否启用该模块</li>
<li><code>condition</code>: 启用条件（可选）</li>
<li><code>setting</code>: 模块特定设置（可选）</li>
<li><code>vars</code>: 模块变量覆盖（可选）</li>
</ul>
<h3 id="3-sysvarsyml---系统变量定义"><a class="header" href="#3-sysvarsyml---系统变量定义">3. <code>sys/vars.yml</code> - 系统变量定义</a></h3>
<p>定义系统级别的环境变量和配置参数。</p>
<pre><code class="language-yaml"># 基础变量定义
vars:
- name: SYSTEM_NAME                    # 变量名
  desp: "系统名称"                      # 描述（可选）
  value: example_system               # 默认值

- name: ENVIRONMENT
  desp: "部署环境"
  value: development

- name: DOMAIN_NAME
  desp: "系统域名"
  value: example.com

- name: ADMIN_EMAIL
  desp: "管理员邮箱"
  value: admin@example.com

# 带环境变量替换的变量定义
vars:
- name: DATA_CENTER
  desp: "数据中心位置"
  value: "${DATACENTER:us-west-1}"   # 默认值 us-west-1

- name: CLUSTER_NAME
  desp: "集群名称"
  value: "${CLUSTER_NAME:default-cluster}"

- name: NAMESPACE
  desp: "K8s 命名空间"
  value: "${NAMESPACE:galaxy-ops}"

# 类型化的变量定义
vars:
- name: REPLICAS
  type: integer                       # 数据类型
  min: 1                             # 最小值
  max: 10                            # 最大值
  value: 3                           # 默认值

- name: ENABLE_SSL
  type: boolean                      # 布尔类型
  value: true

- name: LOG_LEVEL
  type: enum                         # 枚举类型
  values: [debug, info, warn, error]  # 可选值
  value: info

- name: MEMORY_LIMIT
  type: string
  pattern: "^[0-9]+[MG]i?$"          # 正则模式
  value: "512Mi"

# 分组和分类的变量定义
vars:
# 网络配置
- name: INGRESS_PORT
  group: network
  desp: "入口端口"
  value: 80

- name: SECURE_PORT
  group: network
  desp: "安全端口"
  value: 443

# 数据库配置
- name: DB_HOST
  group: database
  desp: "数据库主机"
  value: postgresql

- name: DB_PORT
  group: database
  desp: "数据库端口"
  value: 5432

# 监控配置
- name: MONITORING_ENABLED
  group: monitoring
  desp: "是否启用监控"
  value: true
</code></pre>
<h3 id="4-_galadmgxl---系统管理配置"><a class="header" href="#4-_galadmgxl---系统管理配置">4. <code>_gal/adm.gxl</code> - 系统管理配置</a></h3>
<p>定义系统的版本管理和发布配置。</p>
<pre><code class="language-gxl">// 引入版本管理模块
extern mod ver,git,ver_adm {
    git = "https://github.com/galaxy-operators/cfm-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 环境定义
mod envs {
    env default {
        PKG_NAME = "your_system";        // 系统包名
        VERSION = "1.0.0";              // 系统版本
        MAINTAINER = "devops@example.com";
    }

    env production {
        PKG_NAME = "production-system";
        VERSION = "1.0.0";
        MAINTAINER = "prod-team@example.com";
    }
}

// 主模块继承版本管理功能
mod main : ver_adm {
    // 版本信息任务
    #[task(name="version")]
    flow version {
        gx.echo("System version: ${VERSION}");
        gx.echo("Package name: ${PKG_NAME}");
        gx.echo("Maintainer: ${MAINTAINER}");
    }

    // 发布任务（可选）
    #[task(name="publish")]
    flow publish {
        gx.echo("Publishing system to registry...");
        // 发布逻辑
    }
}
</code></pre>
<h3 id="5-_galworkgxl---工作流环境配置"><a class="header" href="#5-_galworkgxl---工作流环境配置">5. <code>_gal/work.gxl</code> - 工作流环境配置</a></h3>
<p>定义系统的工作流环境和执行配置。</p>
<pre><code class="language-gxl">// 引入操作符和版本管理模块
extern mod operators { path = "./sys/workflows"; }
extern mod ver,git {
    git = "https://github.com/galaxy-operators/cfm-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 环境定义
mod envs {
    // 默认环境
    env default : _common {
        FORCE_FLAG = "";                // 强制标志
        LOG_LEVEL = "";                 // 日志级别
        SYS_BIN = "gsys";              // 系统管理器
        MOD_BIN = "gmod";              // 模块管理器
        SYS = "sys";                    // 系统标识
        MODULE_ENV = "default";         // 模块环境

        // 读取系统模型定义
        gx.read_file(
            file : "sys/sys_model.yml",
            name : "DEFINE"
        );
    }

    // 强制执行环境
    env force {
        FORCE_FLAG = "-f 3";
        LOG_LEVEL = "--log debug";
    }

    // 生产环境
    env production {
        FORCE_FLAG = "-f 2";
        LOG_LEVEL = "--log info";
        MODULE_ENV = "production";
    }

    // 开发环境
    env development {
        FORCE_FLAG = "";
        LOG_LEVEL = "--log debug";
        MODULE_ENV = "development";
    }

    // 通用配置
    env _common {
        BUILD_PATH = "${GXL_PRJ_ROOT}/build";    // 构建路径
        DEPLOY_PATH = "${GXL_PRJ_ROOT}/deploy";   // 部署路径
    }
}

// 主模块继承操作符功能
mod main : operators {
    BUILD_PATH = "${GXL_PRJ_ROOT}/build";

    // 自动加载入口
    #[auto_load(entry)]
    flow ver.use | @_into_main {
        ENV_SYS_MODEL = ${DEFINE.MODEL};          // 设置系统模型
        ENV_PKG_NAME = ${DEFINE.NAME};             // 设置包名
    }

    // 主配置任务
    #[task(name="main conf")]
    flow conf {
        gx.echo("=== 开始系统配置 ===");

        // 更新系统配置
        gx.cmd ("${ENV_SYS_BIN} update ${ENV_LOG_LEVEL} ${ENV_FORCE_FLAG}");

        // 本地化系统配置
        gx.cmd ("${ENV_SYS_BIN} localize ${ENV_LOG_LEVEL}");

        gx.echo("=== 系统配置完成 ===");
    }

    // 系统验证任务
    #[task(name="validate")]
    flow validate {
        gx.echo("=== 开始系统验证 ===");

        // 验证系统模型
        gx.assert(gx.file_exists("sys/sys_model.yml"));

        // 验证模块列表
        gx.assert(gx.file_exists("sys/mod_list.yml"));

        // 验证所有启用的模块
        for ${MODULE} in ${DEFINE.MODULES} {
            if ${MODULE.ENABLE} {
                gx.echo("验证模块: ${MODULE.NAME}");
                // 模块验证逻辑
            }
        }

        gx.echo("=== 系统验证完成 ===");
    }

    // 系统信息任务
    #[task(name="info")]
    flow info {
        gx.echo("=== 系统信息 ===");
        gx.echo("系统名称: ${DEFINE.NAME}");
        gx.echo("目标模型: ${DEFINE.MODEL}");
        gx.echo("厂商: ${DEFINE.VENDER}");
        gx.echo("包含模块数量: ${DEFINE.MODULES_LEN}");
        gx.echo("=== 信息显示完成 ===");
    }
}
</code></pre>
<h3 id="6-sysworkflowsoperatorsgxl---系统操作符工作流"><a class="header" href="#6-sysworkflowsoperatorsgxl---系统操作符工作流">6. <code>sys/workflows/operators.gxl</code> - 系统操作符工作流</a></h3>
<p>定义系统级别的操作流程。</p>
<pre><code class="language-gxl">// 引入系统操作模块
extern mod sys_ops {
    git = "https://github.com/galaxy-operators/ops-gxl.git",
    channel = "${GXL_CHANNEL:main}"
}

// 系统操作符模块
mod operators : sys_ops {
    // 自动加载入口
    #[auto_load(entry)]
    flow __into {
        // 加载系统配置
        gx.read_file(
            file : "sys/sys_model.yml",
            name : "SYSTEM_DEFINE"
        );

        gx.read_file(
            file : "sys/mod_list.yml",
            name : "MODULE_LIST"
        );

        gx.read_file(
            file : "sys/vars.yml",
            name : "SYSTEM_VARS"
        );
    }

    // 系统初始化任务
    #[task(name="gsys@init")]
    flow init {
        gx.echo("=== 开始系统初始化 ===");
        gx.echo("系统名称: ${SYSTEM_DEFINE.NAME}");
        gx.echo("目标平台: ${SYSTEM_DEFINE.MODEL}");

        // 检查系统环境
        gx.echo("1. 检查系统环境...");
        gx.check_environment();

        // 初始化系统目录
        gx.echo("2. 初始化系统目录...");
        gx.cmd("mkdir -p sys/mods");
        gx.cmd("mkdir -p sys/workflows");

        // 初始化各个模块
        gx.echo("3. 初始化系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("初始化模块: ${MODULE.NAME}");
                gx.init_module(${MODULE});
            }
        }

        gx.echo("=== 系统初始化完成 ===");
    }

    // 系统更新任务
    #[task(name="gsys@update")]
    flow update {
        gx.echo("=== 开始系统更新 ===");

        // 更新系统定义
        gx.echo("1. 更新系统定义...");
        gx.update_system_definition();

        // 更新模块列表
        gx.echo("2. 更新模块列表...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("更新模块: ${MODULE.NAME}");
                gx.update_module(${MODULE});
            }
        }

        // 验证系统完整性
        gx.echo("3. 验证系统完整性...");
        gx.validate_system_integrity();

        gx.echo("=== 系统更新完成 ===");
    }

    // 系统本地化任务
    #[task(name="gsys@localize")]
    flow localize {
        gx.echo("=== 开始系统本地化 ===");

        // 本地化系统配置
        gx.echo("1. 本地化系统配置...");
        gx.localize_system_config();

        // 本地化各个模块
        gx.echo("2. 本地化系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("本地化模块: ${MODULE.NAME}");
                gx.localize_module(${MODULE});
            }
        }

        // 生成本地化报告
        gx.echo("3. 生成本地化报告...");
        gx.generate_localization_report();

        gx.echo("=== 系统本地化完成 ===");
    }

    // 系统安装任务
    #[task(name="gsys@install")]
    flow install {
        gx.echo("=== 开始系统安装 ===");

        // 预安装检查
        gx.echo("1. 执行预安装检查...");
        gx.pre_install_check();

        // 安装系统依赖
        gx.echo("2. 安装系统依赖...");
        gx.install_system_dependencies();

        // 安装各个模块
        gx.echo("3. 安装系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("安装模块: ${MODULE.NAME}");
                gx.install_module(${MODULE});
            }
        }

        // 系统配置
        gx.echo("4. 配置系统...");
        gx.configure_system();

        // 验证安装
        gx.echo("5. 验证安装结果...");
        gx.validate_installation();

        gx.echo("=== 系统安装完成 ===");
    }

    // 系统启动任务
    #[task(name="gsys@start")]
    flow start {
        gx.echo("=== 开始系统启动 ===");

        // 启动系统服务
        gx.echo("1. 启动系统服务...");
        gx.start_system_services();

        // 按依赖顺序启动模块
        gx.echo("2. 启动系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("启动模块: ${MODULE.NAME}");
                gx.start_module(${MODULE});
            }
        }

        // 健康检查
        gx.echo("3. 执行健康检查...");
        gx.health_check();

        gx.echo("=== 系统启动完成 ===");
    }

    // 系统停止任务
    #[task(name="gsys@stop")]
    flow stop {
        gx.echo("=== 开始系统停止 ===");

        // 按反向依赖顺序停止模块
        gx.echo("1. 停止系统模块...");
        for ${MODULE} in ${REVERSE_MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("停止模块: ${MODULE.NAME}");
                gx.stop_module(${MODULE});
            }
        }

        // 停止系统服务
        gx.echo("2. 停止系统服务...");
        gx.stop_system_services();

        gx.echo("=== 系统停止完成 ===");
    }

    // 系统状态检查任务
    #[task(name="gsys@status")]
    flow status {
        gx.echo("=== 系统状态检查 ===");

        // 检查系统服务状态
        gx.echo("1. 检查系统服务状态...");
        gx.check_system_services_status();

        // 检查模块状态
        gx.echo("2. 检查系统模块状态...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("检查模块: ${MODULE.NAME}");
                gx.check_module_status(${MODULE});
            }
        }

        // 生成状态报告
        gx.echo("3. 生成状态报告...");
        gx.generate_status_report();

        gx.echo("=== 系统状态检查完成 ===");
    }
}
</code></pre>
<h3 id="7-sys-prjyml---系统项目配置"><a class="header" href="#7-sys-prjyml---系统项目配置">7. <code>sys-prj.yml</code> - 系统项目配置</a></h3>
<p>定义系统项目的配置信息。</p>
<pre><code class="language-yaml"># 基础系统项目配置
test_envs:
  dep_root: ""                              # 依赖根目录
  deps: []                                  # 测试依赖列表

# 高级系统项目配置
name: "Production Web System"               # 系统项目名称
version: "1.0.0"                           # 项目版本
description: "Production web application system with monitoring"

# 测试环境配置
test_envs:
  dep_root: "./test_deps"                   # 依赖根目录
  deps:
    - addr:
        repo: https://github.com/galaxy-operators/bitnami-common.git
      local: ./test_res/bit-common          # 本地路径
      rename: bit-common                    # 重命名
      enable: true                          # 是否启用

    - addr:
        path: ./test_deps/test-data         # 本地路径依赖
      local: test-data
      enable: true

# 构建配置
build:
  # 构建目标
  targets:
    - arm-mac14-host
    - x86-ubt22-host
    - x86-ubt22-k8s

  # 构建选项
  options:
    parallel: true                          # 并行构建
    cache_enabled: true                     # 启用缓存
    cache_dir: "./build/cache"             # 缓存目录

  # 构建输出
  output:
    format: "tar.gz"                       # 输出格式
    destination: "./build/dist"            # 输出目录

# 发布配置
publish:
  repo: "https://github.com/galaxy-operators/systems"  # 发布仓库
  branch: "main"                           # 发布分支
  tag_format: "v${version}"                # 标签格式

  # 发布环境
  environments:
    staging:
      repo: "https://github.com/galaxy-operators/systems-staging"
      branch: "staging"
    production:
      repo: "https://github.com/galaxy-operators/systems-production"
      branch: "main"
      auto_tag: true                        # 自动打标签

# 质量检查
quality:
  # 代码检查
  lint:
    enabled: true
    rules:
      - no-hardcoded-secrets
      - consistent-naming
      - security-checks

  # 测试配置
  test:
    enabled: true
    types:
      - unit
      - integration
      - e2e
    coverage_threshold: 80                 # 覆盖率阈值

# 安全配置
security:
  # 敏感信息扫描
  secret_scanning:
    enabled: true
    patterns:
      - "API_KEY"
      - "PASSWORD"
      - "TOKEN"
      - "SECRET"

  # 许可证检查
  license_check:
    enabled: true
    allowed:
      - "MIT"
      - "Apache-2.0"
      - "BSD-3-Clause"
    forbidden:
      - "GPL-3.0"
      - "AGPL-3.0"

# 监控配置
monitoring:
  # 构建监控
  build:
    enabled: true
    metrics:
      - build_duration
      - build_success_rate
      - artifact_size

  # 运行时监控
  runtime:
    enabled: true
    endpoints:
      - health
      - metrics
      - logging
</code></pre>
<h2 id="开发工作流"><a class="header" href="#开发工作流">开发工作流</a></h2>
<h3 id="1-创建新系统"><a class="header" href="#1-创建新系统">1. 创建新系统</a></h3>
<p>使用 <code>gsys</code> 工具创建新的系统：</p>
<pre><code class="language-bash"># 创建基础系统
gsys new web_system

# 创建指定模型的系统
gsys new web_system --model x86-ubt22-k8s

# 从模板创建系统
gsys new web_system --template microservice

# 创建带厂商信息的系统
gsys new enterprise_system --vendor "Enterprise Corp" --model arm-mac14-host
</code></pre>
<h3 id="2-定义系统规范"><a class="header" href="#2-定义系统规范">2. 定义系统规范</a></h3>
<p>编辑系统核心配置文件：</p>
<pre><code class="language-bash"># 编辑系统模型定义
vim sys/sys_model.yml

# 编辑模块列表
vim sys/mod_list.yml

# 编辑系统变量
vim sys/vars.yml

# 编辑项目配置
vim sys-prj.yml
</code></pre>
<h3 id="3-添加模块到系统"><a class="header" href="#3-添加模块到系统">3. 添加模块到系统</a></h3>
<p>在 <code>mod_list.yml</code> 中添加新模块：</p>
<pre><code class="language-yaml"># 添加本地模块
- name: custom_module
  addr:
    path: ./local_modules/custom_module
  model: arm-mac14-host
  enable: true

# 添加远程模块
- name: redis_official
  addr:
    repo: https://github.com/galaxy-operators/redis
    tag: v7.2.4
  model: x86-ubt22-k8s
  enable: true
</code></pre>
<h3 id="4-配置系统工作流"><a class="header" href="#4-配置系统工作流">4. 配置系统工作流</a></h3>
<p>编辑系统工作流文件：</p>
<pre><code class="language-bash"># 编辑系统操作符工作流
vim sys/workflows/operators.gxl

# 编辑项目工作流配置
vim _gal/work.gxl

# 编辑系统管理配置
vim _gal/adm.gxl
</code></pre>
<h3 id="5-测试系统"><a class="header" href="#5-测试系统">5. 测试系统</a></h3>
<p>使用 <code>gflow</code> 测试系统功能：</p>
<pre><code class="language-bash"># 初始化系统
gflow run gsys@init --path ./system_name

# 验证系统配置
gflow run gsys@validate --path ./system_name

# 本地化系统
gflow run gsys@localize --path ./system_name

# 安装系统
gflow run gsys@install --path ./system_name

# 启动系统
gflow run gsys@start --path ./system_name
</code></pre>
<h3 id="6-验证系统状态"><a class="header" href="#6-验证系统状态">6. 验证系统状态</a></h3>
<p>检查系统运行状态：</p>
<pre><code class="language-bash"># 检查系统状态
gflow run gsys@status --path ./system_name

# 查看系统信息
gflow run info --path ./system_name
</code></pre>
<h3 id="7-发布系统"><a class="header" href="#7-发布系统">7. 发布系统</a></h3>
<p>将系统推送到系统仓库：</p>
<pre><code class="language-bash"># 发布到开发环境
gsys publish system_name --env development

# 发布到生产环境
gsys publish system_name --env production

# 自动打标签发布
gsys publish system_name --auto-tag
</code></pre>
<h2 id="最佳实践-4"><a class="header" href="#最佳实践-4">最佳实践</a></h2>
<h3 id="1-系统设计原则"><a class="header" href="#1-系统设计原则">1. 系统设计原则</a></h3>
<h4 id="模块化设计"><a class="header" href="#模块化设计">模块化设计</a></h4>
<p>将复杂系统分解为功能明确的模块，每个模块负责特定功能。</p>
<pre><code class="language-yaml"># 好的例子：功能明确的模块划分
- name: web_frontend          # 前端服务
  model: x86-ubt22-k8s
  enable: true

- name: api_gateway           # API 网关
  model: x86-ubt22-k8s
  enable: true

- name: user_service          # 用户服务
  model: x86-ubt22-k8s
  enable: true

- name: order_service         # 订单服务
  model: x86-ubt22-k8s
  enable: true

- name: database              # 数据库
  model: x86-ubt22-host
  enable: true

# 不好的例子：功能混乱的系统
- name: monolithic_app        # 单体应用
  model: x86-ubt22-host
  enable: true
</code></pre>
<h4 id="环境一致性"><a class="header" href="#环境一致性">环境一致性</a></h4>
<p>确保在不同环境（开发、测试、生产）中使用一致的系统定义。</p>
<pre><code class="language-yaml"># 使用条件变量实现环境差异
- name: monitoring_stack
  model: x86-ubt22-k8s
  enable: "${ENVIRONMENT:development}" == "production"
  vars:
    - name: RETENTION_DAYS
      value: "${RETENTION_DAYS:30}"
    - name: STORAGE_SIZE
      value: "${STORAGE_SIZE:100Gi}"
</code></pre>
<h4 id="依赖管理-2"><a class="header" href="#依赖管理-2">依赖管理</a></h4>
<p>明确管理模块间的依赖关系，避免循环依赖。</p>
<pre><code class="language-yaml"># 明确的启动顺序依赖
- name: database              # 基础服务
  model: x86-ubt22-host
  enable: true
  priority: 100               # 启动优先级

- name: cache_service         # 缓存服务
  model: x86-ubt22-k8s
  enable: true
  priority: 90
  depends_on: ["database"]

- name: user_service          # 业务服务
  model: x86-ubt22-k8s
  enable: true
  priority: 80
  depends_on: ["database", "cache_service"]

- name: web_frontend          # 前端服务
  model: x86-ubt22-k8s
  enable: true
  priority: 70
  depends_on: ["user_service", "api_gateway"]
</code></pre>
<h3 id="2-配置管理最佳实践"><a class="header" href="#2-配置管理最佳实践">2. 配置管理最佳实践</a></h3>
<h4 id="变量命名规范"><a class="header" href="#变量命名规范">变量命名规范</a></h4>
<p>使用清晰、一致的变量命名约定。</p>
<pre><code class="language-yaml"># 好的命名规范
vars:
# 系统级配置
- name: SYSTEM_NAME
  value: "production-web-system"

- name: ENVIRONMENT
  value: "production"

- name: VERSION
  value: "1.0.0"

# 网络配置
- name: INGRESS_PORT
  value: 80

- name: SECURE_PORT
  value: 443

- name: DOMAIN_NAME
  value: "example.com"

# 数据库配置
- name: DATABASE_HOST
  value: "postgres-primary"

- name: DATABASE_PORT
  value: 5432

- name: DATABASE_NAME
  value: "production_db"

# 监控配置
- name: MONITORING_ENABLED
  value: true

- name: ALERT_EMAIL
  value: "alerts@example.com"

# 不好的命名
- name: sys_name
  value: "prod-web"

- name: db_host
  value: "postgres"

- name: port
  value: 5432
</code></pre>
<h4 id="环境变量支持"><a class="header" href="#环境变量支持">环境变量支持</a></h4>
<p>支持通过环境变量覆盖配置。</p>
<pre><code class="language-yaml">vars:
# 支持环境变量覆盖的配置
- name: DATABASE_HOST
  value: "${DATABASE_HOST:localhost}"         # 默认值 localhost

- name: DATABASE_PORT
  value: "${DATABASE_PORT:5432}"              # 默认值 5432

- name: ENABLE_SSL
  value: "${ENABLE_SSL:false}"               # 默认值 false

- name: LOG_LEVEL
  value: "${LOG_LEVEL:info}"                 # 默认值 info

- name: MAX_CONNECTIONS
  value: "${MAX_CONNECTIONS:100}"             # 默认值 100

# 条件性配置
- name: DEBUG_MODE
  value: "${DEBUG_MODE:false}"

- name: PROFILE_API_ENABLED
  value: "${PROFILE_API_ENABLED:${DEBUG_MODE:false}}"
</code></pre>
<h4 id="配置验证"><a class="header" href="#配置验证">配置验证</a></h4>
<p>为关键配置添加验证规则。</p>
<pre><code class="language-yaml">vars:
# 带验证的配置
- name: INGRESS_PORT
  type: integer
  min: 1
  max: 65535
  value: 80

- name: DATABASE_PORT
  type: integer
  min: 1
  max: 65535
  value: 5432

- name: ENABLE_SSL
  type: boolean
  value: true

- name: LOG_LEVEL
  type: enum
  values: [debug, info, warn, error]
  value: info

- name: MEMORY_LIMIT
  type: string
  pattern: "^[0-9]+[MG]i?$"
  value: "512Mi"

- name: DOMAIN_NAME
  type: string
  pattern: "^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
  value: "example.com"
</code></pre>
<h3 id="3-工作流设计最佳实践"><a class="header" href="#3-工作流设计最佳实践">3. 工作流设计最佳实践</a></h3>
<h4 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h4>
<p>在工作流中包含完善的错误处理和回滚机制。</p>
<pre><code class="language-gxl">flow install {
    try {
        // 预安装检查
        gx.echo("执行预安装检查...");
        gx.pre_install_check();

        // 安装系统依赖
        gx.echo("安装系统依赖...");
        gx.install_system_dependencies();

        // 安装各个模块
        gx.echo("安装系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                try {
                    gx.echo("安装模块: ${MODULE.NAME}");
                    gx.install_module(${MODULE});
                } catch (error) {
                    gx.echo("模块 ${MODULE.NAME} 安装失败: ${error}");
                    gx.echo("开始回滚...");
                    gx.rollback_module(${MODULE});
                    throw error;
                }
            }
        }

        // 系统配置
        gx.echo("配置系统...");
        gx.configure_system();

        // 验证安装
        gx.echo("验证安装结果...");
        gx.validate_installation();

        gx.echo("系统安装完成");
    } catch (error) {
        gx.echo("系统安装失败: ${error}");
        gx.echo("执行系统回滚...");
        gx.rollback_system();
        throw error;
    }
}
</code></pre>
<h4 id="幂等性设计"><a class="header" href="#幂等性设计">幂等性设计</a></h4>
<p>确保工作流可以安全地重复执行。</p>
<pre><code class="language-gxl">flow start {
    gx.echo("开始系统启动...");

    // 检查系统状态
    let system_status = gx.get_system_status();
    if system_status == "running" {
        gx.echo("系统已在运行，跳过启动步骤");
        return;
    }

    // 启动系统服务
    if !gx.service_exists("system-core") {
        gx.echo("启动系统核心服务...");
        gx.start_service("system-core");
    }

    // 按依赖顺序启动模块
    for ${MODULE} in ${ORDERED_MODULE_LIST} {
        if ${MODULE.ENABLE} {
            let module_status = gx.get_module_status(${MODULE.NAME});
            if module_status != "running" {
                gx.echo("启动模块: ${MODULE.NAME}");
                gx.start_module(${MODULE.NAME});
            } else {
                gx.echo("模块 ${MODULE.NAME} 已在运行，跳过");
            }
        }
    }

    // 最终健康检查
    gx.echo("执行系统健康检查...");
    gx.health_check();

    gx.echo("系统启动完成");
}
</code></pre>
<h4 id="进度反馈"><a class="header" href="#进度反馈">进度反馈</a></h4>
<p>提供清晰的执行进度和状态反馈。</p>
<pre><code class="language-gxl">flow install {
    gx.echo("=== 开始系统安装 ===");
    gx.echo("系统名称: ${SYSTEM_DEFINE.NAME}");
    gx.echo("目标平台: ${SYSTEM_DEFINE.MODEL}");
    gx.echo("包含模块数量: ${MODULE_COUNT}");

    // 阶段1: 环境检查
    gx.echo("阶段 1/5: 环境检查...");
    gx.echo("  - 检查系统兼容性...");
    gx.check_system_compatibility();
    gx.echo("  ✓ 系统兼容性检查通过");

    gx.echo("  - 检查磁盘空间...");
    gx.check_disk_space();
    gx.echo("  ✓ 磁盘空间检查通过");

    gx.echo("  - 检查网络连接...");
    gx.check_network_connectivity();
    gx.echo("  ✓ 网络连接检查通过");

    // 阶段2: 依赖安装
    gx.echo("阶段 2/5: 依赖安装...");
    gx.echo("  - 安装系统依赖包...");
    gx.install_system_packages();
    gx.echo("  ✓ 系统依赖包安装完成");

    gx.echo("  - 配置系统环境...");
    gx.configure_system_environment();
    gx.echo("  ✓ 系统环境配置完成");

    // 阶段3: 模块安装
    gx.echo("阶段 3/5: 模块安装...");
    let installed_count = 0;
    for ${MODULE} in ${MODULE_LIST} {
        if ${MODULE.ENABLE} {
            gx.echo("  - 安装模块 ${MODULE.NAME}...");
            gx.install_module(${MODULE});
            installed_count++;
            gx.echo("  ✓ 模块 ${MODULE.NAME} 安装完成 (${installed_count}/${MODULE_COUNT})");
        }
    }

    // 阶段4: 系统配置
    gx.echo("阶段 4/5: 系统配置...");
    gx.echo("  - 生成系统配置文件...");
    gx.generate_system_configs();
    gx.echo("  ✓ 系统配置文件生成完成");

    gx.echo("  - 应用安全策略...");
    gx.apply_security_policies();
    gx.echo("  ✓ 安全策略应用完成");

    // 阶段5: 验证测试
    gx.echo("阶段 5/5: 验证测试...");
    gx.echo("  - 执行安装验证...");
    gx.validate_installation();
    gx.echo("  ✓ 安装验证通过");

    gx.echo("  - 执行健康检查...");
    gx.health_check();
    gx.echo("  ✓ 健康检查通过");

    gx.echo("=== 系统安装完成 ===");
    gx.echo("总计安装模块: ${installed_count}");
    gx.echo("安装用时: ${DURATION}");
}
</code></pre>
<h3 id="4-安全最佳实践"><a class="header" href="#4-安全最佳实践">4. 安全最佳实践</a></h3>
<h4 id="最小权限原则"><a class="header" href="#最小权限原则">最小权限原则</a></h4>
<p>为系统和服务配置最小必要权限。</p>
<pre><code class="language-yaml"># 安全配置示例
vars:
# 运行时用户
- name: RUNTIME_USER
  value: "galaxyops"

- name: RUNTIME_GROUP
  value: "galaxyops"

# 文件权限
- name: CONFIG_FILE_PERMISSIONS
  value: "640"

- name: EXECUTABLE_PERMISSIONS
  value: "750"

- name: DATA_DIR_PERMISSIONS
  value: "750"

# 网络安全
- name: BIND_ADDRESS
  value: "127.0.0.1"          # 默认绑定本地地址

- name: ALLOWED_HOSTS
  value: "localhost,127.0.0.1"

# 认证配置
- name: ENABLE_AUTHENTICATION
  value: true

- name: AUTH_METHOD
  value: "token"

- name: TOKEN_EXPIRY_HOURS
  value: 24

# TLS 配置
- name: ENABLE_TLS
  value: true

- name: TLS_CERT_FILE
  value: "/etc/ssl/certs/system.crt"

- name: TLS_KEY_FILE
  value: "/etc/ssl/private/system.key"
</code></pre>
<h4 id="敏感信息保护"><a class="header" href="#敏感信息保护">敏感信息保护</a></h4>
<p>避免在配置文件中硬编码敏感信息。</p>
<pre><code class="language-gxl"># 从安全存储读取敏感信息
flow configure_security {
    gx.echo("配置安全设置...");

    // 从环境变量读取数据库密码
    let db_password = gx.get_env("DATABASE_PASSWORD");
    if !db_password {
        throw "DATABASE_PASSWORD environment variable is required";
    }

    // 从密钥管理服务读取 API 密钥
    let api_key = gx.get_secret("system/api_key");
    if !api_key {
        throw "Failed to retrieve API key from secret store";
    }

    // 生成配置文件，不包含敏感信息
    gx.echo("生成安全配置文件...");
    gx.generate_config_with_secrets({
        "database": {
            "host": "${DATABASE_HOST}",
            "port": ${DATABASE_PORT},
            "username": "${DATABASE_USER}",
            "password": db_password        // 从安全存储获取
        },
        "api": {
            "endpoint": "${API_ENDPOINT}",
            "key": api_key                 // 从密钥管理服务获取
        }
    });

    gx.echo("安全配置完成");
}
</code></pre>
<h4 id="审计日志"><a class="header" href="#审计日志">审计日志</a></h4>
<p>记录系统关键操作的审计日志。</p>
<pre><code class="language-gxl">flow install {
    gx.echo("开始系统安装...");

    // 记录安装开始事件
    gx.log_audit({
        "event": "system_install_start",
        "timestamp": gx.now(),
        "user": gx.current_user(),
        "system_name": "${SYSTEM_DEFINE.NAME}",
        "target_model": "${SYSTEM_DEFINE.MODEL}"
    });

    try {
        // 执行安装步骤...
        gx.install_system_dependencies();
        gx.install_modules();
        gx.configure_system();

        // 记录安装成功事件
        gx.log_audit({
            "event": "system_install_success",
            "timestamp": gx.now(),
            "user": gx.current_user(),
            "system_name": "${SYSTEM_DEFINE.NAME}",
            "duration": gx.duration(),
            "installed_modules": ${INSTALLED_MODULES}
        });

        gx.echo("系统安装完成");
    } catch (error) {
        // 记录安装失败事件
        gx.log_audit({
            "event": "system_install_failure",
            "timestamp": gx.now(),
            "user": gx.current_user(),
            "system_name": "${SYSTEM_DEFINE.NAME}",
            "duration": gx.duration(),
            "error": error,
            "failed_step": "${CURRENT_STEP}"
        });

        gx.echo("系统安装失败: ${error}");
        throw error;
    }
}
</code></pre>
<h2 id="调试和故障排除"><a class="header" href="#调试和故障排除">调试和故障排除</a></h2>
<h3 id="1-常见问题"><a class="header" href="#1-常见问题">1. 常见问题</a></h3>
<h4 id="系统初始化失败"><a class="header" href="#系统初始化失败">系统初始化失败</a></h4>
<pre><code class="language-bash"># 检查系统文件结构
ls -la system_name/sys/
ls -la system_name/_gal/

# 验证系统模型配置
gsys validate system_name --verbose

# 检查模型定义格式
cat system_name/sys/sys_model.yml | yq .

# 验证模块列表语法
cat system_name/sys/mod_list.yml | yq .
</code></pre>
<h4 id="模块依赖冲突"><a class="header" href="#模块依赖冲突">模块依赖冲突</a></h4>
<pre><code class="language-bash"># 查看模块依赖关系
gsys deps system_name --graph

# 检查循环依赖
gsys deps system_name --check-cycles

# 验证模块兼容性
gsys validate system_name --check-module-compatibility

# 查看模块详细信息
gsys info system_name --modules
</code></pre>
<h4 id="本地化失败"><a class="header" href="#本地化失败">本地化失败</a></h4>
<pre><code class="language-bash"># 检查模块源地址
gsys localize system_name --check-sources

# 验证本地化设置
gsys localize system_name --validate-config

# 手动测试模块本地化
gsys localize system_name --dry-run

# 查看本地化详细日志
gsys localize system_name --log-level debug
</code></pre>
<h3 id="2-调试技巧"><a class="header" href="#2-调试技巧">2. 调试技巧</a></h3>
<h4 id="使用断言验证系统状态"><a class="header" href="#使用断言验证系统状态">使用断言验证系统状态</a></h4>
<pre><code class="language-gxl">flow install {
    gx.echo("开始系统安装...");

    // 验证系统目录结构
    gx.assert(gx.path_exists("sys/sys_model.yml"), "系统模型文件不存在");
    gx.assert(gx.path_exists("sys/mod_list.yml"), "模块列表文件不存在");
    gx.assert(gx.path_exists("sys/vars.yml"), "系统变量文件不存在");

    // 验证模型定义
    let system_model = gx.read_yaml("sys/sys_model.yml");
    gx.assert(system_model.name != "", "系统名称不能为空");
    gx.assert(system_model.model != "", "目标模型不能为空");

    // 验证模块列表
    let module_list = gx.read_yaml("sys/mod_list.yml");
    gx.assert(module_list.length &gt; 0, "模块列表不能为空");

    // 验证每个模块配置
    for ${MODULE} in module_list {
        gx.assert(${MODULE.NAME} != "", "模块名称不能为空");
        gx.assert(${MODULE.ADDR} != null, "模块地址不能为空");
        gx.assert(${MODULE.MODEL} != "", "目标模型不能为空");
    }

    gx.echo("系统配置验证通过");
}
</code></pre>
<h4 id="分步调试工作流"><a class="header" href="#分步调试工作流">分步调试工作流</a></h4>
<pre><code class="language-gxl">flow debug_install {
    gx.echo("=== 调试模式安装 ===");

    // 步骤1：验证输入
    flow step_1_validate_input {
        gx.echo("步骤1: 验证输入配置...");
        gx.validate_system_config();
        gx.validate_module_configs();
        gx.echo("✓ 输入配置验证通过");
    }

    // 步骤2：检查环境
    flow step_2_check_environment {
        gx.echo("步骤2: 检查系统环境...");
        gx.check_os_compatibility();
        gx.check_disk_space();
        gx.check_network_connectivity();
        gx.check_required_tools();
        gx.echo("✓ 系统环境检查通过");
    }

    // 步骤3：准备目录
    flow step_3_prepare_directories {
        gx.echo("步骤3: 准备系统目录...");
        gx.prepare_system_directories();
        gx.prepare_module_directories();
        gx.echo("✓ 目录准备完成");
    }

    // 步骤4：下载依赖
    flow step_4_download_dependencies {
        gx.echo("步骤4: 下载系统依赖...");
        gx.download_system_dependencies();
        gx.echo("✓ 系统依赖下载完成");
    }

    // 步骤5：安装模块
    flow step_5_install_modules {
        gx.echo("步骤5: 安装系统模块...");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.echo("  安装模块: ${MODULE.NAME}");
                gx.install_module(${MODULE});
            }
        }
        gx.echo("✓ 模块安装完成");
    }

    // 逐步执行
    step_1_validate_input();
    step_2_check_environment();
    step_3_prepare_directories();
    step_4_download_dependencies();
    step_5_install_modules();

    gx.echo("=== 调试安装完成 ===");
}
</code></pre>
<h4 id="详细日志记录"><a class="header" href="#详细日志记录">详细日志记录</a></h4>
<pre><code class="language-gxl">flow install_with_logging {
    gx.log_info("开始系统安装流程");
    gx.log_debug("系统配置: ${SYSTEM_CONFIG}");

    let start_time = gx.now();

    try {
        // 环境检查
        gx.log_info("执行环境检查阶段");
        gx.check_environment();
        gx.log_debug("环境检查完成");

        // 依赖安装
        gx.log_info("执行依赖安装阶段");
        let deps_start = gx.now();
        gx.install_dependencies();
        let deps_duration = gx.now() - deps_start;
        gx.log_info("依赖安装完成，耗时: ${deps_duration}ms");

        // 模块安装
        gx.log_info("执行模块安装阶段");
        for ${MODULE} in ${MODULE_LIST} {
            if ${MODULE.ENABLE} {
                gx.log_info("安装模块: ${MODULE.NAME}");
                let module_start = gx.now();
                gx.install_module(${MODULE});
                let module_duration = gx.now() - module_start;
                gx.log_info("模块 ${MODULE.NAME} 安装完成，耗时: ${module_duration}ms");
            }
        }

        // 配置应用
        gx.log_info("执行配置应用阶段");
        gx.apply_configurations();
        gx.log_debug("配置应用完成");

        // 验证测试
        gx.log_info("执行验证测试阶段");
        gx.validate_installation();
        gx.log_info("验证测试通过");

        let total_duration = gx.now() - start_time;
        gx.log_info("系统安装完成，总耗时: ${total_duration}ms");

    } catch (error) {
        let error_duration = gx.now() - start_time;
        gx.log_error("系统安装失败，耗时: ${error_duration}ms");
        gx.log_error("错误详情: ${error}");
        throw error;
    }
}
</code></pre>
<h3 id="3-性能调优"><a class="header" href="#3-性能调优">3. 性能调优</a></h3>
<h4 id="并行化模块操作"><a class="header" href="#并行化模块操作">并行化模块操作</a></h4>
<pre><code class="language-gxl">flow install_parallel {
    gx.echo("开始并行系统安装...");

    // 识别无依赖关系的模块组
    let module_groups = gx.identify_parallel_groups(${MODULE_LIST});

    gx.echo("识别出 ${module_groups.length} 个并行组");

    // 按组并行安装
    for ${GROUP} in module_groups {
        gx.echo("并行安装组 ${GROUP.INDEX}，包含 ${GROUP.MODULES.length} 个模块");

        // 并行执行模块安装
        let parallel_tasks = [];
        for ${MODULE} in ${GROUP.MODULES} {
            let task = async {
                gx.echo("  启动安装模块: ${MODULE.NAME}");
                let result = gx.install_module(${MODULE});
                gx.echo("  ✓ 模块 ${MODULE.NAME} 安装完成");
                return result;
            };
            parallel_tasks.push(task);
        }

        // 等待所有任务完成
        let results = gx.wait_all(parallel_tasks);

        // 检查是否有失败的安装
        for ${RESULT} in results {
            if ${RESULT.STATUS} == "failed" {
                gx.log_error("模块安装失败: ${RESULT.MODULE}");
                throw "Module installation failed";
            }
        }

        gx.echo("✓ 组 ${GROUP.INDEX} 安装完成");
    }

    gx.echo("并行系统安装完成");
}
</code></pre>
<h4 id="缓存优化"><a class="header" href="#缓存优化">缓存优化</a></h4>
<pre><code class="language-gxl">flow install_with_cache {
    gx.echo("开始带缓存的系统安装...");

    // 初始化缓存管理器
    let cache_manager = gx.cache_manager({
        "cache_dir": "./cache",
        "max_size": "10GB",
        "ttl": "7d"
    });

    // 检查缓存是否有效
    if cache_manager.is_valid("system_deps") {
        gx.echo("使用缓存的系统依赖");
        cache_manager.restore("system_deps");
    } else {
        gx.echo("下载系统依赖并缓存");
        gx.download_system_dependencies();
        cache_manager.store("system_deps", "./deps");
    }

    // 安装模块（利用模块级缓存）
    for ${MODULE} in ${MODULE_LIST} {
        if ${MODULE.ENABLE} {
            let cache_key = "module_${MODULE.NAME}_${MODULE.VERSION}";

            if cache_manager.is_valid(cache_key) {
                gx.echo("使用缓存的模块: ${MODULE.NAME}");
                cache_manager.restore(cache_key);
            } else {
                gx.echo("安装模块并缓存: ${MODULE.NAME}");
                gx.install_module(${MODULE});
                cache_manager.store(cache_key, ${MODULE.LOCAL_PATH});
            }
        }
    }

    // 清理过期缓存
    gx.echo("清理过期缓存...");
    cache_manager.cleanup();

    gx.echo("带缓存的系统安装完成");
}
</code></pre>
<h4 id="资源限制"><a class="header" href="#资源限制">资源限制</a></h4>
<pre><code class="language-gxl">flow install_with_resource_limits {
    gx.echo("开始资源限制安装...");

    // 设置资源限制
    let resource_limits = {
        "max_memory": "4GB",
        "max_cpu": "80%",
        "max_disk_io": "100MB/s",
        "max_network_io": "50MB/s"
    };

    gx.set_resource_limits(resource_limits);

    try {
        // 监控资源使用
        gx.start_resource_monitoring();

        // 分批安装模块以避免资源过载
        let batch_size = 2;  // 每批安装的模块数量

        for ${BATCH} in ${MODULE_LIST.batch(batch_size)} {
            gx.echo("安装批次 ${BATCH.INDEX}/${MODULE_LIST.batch_count(batch_size)}");

            for ${MODULE} in ${BATCH.MODULES} {
                if ${MODULE.ENABLE} {
                    gx.echo("  安装模块: ${MODULE.NAME}");
                    gx.install_module(${MODULE});

                    // 检查资源使用
                    let resource_usage = gx.get_resource_usage();
                    gx.log_debug("资源使用: ${resource_usage}");

                    // 如果资源使用过高，等待资源释放
                    if resource_usage.memory &gt; resource_limits.max_memory * 0.9 {
                        gx.echo("  内存使用过高，等待资源释放...");
                        gx.sleep(30);
                    }
                }
            }

            // 批次间等待
            gx.echo("批次完成，等待资源稳定...");
            gx.sleep(10);
        }

        gx.stop_resource_monitoring();
        gx.echo("资源限制安装完成");

    } catch (error) {
        gx.stop_resource_monitoring();
        gx.log_error("安装失败: ${error}");
        throw error;
    }
}
</code></pre>
<h2 id="示例系统"><a class="header" href="#示例系统">示例系统</a></h2>
<h3 id="1-微服务系统示例"><a class="header" href="#1-微服务系统示例">1. 微服务系统示例</a></h3>
<p>完整的微服务系统配置：</p>
<pre><code class="language-yaml"># sys/sys_model.yml
name: microservice_platform
model: x86-ubt22-k8s
vender: TechCorp
metadata:
  description: "Microservice platform with API gateway and services"
  version: "2.0.0"
  tags: [microservice, k8s, production]

# sys/mod_list.yml
- name: nginx_ingress
  addr:
    repo: https://github.com/galaxy-operators/nginx
    tag: v1.25.3
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: INGRESS_CONTROLLER
      value: "nginx"
    - name: SSL_TERMINATION
      value: true

- name: api_gateway
  addr:
    repo: https://github.com/galaxy-operators/api-gateway
    tag: v2.1.0
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: RATE_LIMIT
      value: 1000
    - name: AUTH_ENABLED
      value: true
    - name: CIRCUIT_BREAKER
      value: true

- name: user_service
  addr:
    repo: https://github.com/galaxy-operators/user-service
    tag: v3.0.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["postgres_database"]
  vars:
    - name: REPLICAS
      value: 3
    - name: DATABASE_HOST
      value: "postgres-service"
    - name: JWT_SECRET
      value: "${JWT_SECRET}"

- name: order_service
  addr:
    repo: https://github.com/galaxy-operators/order-service
    tag: v2.5.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["postgres_database", "redis_cache"]
  vars:
    - name: REPLICAS
      value: 2
    - name: DATABASE_HOST
      value: "postgres-service"
    - name: CACHE_HOST
      value: "redis-service"

- name: postgres_database
  addr:
    repo: https://github.com/galaxy-operators/postgresql
    tag: v16.2.0
  model: x86-ubt22-host
  enable: true
  vars:
    - name: POSTGRES_VERSION
      value: "16"
    - name: DATABASE_NAME
      value: "microservices"
    - name: MAX_CONNECTIONS
      value: 200

- name: redis_cache
  addr:
    repo: https://github.com/galaxy-operators/redis
    tag: v7.2.4
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: REDIS_VERSION
      value: "7.2"
    - name: MAX_MEMORY
      value: "512MB"

- name: monitoring_stack
  addr:
    repo: https://github.com/galaxy-operators/monitoring
    tag: v1.8.0
  model: x86-ubt22-k8s
  enable: "${ENABLE_MONITORING:true}"
  vars:
    - name: GRAFANA_ENABLED
      value: true
    - name: PROMETHEUS_ENABLED
      value: true
    - name: ALERTMANAGER_ENABLED
      value: true

# sys/vars.yml
vars:
# 系统配置
- name: ENVIRONMENT
  value: "${ENVIRONMENT:production}"

- name: DOMAIN_NAME
  value: "${DOMAIN_NAME:example.com}"

- name: NAMESPACE
  value: "${NAMESPACE:microservices}"

# 安全配置
- name: JWT_SECRET
  value: "${JWT_SECRET}"

- name: ENABLE_SSL
  value: "${ENABLE_SSL:true}"

- name: SSL_CERT_PATH
  value: "/etc/ssl/certs/tls.crt"

- name: SSL_KEY_PATH
  value: "/etc/ssl/private/tls.key"

# 性能配置
- name: DEFAULT_REPLICAS
  value: "${DEFAULT_REPLICAS:2}"

- name: MAX_REPLICAS
  value: "${MAX_REPLICAS:5}"

- name: CPU_REQUEST
  value: "${CPU_REQUEST:100m}"

- name: MEMORY_REQUEST
  value: "${MEMORY_REQUEST:256Mi}"

# 监控配置
- name: ENABLE_MONITORING
  value: "${ENABLE_MONITORING:true}"

- name: MONITORING_RETENTION
  value: "${MONITORING_RETENTION:30d}"

- name: ALERT_EMAIL
  value: "${ALERT_EMAIL:alerts@example.com}"
</code></pre>
<h3 id="2-数据处理平台示例"><a class="header" href="#2-数据处理平台示例">2. 数据处理平台示例</a></h3>
<p>大数据处理平台的系统配置：</p>
<pre><code class="language-yaml"># sys/sys_model.yml
name: data_processing_platform
model: x86-ubt22-host
vender: DataCorp
metadata:
  description: "Big data processing platform with Hadoop ecosystem"
  version: "1.5.0"
  tags: [bigdata, hadoop, batch-processing]

# sys/mod_list.yml
- name: hadoop_common
  addr:
    repo: https://github.com/galaxy-operators/hadoop
    tag: v3.3.6
  model: x86-ubt22-host
  enable: true
  vars:
    - name: HADOOP_VERSION
      value: "3.3.6"
    - name: JAVA_HOME
      value: "${JAVA_HOME:/usr/lib/jvm/java-11-openjdk}"

- name: hdfs_namenode
  addr:
    repo: https://github.com/galaxy-operators/hadoop-hdfs
    tag: v3.3.6
  model: x86-ubt22-host
  enable: true
  depends_on: ["hadoop_common"]
  vars:
    - name: NAMENODE_PORT
      value: 9820
    - name: REPLICATION_FACTOR
      value: 3

- name: hdfs_datanode
  addr:
    repo: https://github.com/galaxy-operators/hadoop-hdfs
    tag: v3.3.6
  model: x86-ubt22-host
  enable: true
  depends_on: ["hdfs_namenode"]
  vars:
    - name: DATANODE_PORT
      value: 9866
    - name: DATA_DIR
      value: "/data/hdfs/data"

- name: yarn_resourcemanager
  addr:
    repo: https://github.com/galaxy-operators/hadoop-yarn
    tag: v3.3.6
  model: x86-ubt22-host
  enable: true
  depends_on: ["hadoop_common"]
  vars:
    - name: RESOURCEMANAGER_PORT
      value: 8032
    - name: MAX_CONTAINER_MEMORY
      value: "8192"

- name: yarn_nodemanager
  addr:
    repo: https://github.com/galaxy-operators/hadoop-yarn
    tag: v3.3.6
  model: x86-ubt22-host
  enable: true
  depends_on: ["yarn_resourcemanager"]
  vars:
    - name: NODEMANAGER_PORT
      value: 8042
    - name: AVAILABLE_MEMORY_MB
      value: "16384"

- name: hive_metastore
  addr:
    repo: https://github.com/galaxy-operators/hive
    tag: v3.1.3
  model: x86-ubt22-host
  enable: true
  depends_on: ["hdfs_namenode", "postgres_database"]
  vars:
    - name: METASTORE_PORT
      value: 9083
    - name: DATABASE_HOST
      value: "postgres-service"

- name: spark_master
  addr:
    repo: https://github.com/galaxy-operators/spark
    tag: v3.4.1
  model: x86-ubt22-host
  enable: true
  depends_on: ["hadoop_common", "yarn_resourcemanager"]
  vars:
    - name: SPARK_VERSION
      value: "3.4.1"
    - name: MASTER_PORT
      value: 7077
    - name: MASTER_WEB_PORT
      value: 8080

- name: spark_worker
  addr:
    repo: https://github.com/galaxy-operators/spark
    tag: v3.4.1
  model: x86-ubt22-host
  enable: true
  depends_on: ["spark_master"]
  vars:
    - name: WORKER_PORT
      value: 8888
    - name: WORKER_CORES
      value: 4
    - name: WORKER_MEMORY
      value: "8g"

- name: postgres_database
  addr:
    repo: https://github.com/galaxy-operators/postgresql
    tag: v15.5.0
  model: x86-ubt22-host
  enable: true
  vars:
    - name: POSTGRES_VERSION
      value: "15"
    - name: DATABASE_NAME
      value: "metastore"
    - name: MAX_CONNECTIONS
      value: 100

# sys/vars.yml
vars:
# Hadoop 配置
- name: HADOOP_CONF_DIR
  value: "${HADOOP_CONF_DIR:/etc/hadoop/conf}"

- name: HADOOP_LOG_DIR
  value: "${HADOOP_LOG_DIR:/var/log/hadoop}"

- name: HADOOP_PID_DIR
  value: "${HADOOP_PID_DIR:/var/run/hadoop}"

- name: HADOOP_USER
  value: "${HADOOP_USER:hadoop}"

# YARN 配置
- name: YARN_CONF_DIR
  value: "${YARN_CONF_DIR:/etc/hadoop/conf}"

- name: YARN_LOG_DIR
  value: "${YARN_LOG_DIR:/var/log/yarn}"

- name: YARN_NODEMANAGER_RESOURCE_MEMORY_MB
  value: "${YARN_NODEMANAGER_RESOURCE_MEMORY_MB:16384}"

- name: YARN_NODEMANAGER_RESOURCE_CPU_VCORES
  value: "${YARN_NODEMANAGER_RESOURCE_CPU_VCORES:8}"

# Spark 配置
- name: SPARK_CONF_DIR
  value: "${SPARK_CONF_DIR:/etc/spark/conf}"

- name: SPARK_LOG_DIR
  value: "${SPARK_LOG_DIR:/var/log/spark}"

- name: SPARK_WORKER_CORES
  value: "${SPARK_WORKER_CORES:4}"

- name: SPARK_WORKER_MEMORY
  value: "${SPARK_WORKER_MEMORY:8g}"

- name: SPARK_MASTER_HOST
  value: "${SPARK_MASTER_HOST:spark-master}"

# 数据存储配置
- name: HDFS_DATA_DIR
  value: "${HDFS_DATA_DIR:/data/hdfs/data}"

- name: HDFS_NAME_DIR
  value: "${HDFS_NAME_DIR:/data/hdfs/name}"

- name: HDFS_REPLICATION
  value: "${HDFS_REPLICATION:3}"

# 监控配置
- name: ENABLE_MONITORING
  value: "${ENABLE_MONITORING:true}"

- name: PROMETHEUS_PORT
  value: "${PROMETHEUS_PORT:9090}"

- name: GRAFANA_PORT
  value: "${GRAFANA_PORT:3000}"
</code></pre>
<h3 id="3-企业应用系统示例"><a class="header" href="#3-企业应用系统示例">3. 企业应用系统示例</a></h3>
<p>企业级应用系统的系统配置：</p>
<pre><code class="language-yaml"># sys/sys_model.yml
name: enterprise_application_system
model: x86-ubt22-k8s
vender: EnterpriseCorp
metadata:
  description: "Enterprise application system with high availability"
  version: "3.2.0"
  tags: [enterprise, high-availability, production]

# sys/mod_list.yml
- name: load_balancer
  addr:
    repo: https://github.com/galaxy-operators/haproxy
    tag: v2.8.0
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: LOAD_BALANCER_PORT
      value: 80
    - name: SSL_PORT
      value: 443
    - name: BACKEND_CHECK_INTERVAL
      value: 10

- name: web_frontend
  addr:
    repo: https://github.com/galaxy-operators/web-frontend
    tag: v2.1.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["api_gateway"]
  vars:
    - name: REPLICAS
      value: 3
    - name: API_BASE_URL
      value: "https://api.example.com"

- name: api_gateway
  addr:
    repo: https://github.com/galaxy-operators/api-gateway
    tag: v3.0.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["auth_service", "user_service"]
  vars:
    - name: RATE_LIMIT_PER_MINUTE
      value: 1000
    - name: CIRCUIT_BREAKER_THRESHOLD
      value: 50
    - name: CACHE_TTL_SECONDS
      value: 300

- name: auth_service
  addr:
    repo: https://github.com/galaxy-operators/auth-service
    tag: v4.1.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["postgres_primary", "redis_auth"]
  vars:
    - name: REPLICAS
      value: 2
    - name: JWT_EXPIRATION_HOURS
      value: 24
    - name: PASSWORD_POLICY_MIN_LENGTH
      value: 12

- name: user_service
  addr:
    repo: https://github.com/galaxy-operators/user-service
    tag: v3.5.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["postgres_primary", "redis_cache"]
  vars:
    - name: REPLICAS
      value: 3
    - name: CACHE_TTL_MINUTES
      value: 30
    - name: PROFILE_IMAGE_MAX_SIZE
      value: 5242880  # 5MB

- name: business_logic_service
  addr:
    repo: https://github.com/galaxy-operators/business-service
    tag: v2.8.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["postgres_primary", "message_queue", "redis_cache"]
  vars:
    - name: REPLICAS
      value: 4
    - name: WORKER_THREADS
      value: 16
    - name: BATCH_SIZE
      value: 100

- name: reporting_service
  addr:
    repo: https://github.com/galaxy-operators/reporting-service
    tag: v1.6.0
  model: x86-ubt22-k8s
  enable: "${ENABLE_REPORTING:true}"
  depends_on: ["postgres_readonly", "data_warehouse"]
  vars:
    - name: REPLICAS
      value: 1
    - name: REPORT_SCHEDULE_CRON
      value: "0 2 * * *"  # 每天凌晨2点

- name: postgres_primary
  addr:
    repo: https://github.com/galaxy-operators/postgresql-ha
    tag: v15.5.0
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: POSTGRES_VERSION
      value: "15"
    - name: DATABASE_NAME
      value: "enterprise_app"
    - name: MAX_CONNECTIONS
      value: 500
    - name: WAL_KEEP_SEGMENTS
      value: 100

- name: postgres_readonly
  addr:
    repo: https://github.com/galaxy-operators/postgresql-ha
    tag: v15.5.0
  model: x86-ubt22-k8s
  enable: true
  depends_on: ["postgres_primary"]
  vars:
    - name: REPLICAS
      value: 2
    - name: MAX_CONNECTIONS
      value: 300
    - name: HOT_STANDBY
      value: true

- name: redis_auth
  addr:
    repo: https://github.com/galaxy-operators/redis-ha
    tag: v7.2.4
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: REPLICAS
      value: 3
    - name: MAX_MEMORY
      value: "512MB"
    - name: AUTH_ENABLED
      value: true

- name: redis_cache
  addr:
    repo: https://github.com/galaxy-operators/redis-ha
    tag: v7.2.4
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: REPLICAS
      value: 6
    - name: MAX_MEMORY
      value: "2GB"
    - name: CACHE_POLICY
      value: "allkeys-lru"

- name: message_queue
  addr:
    repo: https://github.com/galaxy-operators/rabbitmq-ha
    tag: v3.12.0
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: REPLICAS
      value: 3
    - name: QUEUE_TYPE
      value: "quorum"
    - name: MAX_MESSAGE_SIZE
      value: 52428800  # 50MB

- name: data_warehouse
  addr:
    repo: https://github.com/galaxy-operators/clickhouse
    tag: v23.8.0
  model: x86-ubt22-k8s
  enable: "${ENABLE_DATA_WAREHOUSE:false}"
  vars:
    - name: REPLICAS
      value: 3
    - name: SHARDS
      value: 2
    - name: REPLICAS_PER_SHARD
      value: 2

- name: monitoring_stack
  addr:
    repo: https://github.com/galaxy-operators/enterprise-monitoring
    tag: v2.5.0
  model: x86-ubt22-k8s
  enable: true
  vars:
    - name: RETENTION_DAYS
      value: 90
    - name: ALERT_SEVERITY_LEVELS
      value: ["critical", "warning", "info"]
    - name: NOTIFICATION_CHANNELS
      value: ["email", "slack", "pagerduty"]

# sys/vars.yml
vars:
# 应用配置
- name: ENVIRONMENT
  value: "${ENVIRONMENT:production}"

- name: APP_VERSION
  value: "${APP_VERSION:3.2.0}"

- name: DOMAIN_NAME
  value: "${DOMAIN_NAME:enterprise.example.com}"

- name: NAMESPACE
  value: "${NAMESPACE:enterprise-app}"

# 安全配置
- name: ENABLE_MTLS
  value: "${ENABLE_MTLS:true}"

- name: CERTIFICATE_ISSUER
  value: "${CERTIFICATE_ISSUER:letsencrypt-prod}"

- name: PASSWORD_ROTATION_DAYS
  value: "${PASSWORD_ROTATION_DAYS:90}"

- name: SESSION_TIMEOUT_MINUTES
  value: "${SESSION_TIMEOUT_MINUTES:30}"

# 数据库配置
- name: DATABASE_BACKUP_SCHEDULE
  value: "${DATABASE_BACKUP_SCHEDULE:0 1 * * *}"  # 每天凌晨1点

- name: DATABASE_RETENTION_DAYS
  value: "${DATABASE_RETENTION_DAYS:30}"

- name: CONNECTION_POOL_SIZE
  value: "${CONNECTION_POOL_SIZE:20}"

# 缓存配置
- name: CACHE_DEFAULT_TTL
  value: "${CACHE_DEFAULT_TTL:3600}"  # 1小时

- name: CACHE_MAX_SIZE
  value: "${CACHE_MAX_SIZE:10000}"

- name: CACHE_REFRESH_INTERVAL
  value: "${CACHE_REFRESH_INTERVAL:300}"  # 5分钟

# 消息队列配置
- name: MESSAGE_QUEUE_MAX_RETRIES
  value: "${MESSAGE_QUEUE_MAX_RETRIES:3}"

- name: MESSAGE_QUEUE_DELAY_SECONDS
  value: "${MESSAGE_QUEUE_DELAY_SECONDS:60}"

- name: MESSAGE_QUEUE_PREFETCH_COUNT
  value: "${MESSAGE_QUEUE_PREFETCH_COUNT:10}"

# 高可用配置
- name: HIGH_AVAILABILITY_ENABLED
  value: "${HIGH_AVAILABILITY_ENABLED:true}"

- name: HEALTH_CHECK_INTERVAL_SECONDS
  value: "${HEALTH_CHECK_INTERVAL_SECONDS:30}"

- name: FAILURE_DETECTION_SECONDS
  value: "${FAILURE_DETECTION_SECONDS:60}"

- name: AUTO_FAILOVER_ENABLED
  value: "${AUTO_FAILOVER_ENABLED:true}"

# 性能配置
- name: DEFAULT_REPLICAS
  value: "${DEFAULT_REPLICAS:2}"

- name: MAX_REPLICAS
  value: "${MAX_REPLICAS:10}"

- name: CPU_REQUEST
  value: "${CPU_REQUEST:500m}"

- name: MEMORY_REQUEST
  value: "${MEMORY_REQUEST:1Gi}"

- name: CPU_LIMIT
  value: "${CPU_LIMIT:2000m}"

- name: MEMORY_LIMIT
  value: "${MEMORY_LIMIT:4Gi}"

# 监控配置
- name: MONITORING_ENABLED
  value: "${MONITORING_ENABLED:true}"

- name: ALERT_EMAIL_RECIPIENTS
  value: "${ALERT_EMAIL_RECIPIENTS:devops-alerts@example.com}"

- name: SLACK_WEBHOOK_URL
  value: "${SLACK_WEBHOOK_URL}"

- name: PAGERDUTY_SERVICE_KEY
  value: "${PAGERDUTY_SERVICE_KEY}"

# 业务配置
- name: BUSINESS_HOURS_START
  value: "${BUSINESS_HOURS_START:09:00}"

- name: BUSINESS_HOURS_END
  value: "${BUSINESS_HOURS_END:18:00}"

- name: MAINTENANCE_WINDOW_START
  value: "${MAINTENANCE_WINDOW_START:02:00}"

- name: MAINTENANCE_WINDOW_END
  value: "${MAINTENANCE_WINDOW_END:04:00}"

- name: FEATURE_FLAGS
  value: "${FEATURE_FLAGS:new-dashboard,advanced-analytics}"
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>Sys-Operator 是 Galaxy Ops 框架中用于管理完整系统的核心组件。通过组合多个 Mod-Operator，Sys-Operator 提供了系统级别的统一管理、协调和部署能力。</p>
<h3 id="关键要点总结"><a class="header" href="#关键要点总结">关键要点总结</a></h3>
<h4 id="1-系统架构设计"><a class="header" href="#1-系统架构设计">1. <strong>系统架构设计</strong></a></h4>
<ul>
<li><strong>模块组合</strong>: 将多个独立的 Mod-Operator 组合成完整系统</li>
<li><strong>统一管理</strong>: 提供系统级别的配置和管理接口</li>
<li><strong>环境适配</strong>: 支持不同目标环境和部署场景</li>
</ul>
<h4 id="2-配置管理"><a class="header" href="#2-配置管理">2. <strong>配置管理</strong></a></h4>
<ul>
<li><strong>标准化结构</strong>: 遵循统一的文件结构和命名规范</li>
<li><strong>变量系统</strong>: 支持环境变量覆盖、条件配置、类型验证</li>
<li><strong>模块引用</strong>: 灵活的模块地址和依赖管理</li>
</ul>
<h4 id="3-工作流设计"><a class="header" href="#3-工作流设计">3. <strong>工作流设计</strong></a></h4>
<ul>
<li><strong>系统生命周期</strong>: 完整的系统初始化、更新、本地化、安装、启动、停止流程</li>
<li><strong>错误处理</strong>: 完善的错误处理、回滚和恢复机制</li>
<li><strong>执行优化</strong>: 支持并行执行、缓存优化、资源限制</li>
</ul>
<h4 id="4-最佳实践"><a class="header" href="#4-最佳实践">4. <strong>最佳实践</strong></a></h4>
<ul>
<li><strong>模块化设计</strong>: 功能清晰、职责明确的模块划分</li>
<li><strong>环境一致性</strong>: 不同环境间的配置一致性保证</li>
<li><strong>安全性</strong>: 最小权限、敏感信息保护、审计日志</li>
<li><strong>监控调试</strong>: 详细的日志记录、断言验证、性能监控</li>
</ul>
<h4 id="5-扩展能力"><a class="header" href="#5-扩展能力">5. <strong>扩展能力</strong></a></h4>
<ul>
<li><strong>平台支持</strong>: 支持多种目标平台组合</li>
<li><strong>模块生态</strong>: 丰富的模块仓库和社区支持</li>
<li><strong>工具链</strong>: 完整的开发、测试、部署工具链</li>
</ul>
<h3 id="使用建议"><a class="header" href="#使用建议">使用建议</a></h3>
<ol>
<li><strong>从小规模开始</strong>: 先从简单的系统开始，逐步扩展功能</li>
<li><strong>模块复用</strong>: 充分利用现有的 Mod-Operator 模块</li>
<li><strong>环境隔离</strong>: 严格区分开发、测试、生产环境</li>
<li><strong>监控告警</strong>: 建立完善的监控和告警体系</li>
<li><strong>文档维护</strong>: 保持系统配置和使用文档的同步更新</li>
</ol>
<p>通过合理使用 Sys-Operator，可以显著提升复杂系统的管理效率，降低运维复杂度，确保系统的一致性和可靠性，为企业的数字化转型提供强有力的技术支撑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-开发指南"><a class="header" href="#mod-operator-开发指南">Mod-Operator 开发指南</a></h1>
<h2 id="概述-6"><a class="header" href="#概述-6">概述</a></h2>
<p>Mod-Operator 是 Galaxy Ops 框架的核心组件，用于定义和管理可复用的运维模块。每个 Mod-Operator 代表一个独立的软件组件或服务，包含完整的生命周期管理能力，包括安装、配置、启动、停止、监控等操作。</p>
<h3 id="核心特性-1"><a class="header" href="#核心特性-1">核心特性</a></h3>
<ul>
<li><strong>多平台支持</strong>: 支持不同的 CPU 架构、操作系统和运行环境组合</li>
<li><strong>模块化设计</strong>: 每个模块都是独立的，可单独开发和版本管理</li>
<li><strong>工作流驱动</strong>: 使用 GXL 语言定义复杂的运维操作流程</li>
<li><strong>模板本地化</strong>: 支持配置模板渲染和环境适配</li>
<li><strong>依赖管理</strong>: 处理模块间的依赖关系</li>
<li><strong>构件管理</strong>: 统一的软件包下载、缓存和分发机制</li>
</ul>
<h3 id="在-galaxy-ops-生态系统中的位置-1"><a class="header" href="#在-galaxy-ops-生态系统中的位置-1">在 Galaxy Ops 生态系统中的位置</a></h3>
<pre><code>gmod (创建模块) → gsys (组合系统) → gops (工程管理) → gflow (执行工作流)
</code></pre>
<p>Mod-Operator 是整个运维体系的基础构建块，由 <code>gmod</code> 工具创建和管理，最终通过 <code>gflow</code> 执行具体的运维操作。</p>
<h2 id="文档索引"><a class="header" href="#文档索引">文档索引</a></h2>
<p>本指南被拆分为以下文档以便于维护：</p>
<ul>
<li><strong><a href="operator/mod/./CONFIGURATION.html">配置说明</a></strong> - 核心配置文件详细说明</li>
<li><strong><a href="operator/mod/./DEVELOPMENT.html">开发指南</a></strong> - 开发工作流和最佳实践</li>
<li><strong><a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a></strong> - 调试和故障排除</li>
<li><strong><a href="operator/mod/./REFERENCE.html">API 参考</a></strong> - API 和枚举参考</li>
</ul>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<h3 id="创建新模块"><a class="header" href="#创建新模块">创建新模块</a></h3>
<pre><code class="language-bash"># 创建基础模块
gmod new postgresql

# 创建带目标的模块
gmod new postgresql --targets arm-mac14-host,x86-ubt22-k8s

# 从模板创建
gmod new postgresql --template database
</code></pre>
<h3 id="基本文件结构"><a class="header" href="#基本文件结构">基本文件结构</a></h3>
<pre><code>module_name/
├── mod/                              # 模块定义目录
│   ├── arm-mac14-host/              # ARM + macOS14 + Host 环境
│   │   ├── _gal/                    # 项目配置目录
│   │   ├── local/                   # 本地化生成的配置
│   │   ├── spec/                    # 规范文件目录
│   │   ├── values/                  # 值文件目录
│   │   ├── vars.yml                 # 变量定义
│   │   ├── setting.yml              # 本地化设置
│   │   └── workflows/               # 工作流定义
│   └── x86-ubt22-k8s/              # x86 + Ubuntu22 + K8s 环境
│       └── [相同的子目录结构]
├── mod-prj.yml                      # 模块项目配置
├── version.txt                      # 版本文件
├── .gitignore                       # Git 忽略文件
└── test_res/                        # 测试资源目录
</code></pre>
<h3 id="支持的目标平台"><a class="header" href="#支持的目标平台">支持的目标平台</a></h3>
<div class="table-wrapper"><table><thead><tr><th>组合</th><th>CPU架构</th><th>操作系统</th><th>运行环境</th><th>适用场景</th></tr></thead><tbody>
<tr><td><code>arm-mac14-host</code></td><td>ARM</td><td>macOS 14+</td><td>Host 宿主机</td><td>Apple Silicon Mac 本地开发</td></tr>
<tr><td><code>x86-ubt22-host</code></td><td>x86_64</td><td>Ubuntu 22.04</td><td>Host 宿主机</td><td>Linux 服务器本地部署</td></tr>
<tr><td><code>x86-ubt22-k8s</code></td><td>x86_64</td><td>Ubuntu 22.04</td><td>Kubernetes</td><td>K8s 集群容器化部署</td></tr>
</tbody></table>
</div>
<h2 id="开发工作流-1"><a class="header" href="#开发工作流-1">开发工作流</a></h2>
<h3 id="1-定义模块规范"><a class="header" href="#1-定义模块规范">1. 定义模块规范</a></h3>
<ul>
<li>编辑 <code>spec/artifact.yml</code> - 构件定义</li>
<li>编辑 <code>spec/depends.yml</code> - 依赖定义</li>
</ul>
<h3 id="2-配置变量"><a class="header" href="#2-配置变量">2. 配置变量</a></h3>
<ul>
<li>编辑 <code>vars.yml</code> - 变量定义</li>
<li>编辑 <code>values/_value.yml</code> - 默认值</li>
</ul>
<h3 id="3-编写工作流"><a class="header" href="#3-编写工作流">3. 编写工作流</a></h3>
<ul>
<li>编辑 <code>workflows/operators.gxl</code> - 使用 GXL 定义工作流</li>
</ul>
<h3 id="4-测试和验证"><a class="header" href="#4-测试和验证">4. 测试和验证</a></h3>
<ul>
<li>使用 <code>gflow</code> 测试工作流</li>
<li>使用 <code>gmod validate</code> 验证配置</li>
</ul>
<h3 id="5-本地化模块"><a class="header" href="#5-本地化模块">5. 本地化模块</a></h3>
<ul>
<li>使用 <code>gmod localize</code> 生成特定环境配置</li>
</ul>
<h2 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h2>
<h3 id="modelstd-标准型号"><a class="header" href="#modelstd-标准型号">ModelSTD 标准型号</a></h3>
<p>Mod-Operator 使用 <code>ModelSTD</code> 标准型号来定义目标平台，格式为 <code>arch-os-spc</code>：</p>
<ul>
<li><strong>CPU 架构</strong>: X86 (x86_64), ARM</li>
<li><strong>操作系统</strong>: MAC14 (macOS 14+), UBT22 (Ubuntu 22.04), WIN10 (Windows 10+), COS7 (CentOS 7)</li>
<li><strong>运行空间</strong>: Host (宿主机环境), K8S (Kubernetes 环境)</li>
</ul>
<h3 id="构件管理"><a class="header" href="#构件管理">构件管理</a></h3>
<p>构件定义了模块所需的软件包和下载资源，包括：</p>
<ul>
<li>名称 (name)</li>
<li>版本 (version)</li>
<li>原始地址 (origin_addr)</li>
<li>缓存地址 (cache_addr)</li>
<li>缓存启用 (cache_enable)</li>
<li>本地文件名 (local)</li>
</ul>
<h3 id="依赖管理-3"><a class="header" href="#依赖管理-3">依赖管理</a></h3>
<p>模块可以依赖其他模块或资源，支持：</p>
<ul>
<li>本地路径依赖</li>
<li>Git 仓库依赖</li>
<li>条件依赖（根据变量启用/禁用）</li>
<li>版本约束</li>
</ul>
<h3 id="工作流引擎"><a class="header" href="#工作流引擎">工作流引擎</a></h3>
<p>使用 GXL (Galaxy eXecution Language) 定义运维操作：</p>
<ul>
<li>支持任务定义和执行</li>
<li>变量模板渲染</li>
<li>条件分支和循环</li>
<li>外部命令执行</li>
<li>错误处理和重试机制</li>
</ul>
<h2 id="相关工具"><a class="header" href="#相关工具">相关工具</a></h2>
<ul>
<li><strong>gmod</strong>: 模块创建和管理工具</li>
<li><strong>gops</strong>: 工程管理工具</li>
<li><strong>gflow</strong>: 工作流执行工具</li>
<li><strong>gsys</strong>: 系统组合工具</li>
</ul>
<h2 id="更多信息"><a class="header" href="#更多信息">更多信息</a></h2>
<p>查看详细文档：</p>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./DEVELOPMENT.html">开发指南</a> - 开发最佳实践</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>📖 <a href="operator/mod/./EXAMPLES.html">示例参考</a> - 完整的模块示例</li>
<li>📖 <a href="operator/mod/./REFERENCE.html">API 参考</a> - API 和枚举定义</li>
</ul>
<hr />
<p><em>Mod-Operator 是 Galaxy Ops 框架的核心构建块，通过标准化的文件结构、配置管理和工作流定义，实现了软件组件的模块化运维管理。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-开发指南-1"><a class="header" href="#mod-operator-开发指南-1">Mod-Operator 开发指南</a></h1>
<p>本文档详细介绍 Mod-Operator 的开发工作流程、最佳实践和技巧，帮助开发者高效地创建高质量的运维模块。</p>
<h2 id="开发工作流-2"><a class="header" href="#开发工作流-2">开发工作流</a></h2>
<h3 id="1-创建新模块"><a class="header" href="#1-创建新模块">1. 创建新模块</a></h3>
<p>使用 <code>gmod</code> 工具快速创建新模块的骨架结构。</p>
<h4 id="基础模块创建"><a class="header" href="#基础模块创建">基础模块创建</a></h4>
<pre><code class="language-bash"># 创建基础模块
//fix: use gmod cmd and args

</code></pre>
<h4 id="生成的模块结构"><a class="header" href="#生成的模块结构">生成的模块结构</a></h4>
<pre><code class="language-bash">postgresql/
├── mod/
│   ├── arm-mac14-host/
│   │   ├── spec/
│   │   │   ├── artifact.yml
│   │   │   └── depends.yml
│   │   ├── vars.yml
│   │   ├── setting.yml
│   │   ├── values/
│   │   │   ├── _value.yml
│   │   │   └── _used.yml
│   │   ├── workflows/
│   │   │   └── operators.gxl
│   │   └── _gal/
│   │       ├── work.gxl
│   │       └── project.toml
│   └── x86-ubt22-k8s/
│       └── [相同结构]
├── mod-prj.yml
├── version.txt
├── .gitignore
└── README.md
</code></pre>
<h3 id="2-模块开发步骤"><a class="header" href="#2-模块开发步骤">2. 模块开发步骤</a></h3>
<h4 id="步骤-1定义构件和依赖"><a class="header" href="#步骤-1定义构件和依赖">步骤 1：定义构件和依赖</a></h4>
<p>编辑 <code>spec/artifact.yml</code> 和 <code>spec/depends.yml</code>：</p>
<pre><code class="language-bash"># 编辑构件配置
vim mod/arm-mac14-host/spec/artifact.yml

# 编辑依赖配置
vim mod/arm-mac14-host/spec/depends.yml
</code></pre>
<p><strong>artifact.yml 示例：</strong></p>
<pre><code class="language-yaml">- name: postgresql
  version: 17.4
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz

- name: pcre
  version: 8.45
  origin_addr:
    url: https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz
  local: pcre-8.45.tar.gz
</code></pre>
<p><strong>depends.yml 示例：</strong></p>
<pre><code class="language-yaml">dep_root: ./depends

deps:
- addr:
    path: ./common_libs
  local: common_libs
  enable: true

- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "3.0.0"
  local: openssl
  enable: true
</code></pre>
<h4 id="步骤-2配置变量和默认值"><a class="header" href="#步骤-2配置变量和默认值">步骤 2：配置变量和默认值</a></h4>
<p>编辑变量配置文件：</p>
<pre><code class="language-bash"># 定义环境变量
vim mod/arm-mac14-host/vars.yml

</code></pre>
<p><strong>vars.yml 示例：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  desp: "数据库端口号"
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: MAX_CONNECTIONS
  type: integer
  min: 1
  max: 1000
  value: 100

- name: DATA_DIR
  value: "/var/lib/postgresql"

- name: ENABLE_SSL
  type: boolean
  value: false
</code></pre>
<h4 id="步骤-3编写工作流"><a class="header" href="#步骤-3编写工作流">步骤 3：编写工作流</a></h4>
<p>编辑 <code>workflows/operators.gxl</code> 定义运维操作：</p>
<pre><code class="language-bash"># 编写操作工作流
vim mod/arm-mac14-host/workflows/operators.gxl
</code></pre>
<h4 id="步骤-4配置本地化设置按需"><a class="header" href="#步骤-4配置本地化设置按需">步骤 4：配置本地化设置[按需]</a></h4>
<p>编辑 <code>setting.yml</code> 配置模板渲染：</p>
<pre><code class="language-bash"># 配置本地化设置
vim mod/arm-mac14-host/setting.yml
</code></pre>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - LICENSE
    - "*.log"

  templatize_cust:
    label_beg: '{{'
    label_end: '}}'
</code></pre>
<h4 id="步骤-5验证和测试"><a class="header" href="#步骤-5验证和测试">步骤 5：验证和测试</a></h4>
<pre><code class="language-bash">
# 生成本地化配置
gmod localize

# 测试工作流
gflow install --dry-run
</code></pre>
<h3 id="3-开发工具使用"><a class="header" href="#3-开发工具使用">3. 开发工具使用</a></h3>
<h4 id="gmod---模块管理工具"><a class="header" href="#gmod---模块管理工具">gmod - 模块管理工具</a></h4>
<pre><code class="language-bash"># 创建模块
gmod new module_name


# 生成本地化配置
gmod localize

</code></pre>
<h4 id="gflow---工作流执行工具"><a class="header" href="#gflow---工作流执行工具">gflow - 工作流执行工具</a></h4>
<pre><code class="language-bash"># 执行工作流
gflow install
gflow start
gflow stop
gflow restart

# 调试模式
gflow install -d 1  # 详细输出
gflow install -d 2  # 更详细输出
gflow install -d 3  # 最详细输出

# 试运行模式
gflow install --dry-run

</code></pre>
<h2 id="最佳实践-5"><a class="header" href="#最佳实践-5">最佳实践</a></h2>
<h3 id="1-模块设计原则"><a class="header" href="#1-模块设计原则">1. 模块设计原则</a></h3>
<h4 id="单一职责原则"><a class="header" href="#单一职责原则">单一职责原则</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 专注单一组件
name: postgresql
description: "PostgreSQL 数据库管理模块"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 职责混乱
name: database_stack
description: "数据库、缓存、消息队列管理模块"
</code></pre>
<h4 id="接口一致性"><a class="header" href="#接口一致性">接口一致性</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 统一的任务命名
#[task(name="gops@install")]
flow install { ... }

#[task(name="gops@start")]
flow start { ... }

#[task(name="gops@stop")]
flow stop { ... }

#[task(name="gops@restart")]
flow restart { ... }
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 不一致的命名
#[task(name="install")]
flow install { ... }

#[task(name="startup")]
flow start { ... }

#[task(name="halt")]
flow stop { ... }
</code></pre>
<h4 id="配置外部化"><a class="header" href="#配置外部化">配置外部化</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># 所有配置参数提取到变量
vars:
- name: DATABASE_PORT
  value: 5432

- name: MAX_CONNECTIONS
  value: 100

- name: DATA_DIR
  value: "/var/lib/postgresql"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 硬编码配置
flow install {
    gx.cmd("postgres -p 5432 -d /var/lib/postgresql");
}
</code></pre>
<h3 id="2-工作流设计"><a class="header" href="#2-工作流设计">2. 工作流设计</a></h3>
<h4 id="幂等性设计-1"><a class="header" href="#幂等性设计-1">幂等性设计</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-gxl">flow install {
    // 检查是否已安装
    if gx.defined("/usr/local/bin/postgres") {
        gx.echo("PostgreSQL 已安装，跳过安装步骤");
        return;
    }

    // 执行安装
    gx.cmd("./install.sh");

    // 验证安装
    gx.assert(gx.path_exists("/usr/local/bin/postgres"));
}
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-gxl">flow install {
    // 没有检查，可能重复安装
    gx.cmd("./install.sh");
}
</code></pre>
<h3 id="3-变量管理"><a class="header" href="#3-变量管理">3. 变量管理</a></h3>
<h4 id="命名规范"><a class="header" href="#命名规范">命名规范</a></h4>
<p><strong>✅ 好的命名：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: 5432

- name: MAX_CONNECTIONS
  value: 100

- name: DATA_DIRECTORY
  value: "/var/lib/postgresql"
</code></pre>
<p><strong>❌ 不好的命名：</strong></p>
<pre><code class="language-yaml">vars:
- name: port
  value: 5432

- name: max_conn
  value: 100

- name: data_dir
  value: "/var/lib/postgresql"
</code></pre>
<h4 id="类型安全"><a class="header" href="#类型安全">类型安全</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: ENABLE_SSL
  type: boolean
  value: false

- name: LOG_LEVEL
  type: enum
  values: [debug, info, warn, error]
  value: info
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: "5432"  # 字符串而不是数字

- name: ENABLE_SSL
  value: "false"  # 字符串而不是布尔值
</code></pre>
<h4 id="环境变量支持-1"><a class="header" href="#环境变量支持-1">环境变量支持</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  value: "${POSTGRES_PORT:5432}"  # 默认值 5432

- name: INSTALL_PREFIX
  value: "${PREFIX:/usr/local}"  # 默认 /usr/local

- name: DEBUG_MODE
  type: boolean
  value: "${DEBUG:false}"  # 默认 false
</code></pre>
<h3 id="4-依赖管理"><a class="header" href="#4-依赖管理">4. 依赖管理</a></h3>
<h4 id="版本约束"><a class="header" href="#版本约束">版本约束</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "3.0.0"  # 语义化版本
  enable: true

- addr:
    repo: https://github.com/pcre/pcre.git
    tag: "8.45"
  enable: true
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/openssl/openssl.git
    tag: "latest"  # 不稳定的版本
  enable: true
</code></pre>
<h4 id="条件依赖"><a class="header" href="#条件依赖">条件依赖</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: "${USE_FEATURES:true}"

- addr:
    repo: https://github.com/debug/tools.git
    branch: main
  local: debug_tools
  enable: "${BUILD_MODE:debug}" == "debug"
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: true  # 应该根据条件启用
</code></pre>
<h4 id="本地依赖优先"><a class="header" href="#本地依赖优先">本地依赖优先</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml">deps:
# 本地依赖优先
- addr:
    path: ./local_libs
  local: common_libs
  enable: true

# 外部依赖作为后备
- addr:
    repo: https://github.com/external/lib.git
    tag: "1.0.0"
  local: common_libs
  enable: false  # 默认禁用
</code></pre>
<h3 id="5-文档和维护"><a class="header" href="#5-文档和维护">5. 文档和维护</a></h3>
<h4 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h4>
<p><strong>✅ 好的做法：</strong></p>
<pre><code class="language-yaml"># mod-prj.yml
name: postgresql
version: "17.4.0"
description: "PostgreSQL 数据库管理模块"

# version.txt
17.4.0
</code></pre>
<p><strong>❌ 不好的做法：</strong></p>
<pre><code class="language-yaml"># 没有版本管理
name: postgresql
version: "latest"
description: "PostgreSQL 数据库管理模块"
</code></pre>
<h2 id="调试和故障排除-1"><a class="header" href="#调试和故障排除-1">调试和故障排除</a></h2>
<h3 id="常见问题诊断"><a class="header" href="#常见问题诊断">常见问题诊断</a></h3>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>遵循本开发指南，可以创建出高质量、可维护、可扩展的 Mod-Operator 模块。关键要点：</p>
<ol>
<li><strong>标准化开发流程</strong>：遵循一致的模块创建和开发流程</li>
<li><strong>最佳实践设计</strong>：采用单一职责、幂等性、错误处理等设计原则</li>
<li><strong>有效的调试策略</strong>：使用详细的日志、断言和分步调试</li>
<li><strong>性能优化</strong>：利用并行执行和缓存机制</li>
<li><strong>高级功能</strong>：掌握条件工作流、模板系统</li>
</ol>
<p>通过合理应用这些技巧和最佳实践，可以显著提升模块开发效率和质量，为复杂的系统运维提供坚实的基础。</p>
<h2 id="相关资源"><a class="header" href="#相关资源">相关资源</a></h2>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>📖 <a href="operator/mod/./EXAMPLES.html">示例参考</a> - 完整的模块示例</li>
<li>📖 <a href="operator/mod/./REFERENCE.html">API 参考</a> - API 和枚举定义</li>
<li>🛠️ <a href="operator/mod/../gmod/">gmod 工具文档</a> - 模块管理工具使用指南</li>
<li>🛠️ <a href="operator/mod/../gflow/">gflow 工具文档</a> - 工作流执行工具使用指南</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-配置文件详解"><a class="header" href="#mod-operator-配置文件详解">Mod-Operator 配置文件详解</a></h1>
<p>本文档详细介绍 Mod-Operator 的各个配置文件及其使用方法。</p>
<h2 id="配置文件概览"><a class="header" href="#配置文件概览">配置文件概览</a></h2>
<p>Mod-Operator 使用多种配置文件来定义模块的行为和属性：</p>
<div class="table-wrapper"><table><thead><tr><th>文件</th><th>位置</th><th>作用</th><th>格式</th></tr></thead><tbody>
<tr><td><code>spec/artifact.yml</code></td><td><code>mod/{platform}/spec/</code></td><td>定义软件包和资源</td><td>YAML</td></tr>
<tr><td><code>spec/depends.yml</code></td><td><code>mod/{platform}/spec/</code></td><td>定义依赖关系</td><td>YAML</td></tr>
<tr><td><code>vars.yml</code></td><td><code>mod/{platform}/</code></td><td>定义环境变量</td><td>YAML</td></tr>
<tr><td><code>setting.yml</code></td><td><code>mod/{platform}/</code></td><td>配置本地化行为</td><td>YAML</td></tr>
<tr><td><code>workflows/operators.gxl</code></td><td><code>mod/{platform}/workflows/</code></td><td>工作流定义</td><td>GXL</td></tr>
<tr><td><code>mod-prj.yml</code></td><td>根目录</td><td>项目配置</td><td>YAML</td></tr>
</tbody></table>
</div>
<h2 id="specartifactyml---构件定义"><a class="header" href="#specartifactyml---构件定义">spec/artifact.yml - 构件定义</a></h2>
<p><code>artifact.yml</code> 是 Mod-Operator 中最重要的配置文件之一，它定义了模块所需的软件包、资源及其下载配置。</p>
<h3 id="基本格式"><a class="header" href="#基本格式">基本格式</a></h3>
<pre><code class="language-yaml"># 单个构件定义
- name: postgresql
  version: 0.1.0
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz
</code></pre>
<h3 id="字段说明"><a class="header" href="#字段说明">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>是</td><td>构件名称</td></tr>
<tr><td><code>version</code></td><td>String</td><td>是</td><td>构件版本</td></tr>
<tr><td><code>origin_addr</code></td><td>Object</td><td>是</td><td>原始下载地址</td></tr>
<tr><td><code>cache_addr</code></td><td>Object</td><td>否</td><td>缓存地址（可选）</td></tr>
<tr><td><code>cache_enable</code></td><td>Boolean</td><td>否</td><td>是否启用缓存（默认 false）</td></tr>
<tr><td><code>local</code></td><td>String</td><td>是</td><td>本地存储文件名</td></tr>
</tbody></table>
</div>
<h3 id="地址类型支持"><a class="header" href="#地址类型支持">地址类型支持</a></h3>
<h4 id="http-地址"><a class="header" href="#http-地址">HTTP 地址</a></h4>
<pre><code class="language-yaml">- name: nginx
  version: 1.25.3
  origin_addr:
    url: https://nginx.org/download/nginx-1.25.3.tar.gz
  local: nginx-1.25.3.tar.gz
</code></pre>
<h4 id="git-仓库"><a class="header" href="#git-仓库">Git 仓库</a></h4>
<pre><code class="language-yaml">- name: galaxy-flow
  version: 0.1.0
  origin_addr:
    repo: https://github.com/galaxy-sec/galaxy-flow.git
    branch: main
  local: galaxy-flow
</code></pre>
<h4 id="本地路径"><a class="header" href="#本地路径">本地路径</a></h4>
<pre><code class="language-yaml">- name: custom-library
  version: 1.0.0
  origin_addr:
    path: /path/to/local/library.tar.gz
  local: custom-library.tar.gz
</code></pre>
<h3 id="多构件定义"><a class="header" href="#多构件定义">多构件定义</a></h3>
<pre><code class="language-yaml">- name: postgresql
  version: 17.4
  origin_addr:
    url: https://mirrors.aliyun.com/postgresql/latest/postgresql-17.4.tar.gz
  cache_enable: false
  local: postgresql-17.4.tar.gz

- name: pcre
  version: 8.45
  origin_addr:
    url: https://sourceforge.net/projects/pcre/files/pcre/8.45/pcre-8.45.tar.gz
  local: pcre-8.45.tar.gz

- name: openssl
  version: 3.0.0
  origin_addr:
    repo: https://github.com/openssl/openssl.git
    tag: openssl-3.0.0
  local: openssl-3.0.0
</code></pre>
<h3 id="缓存配置"><a class="header" href="#缓存配置">缓存配置</a></h3>
<pre><code class="language-yaml">- name: large-package
  version: 2.0.0
  origin_addr:
    url: https://example.com/large-package.tar.gz
  cache_addr:
    url: https://cache.example.com/large-package.tar.gz
  cache_enable: true
  local: large-package.tar.gz
</code></pre>
<h2 id="specdependsyml---依赖定义"><a class="header" href="#specdependsyml---依赖定义">spec/depends.yml - 依赖定义</a></h2>
<p><code>depends.yml</code> 定义模块依赖的其他模块或资源，支持多种依赖类型和条件依赖。</p>
<h3 id="基本格式-1"><a class="header" href="#基本格式-1">基本格式</a></h3>
<pre><code class="language-yaml">dep_root: ./depends

deps:
- addr:
    path: ./data
  local: data_resources
  enable: true
</code></pre>
<h3 id="字段说明-1"><a class="header" href="#字段说明-1">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>dep_root</code></td><td>String</td><td>是</td><td>依赖根目录</td></tr>
<tr><td><code>deps</code></td><td>Array</td><td>是</td><td>依赖列表</td></tr>
<tr><td><code>addr</code></td><td>Object</td><td>是</td><td>依赖地址配置</td></tr>
<tr><td><code>local</code></td><td>String</td><td>是</td><td>本地化名称</td></tr>
<tr><td><code>enable</code></td><td>Boolean</td><td>是</td><td>是否启用</td></tr>
</tbody></table>
</div>
<h3 id="依赖地址类型"><a class="header" href="#依赖地址类型">依赖地址类型</a></h3>
<h4 id="本地路径依赖"><a class="header" href="#本地路径依赖">本地路径依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    path: ./common_libs          # 相对路径
  local: common_libs
  enable: true

- addr:
    path: /usr/local/lib        # 绝对路径
  local: system_libs
  enable: false
</code></pre>
<h4 id="git-仓库依赖"><a class="header" href="#git-仓库依赖">Git 仓库依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    repo: https://github.com/user/module.git
    tag: "1.0.0"                # 版本标签
  local: external_module
  enable: true
</code></pre>
<h4 id="条件依赖-1"><a class="header" href="#条件依赖-1">条件依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    path: ./optional_libs
  local: optional_libs
  enable: "${ENABLE_FEATURES:false}"  # 条件启用

- addr:
    repo: https://github.com/debug/debug-tools.git
    branch: main
  local: debug_tools
  enable: "${BUILD_MODE:debug}" == "debug"
</code></pre>
<h4 id="http-url-依赖"><a class="header" href="#http-url-依赖">HTTP URL 依赖</a></h4>
<pre><code class="language-yaml">deps:
- addr:
    url: https://example.com/dependencies.zip
  local: external_deps
  enable: true
</code></pre>
<h2 id="varsyml---变量定义"><a class="header" href="#varsyml---变量定义">vars.yml - 变量定义</a></h2>
<p><code>vars.yml</code> 定义模块使用的环境变量和配置参数，支持类型安全和验证规则。</p>
<h3 id="基本格式-2"><a class="header" href="#基本格式-2">基本格式</a></h3>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  desp: "数据库端口号"
  value: 5432

- name: MAX_CONNECTIONS
  value: 100
</code></pre>
<h3 id="字段说明-2"><a class="header" href="#字段说明-2">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>String</td><td>是</td><td>变量名</td></tr>
<tr><td><code>desp</code></td><td>String</td><td>否</td><td>描述（可选）</td></tr>
<tr><td><code>value</code></td><td>String</td><td>是</td><td>默认值</td></tr>
<tr><td><code>type</code></td><td>String</td><td>否</td><td>类型（string, integer, boolean, enum）</td></tr>
<tr><td><code>min</code></td><td>Number</td><td>否</td><td>最小值（数字类型）</td></tr>
<tr><td><code>max</code></td><td>Number</td><td>否</td><td>最大值（数字类型）</td></tr>
<tr><td><code>values</code></td><td>Array</td><td>否</td><td>枚举值（枚举类型）</td></tr>
</tbody></table>
</div>
<h3 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h3>
<h4 id="字符串变量"><a class="header" href="#字符串变量">字符串变量</a></h4>
<pre><code class="language-yaml">vars:
- name: MODULE_NAME
  desp: "模块名称"
  value: postgresql

- name: DATA_DIR
  value: "/var/lib/postgresql"
</code></pre>
<h4 id="整数变量"><a class="header" href="#整数变量">整数变量</a></h4>
<pre><code class="language-yaml">vars:
- name: DATABASE_PORT
  type: integer
  min: 1024
  max: 65535
  value: 5432

- name: MAX_CONNECTIONS
  type: integer
  min: 1
  max: 1000
  value: 100
</code></pre>
<h4 id="布尔变量"><a class="header" href="#布尔变量">布尔变量</a></h4>
<pre><code class="language-yaml">vars:
- name: ENABLE_SSL
  type: boolean
  value: false

- name: ENABLE_DEBUG
  type: boolean
  value: true
</code></pre>
<h3 id="变量引用和模板"><a class="header" href="#变量引用和模板">变量引用和模板</a></h3>
<pre><code class="language-yaml"># 支持变量间引用
vars:
- name: INSTALL_PREFIX
  value: "/usr/local"

- name: MODULE_PATH
  value: "${INSTALL_PREFIX}/{{MODULE_NAME}}"

- name: CONFIG_FILE
  value: "${MODULE_PATH}/config.conf"
</code></pre>
<h3 id="环境变量支持-2"><a class="header" href="#环境变量支持-2">环境变量支持</a></h3>
<pre><code class="language-yaml"># 支持通过环境变量覆盖默认值
vars:
- name: DATABASE_PORT
  value: "${POSTGRES_PORT:5432}"    # 默认 5432，可被 POSTGRES_PORT 环境变量覆盖

- name: INSTALL_PREFIX
  value: "${PREFIX:/usr/local}"     # 默认 /usr/local，可被 PREFIX 环境变量覆盖

- name: DEBUG_MODE
  type: boolean
  value: "${DEBUG:false}"           # 默认 false，可被 DEBUG 环境变量覆盖
</code></pre>
<h2 id="settingyml---本地化设置"><a class="header" href="#settingyml---本地化设置">setting.yml - 本地化设置</a></h2>
<p><code>setting.yml</code> 配置模板渲染和本地化行为，定义哪些文件需要模板化以及模板标记格式。</p>
<h3 id="基本格式-3"><a class="header" href="#基本格式-3">基本格式</a></h3>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - LICENSE
    - "*.log"

  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h3 id="字段说明-3"><a class="header" href="#字段说明-3">字段说明</a></h3>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>类型</th><th>必需</th><th>说明</th></tr></thead><tbody>
<tr><td><code>templatize_path</code></td><td>Object</td><td>否</td><td>模板路径配置</td></tr>
<tr><td><code>templatize_cust</code></td><td>Object</td><td>否</td><td>自定义模板标记</td></tr>
<tr><td><code>excludes</code></td><td>Array</td><td>否</td><td>排除的文件列表</td></tr>
<tr><td><code>includes</code></td><td>Array</td><td>否</td><td>包含的文件列表（优先级高于 excludes）</td></tr>
<tr><td><code>label_beg</code></td><td>String</td><td>否</td><td>模板开始标记</td></tr>
<tr><td><code>label_end</code></td><td>String</td><td>否</td><td>模板结束标记</td></tr>
</tbody></table>
</div>
<h3 id="文件选择策略"><a class="header" href="#文件选择策略">文件选择策略</a></h3>
<h4 id="排除特定文件"><a class="header" href="#排除特定文件">排除特定文件</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    excludes:
    - README.md
    - CHANGELOG.md
    - "*.log"
    - "*.tmp"
</code></pre>
<h4 id="仅包含特定类型文件"><a class="header" href="#仅包含特定类型文件">仅包含特定类型文件</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    includes:
    - "*.conf"
    - "*.yml"
    - "*.yaml"
    - "templates/*"
</code></pre>
<h4 id="混合使用"><a class="header" href="#混合使用">混合使用</a></h4>
<pre><code class="language-yaml">localize:
  templatize_path:
    includes:
    - "*.conf"
    - "*.template"
    excludes:
    - "examples/*"
    - "test/*"
</code></pre>
<h3 id="模板标记配置"><a class="header" href="#模板标记配置">模板标记配置</a></h3>
<h4 id="默认标记jinja2-风格"><a class="header" href="#默认标记jinja2-风格">默认标记（Jinja2 风格）</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '{{'
    label_end: '}}'
</code></pre>
<h4 id="自定义标记"><a class="header" href="#自定义标记">自定义标记</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h4 id="多种标记支持"><a class="header" href="#多种标记支持">多种标记支持</a></h4>
<pre><code class="language-yaml">localize:
  templatize_cust:
    label_beg: '${'
    label_end: '}'
</code></pre>
<h3 id="本地化规则"><a class="header" href="#本地化规则">本地化规则</a></h3>
<pre><code class="language-yaml"># 为不同环境配置不同的本地化规则
localize:
  # 生产环境配置
  templatize_path:
    excludes:
    - "*.dev"
    - "*.test"

  templatize_cust:
    label_beg: '{{'
    label_end: '}}'

# 开发环境配置
localize:
  templatize_path:
    includes:
    - "*.dev"
    - "config.dev/*"

  templatize_cust:
    label_beg: '[['
    label_end: ']]'
</code></pre>
<h2 id="values_valueyml---默认值定义"><a class="header" href="#values_valueyml---默认值定义">values/_value.yml - 默认值定义</a></h2>
<p><code>_value.yml</code> 存储模块的默认配置值，为模块提供合理的默认行为。</p>
<h2 id="values_usedyml---使用的值定义"><a class="header" href="#values_usedyml---使用的值定义">values/_used.yml - 使用的值定义</a></h2>
<p><code>_used.yml</code> 记录实际使用的配置值及其来源，便于配置审计和问题排查。</p>
<h3 id="基本格式-4"><a class="header" href="#基本格式-4">基本格式</a></h3>
<pre><code class="language-yaml">SPEED_LIMIT:
  origin: mod-default
  value: 1000
  source_file: "values/_value.yml"

MODULE_NAME:
  origin: mod-default
  value: postgresql

PORT:
  origin: user-override
  value: 5433
  source_file: "user-config.yml"

MAX_CONNECTIONS:
  origin: env-override
  value: 200
  environment_var: "MAX_CONNECTIONS"
</code></pre>
<h3 id="值来源类型"><a class="header" href="#值来源类型">值来源类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>来源类型</th><th>说明</th><th>示例</th></tr></thead><tbody>
<tr><td><code>mod-default</code></td><td>模块默认值</td><td>来自 <code>values/_value.yml</code></td></tr>
<tr><td><code>user-override</code></td><td>用户覆盖值</td><td>来自用户配置文件</td></tr>
<tr><td><code>env-override</code></td><td>环境变量覆盖</td><td>来自环境变量</td></tr>
<tr><td><code>cmd-line</code></td><td>命令行参数</td><td>来自命令行选项</td></tr>
<tr><td><code>template-render</code></td><td>模板渲染结果</td><td>运行时计算值</td></tr>
</tbody></table>
</div>
<h2 id="工作流配置"><a class="header" href="#工作流配置">工作流配置</a></h2>
<h3 id="workflowsoperatorsgxl---工作流定义"><a class="header" href="#workflowsoperatorsgxl---工作流定义">workflows/operators.gxl - 工作流定义</a></h3>
<p><code>operators.gxl</code> 使用 GXL 语言定义模块的运维操作流程，包括安装、配置、启动、停止等任务。</p>
<h4 id="基本结构"><a class="header" href="#基本结构">基本结构</a></h4>
<pre><code class="language-gxl">// 引入外部模块
extern mod mod_ops {
    git = "https://github.com/galaxy-operators/ops-gxl.git",
    channel = "${GXL_CHANNEL_OPS:main}"
}

// 定义操作符模块
mod operators : empty_operators {
    // 自动加载入口
    #[auto_load(entry)]
    flow __into {
        // 加载配置文件
        gx.read_file(
            file : "./values/_used.json",
            name : "SETTING"
        );
    }

    // 任务定义...
}
</code></pre>
<pre><code>
#### 常见任务示例

##### 安装任务
```gxl
#[task(name="gops@install")]
flow install {
    };
}
</code></pre>
<h5 id="启动任务"><a class="header" href="#启动任务">启动任务</a></h5>
<pre><code class="language-gxl">#[task(name="gops@start")]
flow start {
}
</code></pre>
<h5 id="停止任务"><a class="header" href="#停止任务">停止任务</a></h5>
<pre><code class="language-gxl">#[task(name="gops@stop")]
flow stop {
}
</code></pre>
<h2 id="mod-prjyml---项目配置"><a class="header" href="#mod-prjyml---项目配置">mod-prj.yml - 项目配置</a></h2>
<p><code>mod-prj.yml</code> 定义模块的项目级别配置，包括模块信息、构建目标和发布配置。</p>
<h3 id="基本格式-5"><a class="header" href="#基本格式-5">基本格式</a></h3>
<pre><code class="language-yaml"># 模块项目配置
name: postgresql
version: 0.1.0
description: "PostgreSQL 数据库管理模块"
maintainer: "PostgreSQL Team &lt;team@example.com&gt;"
license: "Apache-2.0"

# 测试环境配置
test_envs:
  dep_root: "./test-deps"
  deps: []





## 总结

通过合理配置这些配置文件，可以实现：

1. **标准化管理**：统一的配置结构和命名规范
2. **灵活适配**：多平台和环境支持
3. **版本控制**：完整的版本管理和依赖追踪
4. **自动化**：工作流驱动的运维操作
5. **可维护性**：清晰的配置分层和验证机制

遵循本配置指南，可以开发出高质量、可维护、可扩展的 Mod-Operator 模块。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-api-和枚举参考"><a class="header" href="#mod-operator-api-和枚举参考">Mod-Operator API 和枚举参考</a></h1>
<p>本文档提供 Mod-Operator 的 API 接口、枚举定义和数据结构参考，是开发者进行二次开发和功能扩展的重要指南。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="operator/mod/REFERENCE.html#%E6%A8%A1%E5%9D%97-api">模块 API</a></li>
<li><a href="operator/mod/REFERENCE.html#%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89">枚举定义</a></li>
<li><a href="operator/mod/REFERENCE.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="operator/mod/REFERENCE.html#%E5%B7%A5%E4%BD%9C%E6%B5%81-api">工作流 API</a></li>
<li><a href="operator/mod/REFERENCE.html#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">配置文件格式</a></li>
<li><a href="operator/mod/REFERENCE.html#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81">错误代码</a></li>
<li><a href="operator/mod/REFERENCE.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li>
<li><a href="operator/mod/REFERENCE.html#api-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">API 使用示例</a></li>
</ul>
<h2 id="模块-api"><a class="header" href="#模块-api">模块 API</a></h2>
<h3 id="modulespec-接口"><a class="header" href="#modulespec-接口">ModuleSpec 接口</a></h3>
<p>模块的核心数据结构，定义了模块的基本信息和支持的目标平台。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Getters)]
pub struct ModuleSpec {
    /// 模块名称
    name: String,

    /// 目标平台配置映射
    targets: IndexMap&lt;ModelSTD, ModModelSpec&gt;,

    /// 本地化路径
    local: Option&lt;PathBuf&gt;,
}

impl ModuleSpec {
    /// 创建新模块
    pub fn init&lt;S: Into&lt;String&gt;&gt;(name: S, target_vec: Vec&lt;ModModelSpec&gt;) -&gt; Self

    /// 清理其他平台配置
    pub fn clean_other(&amp;mut self, node: &amp;ModelSTD) -&gt; MainResult&lt;()&gt;

    /// 保存主要配置
    pub fn save_main(&amp;self, path: &amp;Path, name: Option&lt;String&gt;) -&gt; MainResult&lt;()&gt;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="方法详解"><a class="header" href="#方法详解">方法详解</a></h4>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>参数</th><th>返回值</th><th>说明</th></tr></thead><tbody>
<tr><td><code>init</code></td><td><code>name: String</code>, <code>target_vec: Vec&lt;ModModelSpec&gt;</code></td><td><code>ModuleSpec</code></td><td>创建新的模块实例</td></tr>
<tr><td><code>clean_other</code></td><td><code>node: &amp;ModelSTD</code></td><td><code>MainResult&lt;()&gt;</code></td><td>清理指定平台外的其他平台配置</td></tr>
<tr><td><code>save_main</code></td><td><code>path: &amp;Path</code>, <code>name: Option&lt;String&gt;</code></td><td><code>MainResult&lt;()&gt;</code></td><td>保存模块主要配置文件</td></tr>
</tbody></table>
</div>
<h4 id="使用示例-1"><a class="header" href="#使用示例-1">使用示例</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 创建模块
let targets = vec![
    ModModelSpec::init(
        ModelSTD::x86_ubt22_k8s(),
        ArtifactPackage::default(),
        ModWorkflows::mod_k8s_tpl_init(),
        GxlProject::spec_k8s_tpl(),
        VarCollection::default(),
        None,
    ),
    ModModelSpec::init(
        ModelSTD::arm_mac14_host(),
        ArtifactPackage::default(),
        ModWorkflows::mod_host_tpl_init(),
        GxlProject::spec_host_tpl(),
        VarCollection::default(),
        None,
    ),
];

let module_spec = ModuleSpec::init("postgresql", targets);

// 清理其他平台
module_spec.clean_other(&amp;ModelSTD::x86_ubt22_k8s());
<span class="boring">}</span></code></pre></pre>
<h3 id="modmodelspec-接口"><a class="header" href="#modmodelspec-接口">ModModelSpec 接口</a></h3>
<p>模型规格定义，包含模块的具体实现配置。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Getters)]
pub struct ModModelSpec {
    /// 模型标准
    model: ModelSTD,

    /// 构件包定义
    artifact_pkg: ArtifactPackage,

    /// 工作流定义
    workflows: ModWorkflows,

    /// GXL 项目配置
    prj: GxlProject,

    /// 变量集合
    vars: VarCollection,

    /// 设置配置
    setting: Option&lt;Setting&gt;,
}

impl ModModelSpec {
    /// 创建新的模型规格
    pub fn init(
        model: ModelSTD,
        artifact_pkg: ArtifactPackage,
        workflows: ModWorkflows,
        prj: GxlProject,
        vars: VarCollection,
        setting: Option&lt;Setting&gt;,
    ) -&gt; Self

    /// 更新本地配置
    pub async fn update_local(
        &amp;self,
        accessor: Accessor,
        path: &amp;Path,
        options: &amp;DownloadOptions,
    ) -&gt; MainResult&lt;UpdateUnit&gt;

    /// 本地化处理
    pub async fn localize(
        &amp;self,
        dst_path: Option&lt;ValuePath&gt;,
        options: LocalizeOptions,
    ) -&gt; MainResult&lt;()&gt;

    /// 保存配置
    pub fn save_to(&amp;self, path: &amp;Path, name: Option&lt;String&gt;) -&gt; SerdeResult&lt;()&gt;

    /// 从文件加载
    pub fn load_from(path: &amp;Path) -&gt; SerdeResult&lt;Self&gt;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="主要方法"><a class="header" href="#主要方法">主要方法</a></h4>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td><code>init</code></td><td><code>model</code>, <code>artifact_pkg</code>, <code>workflows</code>, <code>prj</code>, <code>vars</code>, <code>setting</code></td><td>创建模型规格实例</td></tr>
<tr><td><code>update_local</code></td><td><code>accessor</code>, <code>path</code>, <code>options</code></td><td>更新本地构件配置</td></tr>
<tr><td><code>localize</code></td><td><code>dst_path</code>, <code>options</code></td><td>执行本地化处理</td></tr>
<tr><td><code>save_to</code></td><td><code>path</code>, <code>name</code></td><td>保存配置到文件</td></tr>
<tr><td><code>load_from</code></td><td><code>path</code></td><td>从文件加载配置</td></tr>
</tbody></table>
</div>
<h2 id="枚举定义"><a class="header" href="#枚举定义">枚举定义</a></h2>
<h3 id="modelstd-标准型号-1"><a class="header" href="#modelstd-标准型号-1">ModelSTD 标准型号</a></h3>
<p>模型标准定义，包含 CPU 架构、操作系统和运行环境。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// CPU 架构枚举
pub enum CpuArch {
    /// x86_64 架构
    X86,
    /// ARM 架构
    Arm,
}

/// 操作系统枚举
pub enum OsCPE {
    /// macOS 14+
    MAC14,
    /// Windows 10+
    WIN10,
    /// Ubuntu 22.04
    UBT22,
    /// CentOS 7
    COS7,
}

/// 运行环境枚举
pub enum RunSPC {
    /// 宿主机环境
    Host,
    /// Kubernetes 环境
    K8S,
}

/// 模型标准结构
#[derive(Debug, Clone, PartialEq, Eq, Hash, Getters)]
pub struct ModelSTD {
    /// CPU 架构
    arch: CpuArch,
    /// 操作系统
    os: OsCPE,
    /// 运行环境
    spc: RunSPC,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="常用预定义实例"><a class="header" href="#常用预定义实例">常用预定义实例</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 主流平台组合
impl ModelSTD {
    /// x86 + Ubuntu 22.04 + Kubernetes
    pub fn x86_ubt22_k8s() -&gt; Self

    /// x86 + Ubuntu 22.04 + Host
    pub fn x86_ubt22_host() -&gt; Self

    /// ARM + macOS 14 + Host
    pub fn arm_mac14_host() -&gt; Self

    /// ARM + Ubuntu 22.04 + Host
    pub fn arm_ubt22_host() -&gt; Self
}
<span class="boring">}</span></code></pre></pre>
<h3 id="artifact-枚举"><a class="header" href="#artifact-枚举">Artifact 枚举</a></h3>
<p>构件类型和状态枚举。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 构件类型
pub enum ArtifactType {
    /// HTTP/HTTPS 下载
    Http,
    /// Git 仓库
    Git,
    /// 本地文件
    Local,
    /// 容器镜像
    Container,
}

/// 构件状态
pub enum ArtifactStatus {
    /// 待下载
    Pending,
    /// 下载中
    Downloading,
    /// 已下载
    Downloaded,
    /// 解压中
    Extracting,
    /// 已解压
    Extracted,
    /// 已安装
    Installed,
    /// 错误
    Error,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="枚举比较和转换"><a class="header" href="#枚举比较和转换">枚举比较和转换</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 枚举比较
impl PartialEq for CpuArch {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        match (self, other) {
            (CpuArch::X86, CpuArch::X86) =&gt; true,
            (CpuArch::Arm, CpuArch::Arm) =&gt; true,
            _ =&gt; false,
        }
    }
}

// 枚举转字符串
impl ToString for CpuArch {
    fn to_string(&amp;self) -&gt; String {
        match self {
            CpuArch::X86 =&gt; "x86".to_string(),
            CpuArch::Arm =&gt; "arm".to_string(),
        }
    }
}

// 字符串转枚举
impl FromStr for CpuArch {
    type Err = ParseError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.to_lowercase().as_str() {
            "x86" | "x86_64" | "amd64" =&gt; Ok(CpuArch::X86),
            "arm" | "aarch64" =&gt; Ok(CpuArch::Arm),
            _ =&gt; Err(ParseError::InvalidCpuArch(s.to_string())),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h2>
<h3 id="artifactpackage-构件包"><a class="header" href="#artifactpackage-构件包">ArtifactPackage 构件包</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct ArtifactPackage {
    /// 构件列表
    artifacts: Vec&lt;Artifact&gt;,
}

impl ArtifactPackage {
    /// 创建默认构件包
    pub fn default() -&gt; Self

    /// 从构件列表创建
    pub fn from(artifacts: Vec&lt;Artifact&gt;) -&gt; Self

    /// 获取所有构件
    pub fn artifacts(&amp;self) -&gt; &amp;Vec&lt;Artifact&gt;

    /// 添加构件
    pub fn add_artifact(&amp;mut self, artifact: Artifact)

    /// 移除构件
    pub fn remove_artifact(&amp;mut self, name: &amp;str) -&gt; Option&lt;Artifact&gt;

    /// 查找构件
    pub fn find_artifact(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Artifact&gt;

    /// 验证构件包
    pub fn validate(&amp;self) -&gt; Result&lt;(), ValidationError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="varcollection-变量集合"><a class="header" href="#varcollection-变量集合">VarCollection 变量集合</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct VarCollection {
    /// 变量定义列表
    vars: Vec&lt;VarDefinition&gt;,
}

impl VarCollection {
    /// 定义变量
    pub fn define(vars: Vec&lt;VarDefinition&gt;) -&gt; Self

    /// 添加变量
    pub fn add_var(&amp;mut self, var: VarDefinition)

    /// 获取变量
    pub fn get_var(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;VarDefinition&gt;

    /// 设置变量值
    pub fn set_value(&amp;mut self, name: &amp;str, value: String) -&gt; Result&lt;(), VarError&gt;

    /// 解析变量值
    pub fn resolve_value(&amp;self, name: &amp;str, context: &amp;Context) -&gt; Result&lt;String, VarError&gt;

    /// 验证变量
    pub fn validate(&amp;self) -&gt; Result&lt;(), VarError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gxlproject-gxl-项目"><a class="header" href="#gxlproject-gxl-项目">GxlProject GXL 项目</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize, Getters)]
pub struct GxlProject {
    /// 项目名称
    name: String,

    /// 工作流定义
    workflows: HashMap&lt;String, GxlWorkflow&gt;,

    /// 项目配置
    config: HashMap&lt;String, Value&gt;,
}

impl GxlProject {
    /// 创建项目配置模板
    pub fn spec_k8s_tpl() -&gt; Self

    /// 创建主机配置模板
    pub fn spec_host_tpl() -&gt; Self

    /// 添加工作流
    pub fn add_workflow(&amp;mut self, name: String, workflow: GxlWorkflow)

    /// 获取工作流
    pub fn get_workflow(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;GxlWorkflow&gt;

    /// 执行工作流
    pub async fn execute_workflow(
        &amp;self,
        name: &amp;str,
        context: &amp;Context,
    ) -&gt; Result&lt;WorkflowResult, WorkflowError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="工作流-api"><a class="header" href="#工作流-api">工作流 API</a></h2>
<h3 id="gxlworkflow-gxl-工作流"><a class="header" href="#gxlworkflow-gxl-工作流">GxlWorkflow GXL 工作流</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GxlWorkflow {
    /// 工作流名称
    name: String,

    /// 工作流描述
    description: Option&lt;String&gt;,

    /// 任务列表
    tasks: Vec&lt;GxlTask&gt;,

    /// 变量定义
    variables: HashMap&lt;String, GxlVariable&gt;,

    /// 条件分支
    conditions: Vec&lt;GxlCondition&gt;,

    /// 错误处理
    error_handler: Option&lt;GxlErrorHandler&gt;,
}

impl GxlWorkflow {
    /// 创建工作流
    pub fn new(name: String) -&gt; Self

    /// 添加任务
    pub fn add_task(&amp;mut self, task: GxlTask)

    /// 添加条件分支
    pub fn add_condition(&amp;mut self, condition: GxlCondition)

    /// 设置错误处理器
    pub fn set_error_handler(&amp;mut self, handler: GxlErrorHandler)

    /// 验证工作流
    pub fn validate(&amp;self) -&gt; Result&lt;(), WorkflowError&gt;

    /// 执行工作流
    pub async fn execute(&amp;self, context: &amp;mut Context) -&gt; Result&lt;WorkflowResult, WorkflowError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gxltask-gxl-任务"><a class="header" href="#gxltask-gxl-任务">GxlTask GXL 任务</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GxlTask {
    /// 命令任务
    Command(GxlCommandTask),

    /// 脚本任务
    Script(GxlScriptTask),

    /// 模板渲染任务
    Template(GxlTemplateTask),

    /// 下载任务
    Download(GxlDownloadTask),

    /// 并行任务
    Parallel(GxlParallelTask),

    /// 条件任务
    Conditional(GxlConditionalTask),

    /// 循环任务
    Loop(GxlLoopTask),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="任务执行上下文"><a class="header" href="#任务执行上下文">任务执行上下文</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct Context {
    /// 变量存储
    variables: HashMap&lt;String, Value&gt;,

    /// 工作目录
    working_dir: PathBuf,

    /// 执行状态
    status: ExecutionStatus,

    /// 错误收集
    errors: Vec&lt;ExecutionError&gt;,

    /// 日志输出
    logs: Vec&lt;LogEntry&gt;,
}

impl Context {
    /// 创建新上下文
    pub fn new() -&gt; Self

    /// 设置变量
    pub fn set_var(&amp;mut self, name: String, value: Value)

    /// 获取变量
    pub fn get_var(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Value&gt;

    /// 执行命令
    pub async fn execute_command(&amp;mut self, cmd: &amp;str) -&gt; Result&lt;CommandResult, CommandError&gt;

    /// 添加日志
    pub fn add_log(&amp;mut self, level: LogLevel, message: String)

    /// 保存状态
    pub fn save_state(&amp;self) -&gt; Result&lt;StateSnapshot, StateError&gt;

    /// 恢复状态
    pub fn restore_state(&amp;mut self, state: &amp;StateSnapshot) -&gt; Result&lt;(), StateError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="配置文件格式"><a class="header" href="#配置文件格式">配置文件格式</a></h2>
<h3 id="yaml-配置验证"><a class="header" href="#yaml-配置验证">YAML 配置验证</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 配置验证器
pub struct ConfigValidator;

impl ConfigValidator {
    /// 验证 artifact.yml
    pub fn validate_artifact(yaml_content: &amp;str) -&gt; Result&lt;Vec&lt;Artifact&gt;, ConfigError&gt;

    /// 验证 depends.yml
    pub fn validate_depends(yaml_content: &amp;str) -&gt; Result&lt;DependsConfig, ConfigError&gt;

    /// 验证 vars.yml
    pub fn validate_vars(yaml_content: &amp;str) -&gt; Result&lt;VarCollection, ConfigError&gt;

    /// 验证 setting.yml
    pub fn validate_setting(yaml_content: &amp;str) -&gt; Result&lt;Setting, ConfigError&gt;

    /// 验证 mod-prj.yml
    pub fn validate_project(yaml_content: &amp;str) -&gt; Result&lt;ProjectConfig, ConfigError&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="配置生成器"><a class="header" href="#配置生成器">配置生成器</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 配置文件生成器
pub struct ConfigGenerator;

impl ConfigGenerator {
    /// 生成 artifact.yml
    pub fn generate_artifact(artifacts: &amp;[Artifact]) -&gt; String

    /// 生成 depends.yml
    pub fn generate_depends(deps: &amp;[Dependency]) -&gt; String

    /// 生成 vars.yml
    pub fn generate_vars(vars: &amp;[VarDefinition]) -&gt; String

    /// 生成 setting.yml
    pub fn generate_setting(setting: &amp;Setting) -&gt; String

    /// 生成 mod-prj.yml
    pub fn generate_project(project: &amp;ProjectConfig) -&gt; String
}
<span class="boring">}</span></code></pre></pre>
<h2 id="错误代码"><a class="header" href="#错误代码">错误代码</a></h2>
<h3 id="错误类型定义"><a class="header" href="#错误类型定义">错误类型定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 系统错误
#[derive(Debug, Error)]
pub enum SystemError {
    #[error("配置解析错误: {0}")]
    ConfigParse(String),

    #[error("文件操作错误: {0}")]
    FileOperation(String),

    #[error("网络错误: {0}")]
    Network(String),

    #[error("进程错误: {0}")]
    Process(String),

    #[error("权限错误: {0}")]
    Permission(String),

    #[error("资源不足: {0}")]
    Resource(String),
}

/// 业务错误
#[derive(Debug, Error)]
pub enum BusinessError {
    #[error("模块不存在: {0}")]
    ModuleNotFound(String),

    #[error("任务执行失败: {0}")]
    TaskFailed(String),

    #[error("验证失败: {0}")]
    ValidationFailed(String),

    #[error("状态错误: {0}")]
    InvalidState(String),

    #[error("依赖冲突: {0}")]
    DependencyConflict(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="错误处理模式"><a class="header" href="#错误处理模式">错误处理模式</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 错误处理结果
pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;

/// 错误处理工具
pub struct ErrorHandler;

impl ErrorHandler {
    /// 记录错误
    pub fn log_error(error: &amp;Error) {
        // 记录错误日志
    }

    /// 错误恢复
    pub fn recover(context: &amp;mut Context, error: &amp;Error) -&gt; Result&lt;()&gt; {
        // 执行错误恢复操作
        Ok(())
    }

    /// 错误通知
    pub fn notify(error: &amp;Error) -&gt; Result&lt;()&gt; {
        // 发送错误通知
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="环境变量-5"><a class="header" href="#环境变量-5">环境变量</a></h2>
<h2 id="api-使用示例"><a class="header" href="#api-使用示例">API 使用示例</a></h2>
<h3 id="创建自定义模块"><a class="header" href="#创建自定义模块">创建自定义模块</a></h3>
<pre><pre class="playground"><code class="language-rust">use galaxy_ops::{
    artifact::{Artifact, ArtifactPackage},
    model::{ModelSTD, CpuArch, OsCPE, RunSPC},
    module::ModuleSpec,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 定义目标平台
    let target_platforms = vec![
        ModelSTD::x86_ubt22_k8s(),
        ModelSTD::arm_mac14_host(),
    ];

    // 创建构件包
    let artifacts = vec![
        Artifact::new(
            "nginx",
            "1.25.3",
            "https://nginx.org/download/nginx-1.25.3.tar.gz".parse()?,
            "nginx-1.25.3.tar.gz",
        ),
        Artifact::new(
            "openssl",
            "3.0.0",
            "https://github.com/openssl/openssl.git".parse()?,
            "openssl-3.0.0",
        ),
    ];

    let artifact_pkg = ArtifactPackage::from(artifacts);

    // 为每个平台创建模型规格
    let mut target_specs = Vec::new();
    for platform in target_platforms {
        let model_spec = ModModelSpec::init(
            platform.clone(),
            artifact_pkg.clone(),
            ModWorkflows::mod_k8s_tpl_init(),
            GxlProject::spec_k8s_tpl(),
            VarCollection::define(vec![
                VarDefinition::new("MODULE_NAME", "nginx"),
                VarDefinition::new("VERSION", "1.25.3"),
            ]),
            None,
        );

        target_specs.push(model_spec);
    }

    // 创建模块规格
    let module_spec = ModuleSpec::init("nginx-server", target_specs);

    // 保存模块配置
    module_spec.save_main(&amp;std::path::Path::new("./nginx"), Some("nginx".to_string()))?;

    println!("自定义模块创建成功");
    Ok(())
}</code></pre></pre>
<h3 id="错误处理示例"><a class="header" href="#错误处理示例">错误处理示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use galaxy_ops::{error::{SystemError, BusinessError}, workflow::Context};

fn handle_error(context: &amp;mut Context, error: &amp;dyn std::error::Error) {
    match error.downcast_ref::&lt;SystemError&gt;() {
        Some(sys_error) =&gt; {
            match sys_error {
                SystemError::ConfigParse(msg) =&gt; {
                    eprintln!("配置解析错误: {}", msg);
                    // 执行配置错误恢复
                    ConfigErrorHandler::recover(context, msg);
                }
                SystemError::FileOperation(msg) =&gt; {
                    eprintln!("文件操作错误: {}", msg);
                    // 执行文件错误恢复
                    FileErrorHandler::recover(context, msg);
                }
                SystemError::Network(msg) =&gt; {
                    eprintln!("网络错误: {}", msg);
                    // 执行网络错误恢复
                    NetworkErrorHandler::recover(context, msg);
                }
                _ =&gt; {
                    eprintln!("未知系统错误: {}", msg);
                }
            }
        }
        None =&gt; {
            match error.downcast_ref::&lt;BusinessError&gt;() {
                Some(biz_error) =&gt; {
                    match biz_error {
                        BusinessError::ModuleNotFound(msg) =&gt; {
                            eprintln!("模块不存在: {}", msg);
                            ModuleErrorHandler::recover(context, msg);
                        }
                        BusinessError::TaskFailed(msg) =&gt; {
                            eprintln!("任务执行失败: {}", msg);
                            TaskErrorHandler::recover(context, msg);
                        }
                        BusinessError::ValidationFailed(msg) =&gt; {
                            eprintln!("验证失败: {}", msg);
                            ValidationErrorHandler::recover(context, msg);
                        }
                        _ =&gt; {
                            eprintln!("未知业务错误: {}", msg);
                        }
                    }
                }
                None =&gt; {
                    eprintln!("未分类错误: {}", error);
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>本 API 参考文档提供了 Mod-Operator 框架的完整接口和功能说明，包括：</p>
<ol>
<li><strong>模块管理 API</strong> - 用于创建和管理模块实例</li>
<li><strong>枚举定义</strong> - 标准化的平台和类型定义</li>
<li><strong>数据结构</strong> - 核心配置和数据类型</li>
<li><strong>工作流 API</strong> - 任务执行和流程控制</li>
<li><strong>配置处理</strong> - 配置文件的验证和生成</li>
<li><strong>错误处理</strong> - 完善的错误处理机制</li>
<li><strong>环境变量</strong> - 系统和用户配置变量</li>
<li><strong>实用示例</strong> - 常见场景的实现示例</li>
</ol>
<p>通过这些 API，开发者可以：</p>
<ul>
<li>创建自定义模块类型</li>
<li>扩展工作流功能</li>
<li>自定义配置验证</li>
<li>实现高级监控功能</li>
<li>集成第三方系统</li>
</ul>
<p>建议开发者在使用前仔细阅读相关章节，并根据实际需求选择合适的 API 接口。</p>
<h2 id="相关资源-1"><a class="header" href="#相关资源-1">相关资源</a></h2>
<ul>
<li>📖 <a href="operator/mod/./CONFIGURATION.html">配置说明</a> - 完整的配置文件参考</li>
<li>📖 <a href="operator/mod/./DEVELOPMENT.html">开发指南</a> - 开发工作流和最佳实践</li>
<li>📖 <a href="operator/mod/./TROUBLESHOOTING.html">故障排除</a> - 调试和问题解决</li>
<li>🛠️ <a href="operator/mod/../gmod/">gmod 工具文档</a> - 模块管理工具使用指南</li>
<li>🛠️ <a href="operator/mod/../gflow/">gflow 工具文档</a> - 工作流执行工具使用指南</li>
</ul>
<hr />
<p><em>本文档会根据框架发展持续更新，请关注最新版本。如需帮助，请参考示例代码或提交 Issue。</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mod-operator-故障排除指南"><a class="header" href="#mod-operator-故障排除指南">Mod-Operator 故障排除指南</a></h1>
<p>本文档提供 Mod-Operator 常见问题的诊断步骤、解决方案和调试技巧，帮助开发者快速定位和解决问题。</p>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<ul>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD">常见问题诊断</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%92%8C%E6%96%B9%E6%B3%95">调试工具和方法</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">错误代码解析</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90">性能问题分析</a></li>
<li><a href="operator/mod/TROUBLESHOOTING.html#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE">最佳实践建议</a></li>
</ul>
<h2 id="常见问题诊断-1"><a class="header" href="#常见问题诊断-1">常见问题诊断</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-netaccessctrl-简约配置指南非开发者版"><a class="header" href="#-netaccessctrl-简约配置指南非开发者版">📖 NetAccessCtrl 简约配置指南（非开发者版）</a></h1>
<h2 id="什么是-netaccessctrl"><a class="header" href="#什么是-netaccessctrl">什么是 NetAccessCtrl？</a></h2>
<p>NetAccessCtrl 是一个网络访问控制模块，可以在使用orino_variate 时自动将您的网络请求重定向到更快的镜像服务器，支持认证、超时设置和代理配置。它可以帮助您：</p>
<ul>
<li>🚀 加速 GitHub、GitLab 等国外服务访问</li>
<li>🔐 安全管理认证信息</li>
<li>⏱️ 控制网络请求超时时间</li>
<li>🌐 配置代理服务器</li>
<li>📝 使用环境变量动态配置</li>
</ul>
<h2 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h2>
<h3 id="1-创建配置文件"><a class="header" href="#1-创建配置文件">1. 创建配置文件</a></h3>
<p>在您的项目根目录创建 <code>net-accessor_ctrl.yaml</code> 文件：</p>
<pre><code class="language-yaml"># 基础配置示例
enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror.ghproxy.com/"
    # 可选：添加认证信息
    auth:
      username: "your_username"
      password: "your_token"
</code></pre>
<h3 id="2-常用场景配置"><a class="header" href="#2-常用场景配置">2. 常用场景配置</a></h3>
<h4 id="github-加速访问"><a class="header" href="#github-加速访问">GitHub 加速访问</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror.ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
</code></pre>
<h4 id="gitlab-镜像"><a class="header" href="#gitlab-镜像">GitLab 镜像</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://gitlab.com/*"
        target: "https://gitlab-mirror.com/"
</code></pre>
<h4 id="npm-包管理器加速"><a class="header" href="#npm-包管理器加速">NPM 包管理器加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://registry.npmjs.org/*"
        target: "https://registry.npmmirror.com/"
</code></pre>
<h3 id="3-完整配置示例"><a class="header" href="#3-完整配置示例">3. 完整配置示例</a></h3>
<pre><code class="language-yaml">enable: true
units:
  # GitHub 配置
  - rules:
      - pattern: "https://github.com/*"
        target: "https://ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
    auth:
      username: "${GITHUB_USER}"
      password: "${GITHUB_TOKEN}"
    timeout:
      connect-timeout: 30
      read-timeout: 60
      total-timeout: 300
    proxy:
      url: "http://proxy.company.com:8080"

  # 其他服务配置
  - rules:
      - pattern: "https://api.example.com/*"
        target: "https://internal-api.example.com/"
</code></pre>
<h2 id="配置参数说明"><a class="header" href="#配置参数说明">配置参数说明</a></h2>
<h3 id="基本参数"><a class="header" href="#基本参数">基本参数</a></h3>
<ul>
<li><code>enable</code>: <code>true</code> 或 <code>false</code>，是否启用网络访问控制</li>
<li><code>units</code>: 配置单元列表，每个单元包含重定向规则和配置</li>
</ul>
<h3 id="单元配置-units"><a class="header" href="#单元配置-units">单元配置 (units)</a></h3>
<p>每个 <code>unit</code> 包含：</p>
<ul>
<li><code>rules</code>: 重定向规则列表</li>
<li><code>auth</code>: 可选的认证信息（用户名和密码）</li>
<li><code>timeout</code>: 可选的超时设置</li>
<li><code>proxy</code>: 可选的代理配置</li>
</ul>
<h3 id="规则配置-rules"><a class="header" href="#规则配置-rules">规则配置 (rules)</a></h3>
<p>每个 <code>rule</code> 包含：</p>
<ul>
<li><code>pattern</code>: 要匹配的URL模式（支持 <code>*</code> 通配符）</li>
<li><code>target</code>: 重定向的目标地址</li>
</ul>
<h3 id="环境变量支持-3"><a class="header" href="#环境变量支持-3">环境变量支持</a></h3>
<p>您可以使用环境变量来动态配置，避免硬编码敏感信息：</p>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://${GITHUB_DOMAIN:github.com}/*"
        target: "https://${MIRROR_DOMAIN:ghproxy.com}/"
    auth:
      username: "${GITHUB_USER}"
      password: "${GITHUB_TOKEN}"
    proxy:
      url: "${PROXY_URL:http://proxy.default:8080}"
</code></pre>
<p>环境变量语法：</p>
<ul>
<li><code>${VARIABLE_NAME}</code>: 使用环境变量</li>
<li><code>${VARIABLE_NAME:default_value}</code>: 使用环境变量，如果不存在则使用默认值</li>
</ul>
<h2 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h2>
<h3 id="1-设置环境变量可选"><a class="header" href="#1-设置环境变量可选">1. 设置环境变量（可选）</a></h3>
<pre><code class="language-bash"># Linux/Mac
export GITHUB_USER="your_username"
export GITHUB_TOKEN="your_token"
export PROXY_URL="http://proxy.company.com:8080"

# Windows
set GITHUB_USER=your_username
set GITHUB_TOKEN=your_token
set PROXY_URL=http://proxy.company.com:8080
</code></pre>
<h3 id="2-将配置文件放在正确位置"><a class="header" href="#2-将配置文件放在正确位置">2. 将配置文件放在正确位置</a></h3>
<ul>
<li>系统级配置：<code>/etc/net-access.yaml</code></li>
<li>用户级配置：<code>~/.config/net-access.yaml</code></li>
<li>项目级配置：<code>项目根目录/net-access.yaml</code></li>
</ul>
<h3 id="3-验证配置"><a class="header" href="#3-验证配置">3. 验证配置</a></h3>
<p>配置完成后，您可以通过以下方式验证是否生效：</p>
<pre><code class="language-bash"># 测试 GitHub 访问
curl -I "https://github.com/user/repo/releases"

# 查看是否重定向到镜像服务器
</code></pre>
<h2 id="常见问题-5"><a class="header" href="#常见问题-5">常见问题</a></h2>
<h3 id="q-如何添加多个镜像服务器"><a class="header" href="#q-如何添加多个镜像服务器">Q: 如何添加多个镜像服务器？</a></h3>
<p>A: 在 <code>units</code> 中添加多个配置单元，系统会按顺序尝试：</p>
<pre><code class="language-yaml">enable: true
units:
  # 第一个镜像
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror1.github.com/"

  # 备用镜像
  - rules:
      - pattern: "https://github.com/*"
        target: "https://mirror2.github.com/"
</code></pre>
<h3 id="q-如何设置不同的超时时间"><a class="header" href="#q-如何设置不同的超时时间">Q: 如何设置不同的超时时间？</a></h3>
<p>A: 在 <code>timeout</code> 部分配置：</p>
<pre><code class="language-yaml">timeout:
  connect-timeout: 30    # 连接超时（秒）
  read-timeout: 60       # 读取超时（秒）
  total-timeout: 300     # 总超时（秒）
</code></pre>
<h3 id="q-如何处理认证"><a class="header" href="#q-如何处理认证">Q: 如何处理认证？</a></h3>
<p>A: 在 <code>auth</code> 部分配置用户名和密码，推荐使用环境变量：</p>
<pre><code class="language-yaml">auth:
  username: "${YOUR_USERNAME}"
  password: "${YOUR_PASSWORD}"
</code></pre>
<h3 id="q-配置不生效怎么办"><a class="header" href="#q-配置不生效怎么办">Q: 配置不生效怎么办？</a></h3>
<p>A: 检查以下几点：</p>
<ol>
<li>确保 <code>enable: true</code></li>
<li>检查配置文件路径是否正确</li>
<li>验证 YAML 语法是否正确</li>
<li>检查 URL 模式是否匹配</li>
</ol>
<h3 id="q-如何配置代理"><a class="header" href="#q-如何配置代理">Q: 如何配置代理？</a></h3>
<p>A: 在 <code>proxy</code> 部分配置：</p>
<pre><code class="language-yaml">proxy:
  url: "http://proxy.example.com:8080"
</code></pre>
<h3 id="q-支持哪些通配符"><a class="header" href="#q-支持哪些通配符">Q: 支持哪些通配符？</a></h3>
<p>A: 目前支持 <code>*</code> 通配符，可以匹配任意字符序列。例如：</p>
<ul>
<li><code>https://github.com/*</code> 匹配所有 GitHub 地址</li>
<li><code>https://raw.githubusercontent.com/*</code> 匹配所有 GitHub 原始文件地址</li>
</ul>
<h2 id="配置示例合集"><a class="header" href="#配置示例合集">配置示例合集</a></h2>
<h3 id="常用镜像服务"><a class="header" href="#常用镜像服务">常用镜像服务</a></h3>
<h4 id="github-全家桶加速"><a class="header" href="#github-全家桶加速">GitHub 全家桶加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://github.com/*"
        target: "https://ghproxy.com/"
      - pattern: "https://raw.githubusercontent.com/*"
        target: "https://raw.ghproxy.com/"
      - pattern: "https://gist.github.com/*"
        target: "https://gist.ghproxy.com/"
</code></pre>
<h4 id="python-包管理器-pypi"><a class="header" href="#python-包管理器-pypi">Python 包管理器 (PyPI)</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://pypi.org/*"
        target: "https://pypi.doubanio.com/"
</code></pre>
<h4 id="docker-镜像加速"><a class="header" href="#docker-镜像加速">Docker 镜像加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://registry-1.docker.io/*"
        target: "https://dockerhub.azk8s.cn/"
</code></pre>
<h4 id="rubygems-加速"><a class="header" href="#rubygems-加速">RubyGems 加速</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://rubygems.org/*"
        target: "https://gems.ruby-china.com/"
</code></pre>
<h3 id="企业内部配置"><a class="header" href="#企业内部配置">企业内部配置</a></h3>
<h4 id="内部服务映射"><a class="header" href="#内部服务映射">内部服务映射</a></h4>
<pre><code class="language-yaml">enable: true
units:
  - rules:
      - pattern: "https://external-api.company.com/*"
        target: "https://internal-api.company.com/"
    auth:
      username: "${INTERNAL_API_USER}"
      password: "${INTERNAL_API_PASSWORD}"
    timeout:
      connect-timeout: 10
      read-timeout: 30
      total-timeout: 60
</code></pre>
<h4 id="多环境配置"><a class="header" href="#多环境配置">多环境配置</a></h4>
<pre><code class="language-yaml"># 开发环境配置
enable: ${ENABLE_NET_ACCESS:true}
units:
  - rules:
      - pattern: "https://api.${ENV:dev}.company.com/*"
        target: "http://localhost:8080/"
    timeout:
      connect-timeout: 5
      read-timeout: 15
      total-timeout: 30
</code></pre>
<h2 id="故障排除-3"><a class="header" href="#故障排除-3">故障排除</a></h2>
<h3 id="检查配置文件语法"><a class="header" href="#检查配置文件语法">检查配置文件语法</a></h3>
<p>使用在线 YAML 验证工具检查配置文件语法：</p>
<ol>
<li>访问 https://www.yamllint.com/</li>
<li>粘贴您的配置文件内容</li>
<li>检查是否有语法错误</li>
</ol>
<h3 id="常见错误及解决方案"><a class="header" href="#常见错误及解决方案">常见错误及解决方案</a></h3>
<h4 id="1-配置文件不生效"><a class="header" href="#1-配置文件不生效">1. 配置文件不生效</a></h4>
<p><strong>症状</strong>: 配置修改后没有效果
<strong>解决方案</strong>:</p>
<ul>
<li>检查配置文件路径是否正确</li>
<li>确认 <code>enable: true</code></li>
<li>重启应用程序</li>
<li>检查文件权限</li>
</ul>
<h4 id="2-环境变量未生效"><a class="header" href="#2-环境变量未生效">2. 环境变量未生效</a></h4>
<p><strong>症状</strong>: 环境变量没有正确替换
<strong>解决方案</strong>:</p>
<ul>
<li>确认环境变量已正确设置</li>
<li>检查环境变量名称是否正确</li>
<li>使用 <code>echo $VARIABLE_NAME</code> 验证环境变量</li>
<li>重新启动终端或应用程序</li>
</ul>
<h4 id="3-网络连接超时"><a class="header" href="#3-网络连接超时">3. 网络连接超时</a></h4>
<p><strong>症状</strong>: 请求经常超时
<strong>解决方案</strong>:</p>
<ul>
<li>增加 <code>timeout</code> 配置中的时间值</li>
<li>检查网络连接状态</li>
<li>尝试更换镜像服务器</li>
</ul>
<h4 id="4-认证失败"><a class="header" href="#4-认证失败">4. 认证失败</a></h4>
<p><strong>症状</strong>: 401 或 403 错误
<strong>解决方案</strong>:</p>
<ul>
<li>检查用户名和密码是否正确</li>
<li>确认认证信息是否有权限访问目标服务</li>
<li>检查 token 是否已过期</li>
</ul>
<h3 id="调试技巧-2"><a class="header" href="#调试技巧-2">调试技巧</a></h3>
<h4 id="启用详细日志"><a class="header" href="#启用详细日志">启用详细日志</a></h4>
<p>如果应用程序支持日志，可以启用详细日志来查看重定向过程：</p>
<pre><code class="language-bash"># 示例：启用调试日志
export RUST_LOG=debug
your_application
</code></pre>
<h4 id="手动测试重定向"><a class="header" href="#手动测试重定向">手动测试重定向</a></h4>
<p>使用 <code>curl</code> 命令手动测试重定向是否工作：</p>
<pre><code class="language-bash"># 测试重定向
curl -v "https://github.com/user/repo"

# 查看是否被重定向到镜像服务器
</code></pre>
<h4 id="检查配置加载"><a class="header" href="#检查配置加载">检查配置加载</a></h4>
<p>如果可能，查看应用程序启动时的日志，确认配置文件是否正确加载。</p>
<h2 id="最佳实践-6"><a class="header" href="#最佳实践-6">最佳实践</a></h2>
<h3 id="安全性建议"><a class="header" href="#安全性建议">安全性建议</a></h3>
<ol>
<li><strong>使用环境变量</strong>: 避免在配置文件中硬编码敏感信息</li>
<li><strong>设置文件权限</strong>: 确保配置文件只有授权用户可读
<pre><code class="language-bash">chmod 600 net-access.yaml
</code></pre>
</li>
<li><strong>定期更新认证信息</strong>: 定期更换密码和访问令牌</li>
<li><strong>使用 HTTPS</strong>: 确保所有目标地址使用 HTTPS 协议</li>
</ol>
<h3 id="性能优化建议"><a class="header" href="#性能优化建议">性能优化建议</a></h3>
<ol>
<li><strong>规则排序</strong>: 将最常用的规则放在前面</li>
<li><strong>合理设置超时</strong>: 根据网络环境调整超时时间</li>
<li><strong>使用就近镜像</strong>: 选择地理位置较近的镜像服务器</li>
<li><strong>避免过度重定向</strong>: 不要配置过多的重定向层级</li>
</ol>
<h3 id="维护建议"><a class="header" href="#维护建议">维护建议</a></h3>
<ol>
<li><strong>版本控制</strong>: 将配置文件纳入版本控制（排除敏感信息）</li>
<li><strong>文档记录</strong>: 记录配置文件的用途和变更历史</li>
<li><strong>定期测试</strong>: 定期测试配置是否仍然有效</li>
<li><strong>备份配置</strong>: 保留配置文件的备份</li>
</ol>
<h2 id="获取帮助"><a class="header" href="#获取帮助">获取帮助</a></h2>
<p>如果遇到问题，可以通过以下方式获取帮助：</p>
<h3 id="检查清单"><a class="header" href="#检查清单">检查清单</a></h3>
<p>在寻求帮助前，请先检查：</p>
<ul>
<li><input disabled="" type="checkbox"/>
配置文件语法是否正确</li>
<li><input disabled="" type="checkbox"/>
环境变量是否正确设置</li>
<li><input disabled="" type="checkbox"/>
网络连接是否正常</li>
<li><input disabled="" type="checkbox"/>
认证信息是否有效</li>
<li><input disabled="" type="checkbox"/>
目标服务器是否可访问</li>
</ul>
<h3 id="常见资源"><a class="header" href="#常见资源">常见资源</a></h3>
<ul>
<li><strong>YAML 语法验证</strong>: https://www.yamllint.com/</li>
<li><strong>环境变量设置指南</strong>: 搜索 "环境变量设置 [您的操作系统]"</li>
<li><strong>网络连接测试</strong>: 使用 <code>ping</code> 和 <code>curl</code> 命令测试</li>
<li><strong>镜像服务状态</strong>: 查看镜像服务的官方状态页面</li>
</ul>
<h3 id="联系支持"><a class="header" href="#联系支持">联系支持</a></h3>
<p>如果以上方法都无法解决问题，请联系技术支持并提供以下信息：</p>
<ol>
<li>操作系统和版本</li>
<li>配置文件内容（去除敏感信息）</li>
<li>错误信息或日志</li>
<li>重现问题的步骤</li>
</ol>
<hr />
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="配置文件模板"><a class="header" href="#配置文件模板">配置文件模板</a></h3>
<h4 id="基础模板"><a class="header" href="#基础模板">基础模板</a></h4>
<pre><code class="language-yaml"># NetAccessCtrl 基础配置模板
enable: true
units:
  - rules:
      - pattern: "https://example.com/*"
        target: "https://mirror.example.com/"
</code></pre>
<h4 id="完整模板"><a class="header" href="#完整模板">完整模板</a></h4>
<pre><code class="language-yaml"># NetAccessCtrl 完整配置模板
enable: true
units:
  - rules:
      - pattern: "https://service1.com/*"
        target: "https://mirror1.service1.com/"
      - pattern: "https://service2.com/*"
        target: "https://mirror2.service2.com/"
    auth:
      username: "${SERVICE1_USER}"
      password: "${SERVICE1_PASSWORD}"
    timeout:
      connect-timeout: 30
      read-timeout: 60
      total-timeout: 300
    proxy:
      url: "${PROXY_URL:http://proxy.default:8080}"

  - rules:
      - pattern: "https://another-service.com/*"
        target: "https://internal.another-service.com/"
    # 此单元无认证、超时和代理配置
</code></pre>
<h3 id="常用镜像服务器列表"><a class="header" href="#常用镜像服务器列表">常用镜像服务器列表</a></h3>
<div class="table-wrapper"><table><thead><tr><th>服务类型</th><th>原地址</th><th>推荐镜像地址</th></tr></thead><tbody>
<tr><td>GitHub</td><td><code>https://github.com/*</code></td><td><code>https://ghproxy.com/</code></td></tr>
<tr><td>GitHub Raw</td><td><code>https://raw.githubusercontent.com/*</code></td><td><code>https://raw.ghproxy.com/</code></td></tr>
<tr><td>PyPI</td><td><code>https://pypi.org/*</code></td><td><code>https://pypi.doubanio.com/</code></td></tr>
<tr><td>NPM</td><td><code>https://registry.npmjs.org/*</code></td><td><code>https://registry.npmmirror.com/</code></td></tr>
<tr><td>Docker Hub</td><td><code>https://registry-1.docker.io/*</code></td><td><code>https://dockerhub.azk8s.cn/</code></td></tr>
<tr><td>RubyGems</td><td><code>https://rubygems.org/*</code></td><td><code>https://gems.ruby-china.com/</code></td></tr>
</tbody></table>
</div>
<p><em>注意：镜像服务地址可能会发生变化，请以最新信息为准。</em></p>
<hr />
<p><strong>快速开始总结</strong>：</p>
<ol>
<li>创建 <code>net-access.yaml</code> 文件</li>
<li>复制相应场景的配置示例</li>
<li>设置环境变量（可选）</li>
<li>放置配置文件到正确位置</li>
<li>验证配置是否生效</li>
</ol>
<p>祝您使用愉快！🎉</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl---语法"><a class="header" href="#gxl---语法">GXL   语法</a></h1>
<h2 id="结构"><a class="header" href="#结构">结构</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
 env dev {
 }
}

mod main {
    flow conf {
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>mod   模块</li>
<li>env   环境</li>
<li>flow  处理流</li>
</ul>
<h2 id="flow"><a class="header" href="#flow">flow</a></h2>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<h4 id="简单使用"><a class="header" href="#简单使用">简单使用</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>flow test {
  gx.echo (  "hello world" );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="增加描述"><a class="header" href="#增加描述">增加描述</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[usage(desp="test flow")]
flow test() {
  gx.echo (  "hello world" );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="编排"><a class="header" href="#编排">编排</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>flow head {
  gx.echo ( "head"; )
}
flow tail {
  gx.echo ( "tail"; )
}

// 执行过程为: test -&gt; head -&gt; tail
flow  @test | head | tail  { }
flow  test | head | tail  { }


// 执行过程为: head -&gt; tail -&gt; test
flow  | head | tail  |@test { }

//执行过程为: head -&gt; test -&gt; tail
flow  head | @test | tail {
  gx.echo ( "test"; )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  flow [ &lt;flows&gt;|]  @&lt;flow_name&gt;  [|&lt;flows&gt;] {
  }
<span class="boring">}</span></code></pre></pre>
<h3 id="分支"><a class="header" href="#分支">分支</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {
  api = "1.0"
  flow conf {
    if  ${API} == "1.0" {
        gx.echo ( value : "this is if true cond " );
    }
    else {
        gx.echo ( value : "this is if false cond" );
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="通配比较"><a class="header" href="#通配比较">通配比较</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {
  api = "1.0"
  flow conf {
    if  ${API} =* "1*" {
        gx.echo ( value : "this is if true cond " );
    }
    else {
        gx.echo ( value : "this is if false cond" );
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="env"><a class="header" href="#env">env</a></h2>
<p>环境设定集合</p>
<h3 id="示例-4"><a class="header" href="#示例-4">示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env dev {
    root = "./" ;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[useage(desp="开发环境")]
env dev {
    root = "./" ;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="mix-env"><a class="header" href="#mix-env">mix env</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env base {}
env dev  : base {
    root = "./" ;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>默认env: default  , 可以省去 gflow -e 参数 ;</li>
</ul>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env &lt;name&gt; [: &lt;mix-envs&gt;] {
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>name  :</li>
<li>mix-envs : 可继承的env</li>
</ul>
<h2 id="mod"><a class="header" href="#mod">mod</a></h2>
<p>mod 是顶级的组织结构</p>
<p>只有 envs,main 两个mod 中的 env 和 flow  cli 直接load</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
  prop1 = "prop1"
  env dev {}
}
mod main {
  prop1 = "prop1"
  flow test {}
}
<span class="boring">}</span></code></pre></pre>
<p>执行</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gflow -e dev test 
<span class="boring">}</span></code></pre></pre>
<h3 id="mod-注解"><a class="header" href="#mod-注解">mod 注解</a></h3>
<h3 id="mod继承"><a class="header" href="#mod继承">mod继承</a></h3>
<h3 id="示例-5"><a class="header" href="#示例-5">示例</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<h1 id="activity"><a class="header" href="#activity">Activity</a></h1>
<ul>
<li>包装shell  成为 activity</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> activity copy {
     src = "" ;
     dst = "" ;
     log = "1" ;
     out = "true"
     executer = "copy_act.sh" ;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量定义"><a class="header" href="#变量定义">变量定义</a></h1>
<h2 id="示例-6"><a class="header" href="#示例-6">示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    one= "one";
    sys_a = { mod1 : "A", mod2 : "B" , mod3: 1 , mod4 : 2};
    sys_b =  [ "C", "D" ];
    sys_c = ${SYS_B[1]} ;
    sys_d = ${SYS_A.MOD1} ;
<span class="boring">}</span></code></pre></pre>
<h2 id="规则"><a class="header" href="#规则">规则</a></h2>
<p>在GXL内 变量名不区分大小写</p>
<h2 id="使用示例-2"><a class="header" href="#使用示例-2">使用示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
    env default   {
      data_list =  [ "JAVA", "RUST", "PYTHON"] ;
      data_obj =  { 
        JAVA : { NAME: "JAVA", SCORE: 80 }, 
        RUST : { NAME: "RUST", SCORE: 100 }, 
        PYTHON : { NAME: "PYTHON", SCORE: 200} 
        } ;
    }
}
mod main   {
  flow array_do{
    for ${CUR} in ${ENV_DATA_LIST} {
      gx.echo( "CUR:${CUR}" );
    }
  }
  flow obj_do{
    for ${CUR} in ${ENV_DATA_OBJ} {
      gx.echo( "CUR:${CUR.NAME} : ${CUR.SCORE}" );
    }
  }

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="内置常量"><a class="header" href="#内置常量">内置常量</a></h2>
<ul>
<li>GXL_PRJ_ROOT:   最近定义了 _gal/project.toml 的目录</li>
<li>GXL_START_ROOT:  GXL 启动处理的目录</li>
<li>GXL_CUR_DIR:  GXL 当前所在目录，在调用gx.run时，与GXL_START_ROOT可能不同</li>
<li>GXL_CMD_ARG:  gflow -- &lt;cmd_arg&gt;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="flow-1"><a class="header" href="#flow-1">flow</a></h1>
<h2 id="注解"><a class="header" href="#注解">注解</a></h2>
<h3 id="task---v060"><a class="header" href="#task---v060">task   (v0.6.0)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(name="setup")]
flow setup{
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dryrun--v070"><a class="header" href="#dryrun--v070">dryrun  (v0.7.0)</a></h3>
<pre><code>#[dryrun(_pub_dryrun)]
flow _pub_dysec {
    ...
}
flow _pub_dryrun {
    ...
}
</code></pre>
<h3 id="transcation-undo-v070"><a class="header" href="#transcation-undo-v070">transcation undo (v0.7.0)</a></h3>
<pre><code>flow trans1 | step1 | step2 | step3 ;
  #[transaction,undo(_undo_step1)]
  flow step1 {
    gx.echo (" step1 ");
  }
  #[undo(_undo_step2)]
  flow step2 {
    gx.echo (" step2 ");
  }
  #[undo(_undo_step3)]
  flow step3 {
    gx.echo (" step3 ");
    gx.assert ( value : "true" , expect : "false" );
  }

  flow _undo_step1 {
    gx.echo (" undo step1 ");
  }
  flow _undo_step2 {
    gx.echo (" undo step2 ");
  }
  flow _undo_step3 {
    gx.echo (" undo step3 ");
  }
</code></pre>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[usage(desp="test")]
flow test_1 {

}
<span class="boring">}</span></code></pre></pre>
<h3 id="auto_load"><a class="header" href="#auto_load">auto_load</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[auto_load(entry,exit)] 

//entry: 进入flow 
//exit : 退出flow
示例:

mod main {

  flow start {
    gx.echo ( value : "hello" );
  }
  #[auto_load(entry)]
  flow conf {
    gx.echo ( value : "hello" );
  }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="defined"><a class="header" href="#defined">defined</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    if defined(${PRJ_ROOT}) {
        gx.echo (  "${PRJ_ROOT}/test/main.py"  );
        }
        else {
        gx.echo (  "${PRJ_ROOT}/test/main.py"  );
    }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxl-文件语法"><a class="header" href="#gxl-文件语法">GXL 文件语法</a></h1>
<h2 id="gxl-语法定义"><a class="header" href="#gxl-语法定义">GXL 语法定义</a></h2>
<p>GXL（Galaxy Flow Language）是一种为 DevSecOps 自动化工作流设计的领域特定语言。根据代码库中的信息，GXL 的语法定义主要在 galaxy-sec/galaxy-flow 仓库的解析器模块中实现。</p>
<h3 id="gxl-语法结构"><a class="header" href="#gxl-语法结构">GXL 语法结构</a></h3>
<p>GXL 语言遵循模块化、层次化的结构，主要由以下核心组件组成：</p>
<ul>
<li>模块（Modules）：使用 mod 关键字定义，是 GXL 的顶层组织单元</li>
<li>环境（Environments）：使用 env 关键字定义，用于配置不同的执行上下文</li>
<li>流程（Flows）：使用 flow 关键字定义，表示工作流程序</li>
<li>活动（Activities）：可重用的操作单元，在流程中调用</li>
</ul>
<h2 id="ebnf-语法"><a class="header" href="#ebnf-语法">EBNF 语法</a></h2>
<pre><code class="language-EBNF">
; GXL 文件由一系列模块定义组成
GXL-File = *Module


(* GXL 文件由一系列模块定义组成 *)
GXL-File = {Module};

(* 模块定义 *)
Module = "mod", whitespace, ModuleName, whitespace, "{", whitespace, ModuleContent, whitespace, "}", whitespace, ";";
ModuleName = Identifier;
ModuleContent = {Property | Environment | Flow};

(* 属性定义 (键值对) *)
Property = PropertyName, whitespace, "=", whitespace, PropertyValue, whitespace, ";";
PropertyName = Identifier;
PropertyValue = String;

(* 环境定义 *)
Environment = "env", whitespace, EnvName, [whitespace, ":", whitespace, EnvRefList], whitespace, "{", whitespace, EnvContent, whitespace, "}";
EnvName = Identifier;
EnvContent = {Property};
EnvRefList = EnvRef, {",", whitespace, EnvRef};
EnvRef = Identifier;

(* 流程定义 - 两种形式：直接定义或引用其他流程 *)
Flow = DirectFlow | ReferenceFlow;

(* 直接定义流程 *)
DirectFlow = "flow", whitespace, FlowName, [whitespace, ":", whitespace, FlowRefList [ whitespace , ":" whitespace, FlowRefList ] ], whitespace, "{", whitespace, FlowContent, whitespace, "}", whitespace, ";";
FlowName = Identifier;
FlowContent = {Command};

(* 引用其他流程 *)
ReferenceFlow = "flow", whitespace, FlowName, whitespace, ":", whitespace, FlowRefList, whitespace, ";";
FlowRefList = FlowRef, {",", whitespace, FlowRef};
FlowRef = Identifier;


(* 命令定义 *)
Command = (BuiltinCommand | ActivityCall), whitespace, ";";

(* 内置命令 *)
BuiltinCommand = "gx.", CommandName, whitespace, "{", whitespace, CommandProps, whitespace, "}";
CommandName = "echo" | "vars" | "cmd" | "read" | "tpl" | "assert" | "ver";
CommandProps = {PropertyAssignment};
PropertyAssignment = PropertyName, whitespace, "=", whitespace, PropertyValue, whitespace,  ",";

(* 活动调用 *)
ActivityCall = ActivityName, whitespace, "{", whitespace, CommandProps, whitespace, "}";
ActivityName = Identifier, {".", Identifier};

(* 标识符 *)
Identifier = Alpha, {Alpha | Digit | "_"};
Alpha = "A" | "B" | ... | "Z" | "a" | "b" | ... | "z";
Digit = "0" | "1" | ... | "9";

(* 字符串 *)
String = '"', {StringChar}, '"';
StringChar = UnescapedChar | EscapedChar;
UnescapedChar = ? 除了 " 和 \ 的任何字符 ?;
EscapedChar = "\", ("\" | '"');

(* 变量引用 *)
VariableRef = "${", VariableName, "}";
VariableName = Identifier;

(* 空白字符 *)
whitespace = {" " | "\t" | "\r" | "\n"};

(* 外部模块引用 *)
ExternModule = "extern", whitespace, "mod", whitespace, ModuleNameList, whitespace, "{", whitespace, ModuleSource, whitespace, "}", whitespace, ";";
ModuleNameList = ModuleName, {",", whitespace, ModuleName};
ModuleSource = PathSource | GitSource;
PathSource = "path", whitespace, "=", whitespace, String;
GitSource = "git", whitespace, "=", whitespace, String, whitespace, ",", whitespace, "channel", whitespace, "=", whitespace, String;


(* 注解 *)
Annotation = "#[", AnnotationName, ("(", AnnotationParams, ")")?, "]";
AnnotationName = Identifier;
AnnotationParams = AnnotationParam, {",", whitespace, AnnotationParam};
AnnotationParam = Identifier, whitespace, "=", whitespace, String;
</code></pre>
<h2 id="示例-7"><a class="header" href="#示例-7">示例</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env dev {
	root = "${HOME}/my_project";
	gx.read_cmd {
		name = "MY_PATH" ;
		cmd  = "pwd" ;
	};
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod my_module {
    -- 模块属性
    author = "John Doe";
    version = "1.0";

    -- 环境定义
    env test {
        root = "${HOME}/test_project";
        gx.read_cmd {
            name = "TEST_PATH";
            cmd = "ls";
        };
    }

    -- 流程定义
    flow my_flow {
        step1 = "execute_task";
        task1.run {
            param1 = "value1";
            param2 = "value2";
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示例-8"><a class="header" href="#示例-8">示例</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert-示例"><a class="header" href="#assert-示例">Assert 示例</a></h1>
<h2 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path= "../../_gal/mods"; }
mod base_env {
    env _common {
      gx.vars {
        DOMAIN    = "domain" ;
      }
    }
    env cli : _common {
      ROOT   = "./";

    }
    env unit_test : _common {
      ROOT   = "./example";
    }
}
mod envs : base_env {
    #[usage(desp="default")]
    env default : cli ;
    env empty {}
    env ut : unit_test  ;
}
mod base{
  mod_val = "1";
  flow define {
    base = "BASE";
  }
  #[auto_load(entry)]
  flow base_into  {
    base_begin = "BASE_INTO";
  }
  #[auto_load(exit)]
  flow base_exit {
    base_end = "BASE_EXIT";
  }
}
mod other {
  flow def1 {
    other_val = "OTHER_DEF";
  }
  flow def2{
    other_val = "OTHER_DEF2";
  }
}
mod main   {
  conf = "${ENV_ROOT}/conf" ;

  #[auto_load(entry)]
  flow __into  | other.def1  {
    other_val = "OTHER_DE1";
  }
  #[auto_load(exit)]
  flow __exit | other.def2 ;
  #[usage(desp="main")]
  flow assert_main {
    one= "one";
    sys_a = { mod1 : "A", mod2 : "B" };
    sys_b =  [ "C", "D" ];
    sys_c = ${SYS_B[1]} ;
    sys_d = ${SYS_A.MOD1} ;
    gx.assert ( value : "${MAIN_CONF}" , expect : "${ENV_ROOT}/conf" );
    gx.assert ( value : "${OTHER_VAL}" , expect : "OTHER_DEF" );
    gx.assert ( value : "${SYS_A.MOD1}" , expect : "A" );
    gx.assert ( value : "${sys_a.mod1}" , expect : "A" );
    gx.assert ( value : "${sys_b[0]}" , expect : "C" );
    gx.assert ( value : "${sys_d}" , expect : "A" );
  }

  flow base.define | @assert_parent   {
    gx.assert ( value : "${MAIN_CONF}" , expect : "${ENV_ROOT}/conf" );
    gx.assert ( value : "${BASE_MOD_VAL}" , expect : "1" );
    gx.assert ( value : "${OTHER_VAL}" , expect : "OTHER_DEF" );
    gx.assert ( value : "${BASE}" , expect : "BASE" );
    gx.assert ( value : "${BASE_BEGIN}" , expect : "BASE_INTO" );
  }

}
<span class="boring">}</span></code></pre></pre>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.assert</code> 命令进行断言检查。在 <code>assert_main</code> 流程中，多个 <code>gx.assert</code> 命令用于验证变量的值是否符合预期。在 <code>base.define</code> 流程中，也使用了 <code>gx.assert</code> 来验证环境变量和模块变量的值。</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load base_env]
    B --&gt; C[Load envs]
    C --&gt; D[Load base module]
    D --&gt; E[Load other module]
    E --&gt; F[Load main module]
    F --&gt; G[Execute __into flow]
    G --&gt; H[Execute assert_main flow]
    H --&gt; I[Execute gx.assert commands]
    I --&gt; J[Execute base.define flow]
    J --&gt; K[Execute more gx.assert commands]
    K --&gt; L[Execute __exit flow]
    L --&gt; M[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dryrun-example"><a class="header" href="#dryrun-example">Dryrun Example</a></h1>
<p>This example demonstrates the dryrun functionality in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod main {

env default {}

flow _step1 {
    gx.echo ("step1");
}

#[dryrun(_step3)]
flow _step2 {
    gx.echo ("step2");
    gx.assert ( value : "true" , expect : "false" );
}

flow _step3 {
    gx.echo ("dryrun setp2");
}

flow start | _step1 | _step2 ;

}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load main module]
    B --&gt; C[Execute start flow]
    C --&gt; D[Execute _step1 flow]
    D --&gt; E[Execute _step2 flow]
    E --&gt; F{Assertion fails?}
    F --&gt;|Yes| G[Execute _step3 flow]
    F --&gt;|No| H[End]
    G --&gt; I[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fun-example"><a class="header" href="#fun-example">Fun Example</a></h1>
<p>This example demonstrates how to define and use functions in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod sys {
    fun echo(name) {
        gx.echo("echo:${name}");
    }
    fun echo_obj(obj) {
        gx.echo("echo_obj:${obj}");
    }
    fun echo_list(list) {
        gx.echo("echo_list:${list}");
    }
}

mod envs {
    env default {
        DATA = [
            "JAVA",
            "RUST",
            "PYTHON",
        ];
        OBJ = {
            name: "test",
            value: "value",
        };
    }
}

mod main {
    flow conf {
        sys.echo("test");
        sys.echo_obj("${OBJ}");
        sys.echo_list("${DATA}");
    }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load sys module]
    B --&gt; C[Define echo functions]
    C --&gt; D[Load envs module]
    D --&gt; E[Load main module]
    E --&gt; F[Execute conf flow]
    F --&gt; G[Call sys.echo function]
    G --&gt; H[Call sys.echo_obj function]
    H --&gt; I[Call sys.echo_list function]
    I --&gt; J[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-示例"><a class="header" href="#read-示例">Read 示例</a></h1>
<h2 id="示例代码-1"><a class="header" href="#示例代码-1">示例代码</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path= "../../_gal/mods"; }
mod envs {
    env _dev_local {
        gx.read_file ( file : "./var.ini" );
    }
    env default : _dev_local ;
}
mod main   {
  flow conf  {
    gx.echo (  "${RUST}" );
    gx.echo (  "${JAVA}" );
    gx.assert ( value : "${JAVA}" , expect : "90"  );

    gx.read_cmd (
        //fail!
        //cmd  : r#"git branch --show-current |  sed -E "s/(feature|develop|ver-dev|release|master|issue)(\/\.*)?/_branch_\1/g" "# ,
        //suc!
        cmd  : "git branch --show-current | sed -E 's/release/rls/g'" ,
        name : "GIT_BRANCH" );

    gx.echo ( "what:${GIT_BRANCH}" );

    gx.read_file ( file : "./var2.ini" , name : "DATA");

    for ${CUR} in ${DATA} {
        gx.echo ( value : "${CUR}" );
    }
  }



}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Execute _dev_local env]
    C --&gt; D[Execute gx.read_file command]
    D --&gt; E[Load main module]
    E --&gt; F[Execute conf flow]
    F --&gt; G[Execute gx.echo commands]
    G --&gt; H[Execute gx.read_cmd command]
    H --&gt; I[Execute gx.echo command]
    I --&gt; J[Execute gx.read_file command]
    J --&gt; K[Loop through DATA]
    K --&gt; L[Execute gx.echo command for each item]
    L --&gt; M[End]
</pre>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.read</code> 命令从不同来源读取数据。在 <code>_dev_local</code> 环境中，使用 <code>gx.read_file</code> 从 <code>var.ini</code> 文件读取数据。在 <code>conf</code> 流程中，使用 <code>gx.read_cmd</code> 执行 Git 命令并捕获输出，以及使用 <code>gx.read_file</code> 从 <code>var2.ini</code> 文件读取数据。还展示了如何遍历读取的数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-example"><a class="header" href="#shell-example">Shell Example</a></h1>
<p>This example demonstrates how to execute shell commands in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod envs {
    env _dev_local {}
    env default : _dev_local;
}

mod main {
    flow conf {
        gx.read_file(file: "./var.yml", name: "VAR");
        gx.echo("what:${VAR.MEMBER.JAVA}");

        gx.shell(
            arg_file: "./var.json",
            shell: "./demo.sh",
            out_var: "SYS_OUT");

        gx.echo("what:${SYS_OUT}");

        gx.read_file(file: "./var_list.yml", name: "DATA");
        for ${CUR} in ${DATA.DEV_LANG} {
            gx.shell(
                shell: "./demo_ex.sh ${CUR}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }

        gx.read_file(file: "./var_obj.yml", name: "DATA");
        for ${CUR} in ${DATA} {
            gx.shell(
                shell: "./demo_ex.sh ${CUR.SYS.NAME}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }
    }
    flow do_obj {
        gx.read_file(file: "./var_obj.yml", name: "DATA");
        for ${CUR} in ${DATA} {
            //gx.echo( "CUR:${CUR.SYS.NAME}" );
            gx.shell(
                shell: "./demo_ex.sh ${CUR.SYS.NAME}",
                out_var: "SYS_OUT");
            gx.echo("what:${SYS_OUT}");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="说明-2"><a class="header" href="#说明-2">说明</a></h2>
<p>这个示例展示了如何使用 <code>gx.shell</code> 命令执行 shell 脚本。在 <code>conf</code> 流程中，首先从 <code>var.yml</code> 文件读取数据，然后使用 <code>gx.shell</code> 执行 <code>demo.sh</code> 脚本，并通过 <code>arg_file</code> 参数传递 <code>var.json</code> 文件。还展示了如何在循环中执行 shell 脚本，并处理列表和对象数据。</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Load main module]
    C --&gt; D[Execute conf flow]
    D --&gt; E[Execute gx.read_file command]
    E --&gt; F[Execute gx.echo command]
    F --&gt; G[Execute gx.shell command]
    G --&gt; H[Execute gx.echo command]
    H --&gt; I[Execute gx.read_file command]
    I --&gt; J[Loop through DATA.DEV_LANG]
    J --&gt; K[Execute gx.shell command for each item]
    K --&gt; L[Execute gx.echo command]
    L --&gt; M[Execute gx.read_file command]
    M --&gt; N[Loop through DATA]
    N --&gt; O[Execute gx.shell command for each item]
    O --&gt; P[Execute gx.echo command]
    P --&gt; Q[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-example"><a class="header" href="#template-example">Template Example</a></h1>
<p>This example demonstrates how to use templates in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod os { path = "../../_gal/mods"; }

mod base_env {
    env _common {
        gx.vars {
            DOMAIN = "domain";
            SOCK_FILE = "socket";
            GXL_PRJ_ROOT = "./";
        }
    }
    env cli : _common {
        ROOT = "./";
    }
    env unit_test : _common {
        ROOT = "./example";
    }
}

mod envs : base_env {
    #[usage(desp = "default")]
    env default : cli;
    env empty {}
    env ut : unit_test;
}

mod main {
    conf = "${ENV_ROOT}/conf";
    flow conf {
        os.path(dst: "${MAIN_CONF}/used", keep: "true");
        gx.tpl(
            tpl: "${MAIN_CONF}/tpls/",
            dst: "${MAIN_CONF}/used/",
            file: "${MAIN_CONF}/value.json");

        ```cmd
        echo "hello";
        cp ./conf/value.json ./conf/used/back.json;
        ```
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>This example shows how to use the <code>gx.tpl</code> command to process template files. In the <code>conf</code> flow, the <code>os.path</code> command is first used to create the target directory, then the <code>gx.tpl</code> command renders template files from the <code>tpls</code> directory based on values in the <code>value.json</code> file and outputs them to the <code>used</code> directory. Finally, an inline shell command block is shown to copy a file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-example"><a class="header" href="#transaction-example">Transaction Example</a></h1>
<p>This example demonstrates how to use transactions in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern mod base { path = "./_gal/"; }

mod envs {
    env default {};
}

mod main {
    flow trans1 | step1 | step2 | base.base_step1 | step3;
    flow trans2 | step1 | step3 | step2;

    #[transaction, undo(_undo_step1)]
    flow step1 {
        gx.echo(" step1 ");
    }
    #[undo(_undo_step2)]
    flow step2 {
        gx.echo(" step2 ");
    }
    #[undo(_undo_step3)]
    flow step3 {
        gx.echo(" step3 ");
        gx.assert(value: "true", expect: "false");
    }

    flow _undo_step1 {
        gx.echo(" undo step1 ");
    }
    flow _undo_step2 {
        gx.echo(" undo step2 ");
    }
    flow _undo_step3 {
        gx.echo(" undo step3 ");
    }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load base module]
    B --&gt; C[Load envs module]
    C --&gt; D[Load main module]
    D --&gt; E[Define flows]
    E --&gt; F[Execute trans1 flow]
    F --&gt; G[Execute step1 flow]
    G --&gt; H[Execute step2 flow]
    H --&gt; I[Execute base.base_step1 flow]
    I --&gt; J[Execute step3 flow]
    J --&gt; K[Execute trans2 flow]
    K --&gt; L[Execute step1 flow]
    L --&gt; M[Execute step3 flow]
    M --&gt; N[Execute step2 flow]
    N --&gt; O[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vars-example"><a class="header" href="#vars-example">Vars Example</a></h1>
<p>This example demonstrates how to define and use variables in GXL.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod envs {
    env default {
        data_list = [
            "JAVA",
            "RUST",
            "PYTHON",
        ];
        data_obj = {
            JAVA: { NAME: "JAVA", SCORE: 80 },
            RUST: { NAME: "RUST", SCORE: 100 },
            PYTHON: { NAME: "PYTHON", SCORE: 200 },
        };
    }
}

mod main {
    flow array_do {
        for ${CUR} in ${ENV.DATA_LIST} {
            gx.echo("CUR:${CUR}");
        }
    }
    flow obj_do {
        for ${CUR} in ${ENV.DATA_OBJ} {
            gx.echo("CUR:${CUR.NAME} : ${CUR.SCORE}");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>This example shows how to define variables in an environment and how to use these variables in flows. In the <code>default</code> environment, a list <code>data_list</code> and an object <code>data_obj</code> are defined. In the <code>array_do</code> flow, the <code>data_list</code> list is iterated over and each element is output. In the <code>obj_do</code> flow, the <code>data_obj</code> object is iterated over and the properties of each object are output.</p>
<pre class="mermaid">graph TD
    A[Start] --&gt; B[Load envs module]
    B --&gt; C[Define data_list and data_obj variables]
    C --&gt; D[Load main module]
    D --&gt; E[Execute array_do flow]
    E --&gt; F[Loop through ENV.DATA_LIST]
    F --&gt; G[Execute gx.echo command for each item]
    G --&gt; H[Execute obj_do flow]
    H --&gt; I[Loop through ENV.DATA_OBJ]
    I --&gt; J[Execute gx.echo command for each item]
    J --&gt; K[End]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="galaxy-flow-内置能力文档"><a class="header" href="#galaxy-flow-内置能力文档">Galaxy Flow 内置能力文档</a></h1>
<p>本文档详细描述了Galaxy Flow中所有内置能力的语法定义和使用示例。</p>
<h2 id="gxassert"><a class="header" href="#gxassert">gx.assert</a></h2>
<h3 id="功能描述"><a class="header" href="#功能描述">功能描述</a></h3>
<p>执行断言检查，验证表达式的值是否符合预期。</p>
<h3 id="语法定义"><a class="header" href="#语法定义">语法定义</a></h3>
<pre><code class="language-gxl">gx.assert {
  value: &lt;表达式&gt;,      // 要检查的值
  expect: &lt;期望值&gt;,     // 期望的值
  err: &lt;错误信息&gt;,      // 断言失败时的错误信息（可选）
  result: &lt;变量名&gt;      // 存储断言结果的变量名（可选）
}
</code></pre>
<h3 id="示例代码-2"><a class="header" href="#示例代码-2">示例代码</a></h3>
<pre><code class="language-gxl">// 检查变量值是否等于期望值
gx.assert {
  value: ${MY_VAR},
  expect: "expected_value",
  err: "MY_VAR值不正确"
}

// 检查表达式结果并存储结果
gx.assert {
  value: ${CALC_RESULT},
  expect: 42,
  result: "assert_result"
}
</code></pre>
<h2 id="gxcmd"><a class="header" href="#gxcmd">gx.cmd</a></h2>
<h3 id="功能描述-1"><a class="header" href="#功能描述-1">功能描述</a></h3>
<p>执行系统命令或脚本。</p>
<h3 id="语法定义-1"><a class="header" href="#语法定义-1">语法定义</a></h3>
<pre><code class="language-gxl">gx.cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  shell: &lt;Shell类型&gt;,    // 指定使用的Shell（可选）
  out: &lt;输出变量名&gt;,     // 捕获命令标准输出的变量名（可选）
  err: &lt;错误变量名&gt;,     // 捕获命令错误输出的变量名（可选）
  suc: &lt;成功标识&gt;,       // 命令执行成功的标识（可选）
  sudo: &lt;布尔值&gt;,        // 是否使用sudo权限执行（可选）
  log: &lt;日志级别&gt;,       // 日志记录级别（可选）
  silence: &lt;布尔值&gt;      // 是否静默执行（可选）
}
</code></pre>
<h3 id="示例代码-3"><a class="header" href="#示例代码-3">示例代码</a></h3>
<pre><code class="language-gxl">// 执行简单命令
gx.cmd {
  cmd: "ls -la"
}

// 执行命令并捕获输出
gx.cmd {
  cmd: "date",
  out: "current_date"
}

// 使用sudo权限执行命令
gx.cmd {
  cmd: "systemctl restart nginx",
  sudo: true
}
</code></pre>
<h2 id="gxecho"><a class="header" href="#gxecho">gx.echo</a></h2>
<h3 id="功能描述-2"><a class="header" href="#功能描述-2">功能描述</a></h3>
<p>输出文本信息到控制台。</p>
<h3 id="语法定义-2"><a class="header" href="#语法定义-2">语法定义</a></h3>
<pre><code class="language-gxl">gx.echo {
  value: &lt;文本内容&gt;,     // 要输出的文本内容
  file: &lt;文件路径&gt;,      // 输出到文件的路径（可选）
  export: &lt;变量名&gt;,      // 导出为环境变量的名称（可选）
  inc: &lt;布尔值&gt;          // 是否追加到文件末尾（可选）
}
</code></pre>
<h3 id="示例代码-4"><a class="header" href="#示例代码-4">示例代码</a></h3>
<pre><code class="language-gxl">// 输出简单文本
gx.echo {
  value: "Hello, Galaxy Flow!"
}

// 输出到文件
gx.echo {
  value: "This is a log entry",
  file: "app.log"
}

// 追加到文件
gx.echo {
  value: "Additional information",
  file: "app.log",
  inc: true
}

// 导出为环境变量
gx.echo {
  value: "production",
  export: "ENV_TYPE"
}
</code></pre>
<h2 id="gxread"><a class="header" href="#gxread">gx.read</a></h2>
<h3 id="功能描述-3"><a class="header" href="#功能描述-3">功能描述</a></h3>
<p>从不同来源读取数据并存储到变量中。</p>
<h3 id="语法定义-3"><a class="header" href="#语法定义-3">语法定义</a></h3>
<pre><code class="language-gxl">// 从文件读取
gx.read_file {
  file: &lt;文件路径&gt;,      // 要读取的文件路径
  name: &lt;变量名&gt;         // 存储文件内容的变量名
}

// 从标准输入读取
gx.read_stdin {
  name: &lt;变量名&gt;,        // 存储输入内容的变量名
  prompt: &lt;提示文本&gt;     // 输入提示文本（可选）
}

// 从命令输出读取
gx.read_cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  name: &lt;变量名&gt;,        // 存储命令输出的变量名
  shell: &lt;Shell类型&gt;     // 指定使用的Shell（可选）
}
</code></pre>
<h3 id="示例代码-5"><a class="header" href="#示例代码-5">示例代码</a></h3>
<pre><code class="language-gxl">// 从文件读取内容
gx.read_file {
  file: "config.json",
  name: "config_data"
}

// 从标准输入读取
gx.read_stdin {
  name: "user_input",
  prompt: "请输入您的姓名: "
}

// 从命令输出读取
gx.read_cmd {
  cmd: "git rev-parse HEAD",
  name: "commit_hash"
}
</code></pre>
<h2 id="gxvars"><a class="header" href="#gxvars">gx.vars</a></h2>
<h3 id="功能描述-4"><a class="header" href="#功能描述-4">功能描述</a></h3>
<p>定义和设置多个变量。</p>
<h3 id="语法定义-4"><a class="header" href="#语法定义-4">语法定义</a></h3>
<pre><code class="language-gxl">gx.vars {
  &lt;变量名1&gt;: &lt;值1&gt;,      // 变量名和对应的值
  &lt;变量名2&gt;: &lt;值2&gt;,      // 可以定义多个变量
  // ...
}
</code></pre>
<h3 id="示例代码-6"><a class="header" href="#示例代码-6">示例代码</a></h3>
<pre><code class="language-gxl">// 定义多个变量
gx.vars {
  app_name: "MyApp",
  version: "1.0.0",
  debug: true
}

// 使用变量引用
gx.vars {
  project_root: "${HOME}/projects",
  config_file: "${project_root}/config.yaml"
}
</code></pre>
<h2 id="gxtpl"><a class="header" href="#gxtpl">gx.tpl</a></h2>
<h3 id="功能描述-5"><a class="header" href="#功能描述-5">功能描述</a></h3>
<p>使用模板引擎处理文件模板。</p>
<h3 id="语法定义-5"><a class="header" href="#语法定义-5">语法定义</a></h3>
<pre><code class="language-gxl">gx.tpl {
  tpl: &lt;模板内容&gt;,       // 模板内容
  dst: &lt;目标文件路径&gt;,   // 生成文件的路径
  data: &lt;数据变量名&gt;,    // 模板数据变量名（可选）
  engine: &lt;引擎类型&gt;,    // 模板引擎类型（可选）
  file: &lt;模板文件路径&gt;   // 模板文件路径（可选，与tpl互斥）
}
</code></pre>
<h3 id="示例代码-7"><a class="header" href="#示例代码-7">示例代码</a></h3>
<pre><code class="language-gxl">// 使用内联模板
gx.tpl {
  tpl: "Hello, {{name}}! Welcome to {{app_name}}.",
  dst: "output.txt",
  data: "user_data"
}

// 使用模板文件
gx.tpl {
  file: "template.txt",
  dst: "output.txt",
  data: "template_data"
}
</code></pre>
<h2 id="gxver"><a class="header" href="#gxver">gx.ver</a></h2>
<h3 id="功能描述-6"><a class="header" href="#功能描述-6">功能描述</a></h3>
<p>管理和操作版本信息。</p>
<h3 id="语法定义-6"><a class="header" href="#语法定义-6">语法定义</a></h3>
<pre><code class="language-gxl">gx.ver {
  value: &lt;版本值&gt;,       // 版本值
  default: &lt;默认值&gt;,     // 默认版本值（可选）
  file: &lt;文件路径&gt;,      // 版本文件路径（可选）
  export: &lt;变量名&gt;,      // 导出版本信息的变量名（可选）
  inc: &lt;递增类型&gt;        // 版本递增类型（可选，可选值：build/bugfix/feature/main）
}
</code></pre>
<h3 id="示例代码-8"><a class="header" href="#示例代码-8">示例代码</a></h3>
<pre><code class="language-gxl">// 设置版本值
gx.ver {
  value: "1.2.3"
}

// 从文件读取版本并递增
gx.ver {
  file: "VERSION",
  inc: "feature"
}

// 导出版本信息
gx.ver {
  value: "2.0.0",
  export: "APP_VERSION"
}
</code></pre>
<h2 id="gxshell"><a class="header" href="#gxshell">gx.shell</a></h2>
<h3 id="功能描述-7"><a class="header" href="#功能描述-7">功能描述</a></h3>
<p>执行Shell脚本文件。</p>
<h3 id="语法定义-7"><a class="header" href="#语法定义-7">语法定义</a></h3>
<pre><code class="language-gxl">gx.shell {
  shell: &lt;脚本文件路径&gt;,  // 要执行的Shell脚本文件路径
  arg_file: &lt;参数文件&gt;,   // 参数文件路径（可选）
  out_var: &lt;输出变量名&gt;,  // 捕获脚本输出的变量名（可选）
  default: &lt;默认脚本&gt;     // 默认脚本文件路径（可选，与shell互斥）
}
</code></pre>
<h3 id="示例代码-9"><a class="header" href="#示例代码-9">示例代码</a></h3>
<pre><code class="language-gxl">// 执行Shell脚本
gx.shell {
  shell: "deploy.sh"
}

// 执行脚本并捕获输出
gx.shell {
  shell: "build.sh",
  out_var: "build_output"
}

// 使用参数文件
gx.shell {
  shell: "install.sh",
  arg_file: "install.args"
}
</code></pre>
<h2 id="gxdownload-和-gxupload"><a class="header" href="#gxdownload-和-gxupload">gx.download 和 gx.upload</a></h2>
<h3 id="功能描述-8"><a class="header" href="#功能描述-8">功能描述</a></h3>
<p>下载和上传文件。</p>
<h3 id="语法定义-8"><a class="header" href="#语法定义-8">语法定义</a></h3>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: &lt;下载URL&gt;,        // 文件下载URL
  local_file: &lt;本地路径&gt;, // 保存到本地的文件路径
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}

// 上传文件
gx.upload {
  url: &lt;上传URL&gt;,        // 文件上传URL
  local_file: &lt;本地路径&gt;, // 要上传的本地文件路径
  method: &lt;HTTP方法&gt;,     // HTTP方法（如POST、PUT等，默认POST）
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}
</code></pre>
<h3 id="示例代码-10"><a class="header" href="#示例代码-10">示例代码</a></h3>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: "https://example.com/file.zip",
  local_file: "downloaded_file.zip"
}

// 上传文件
gx.upload {
  url: "https://example.com/upload",
  local_file: "local_file.txt",
  method: "POST"
}
</code></pre>
<h2 id="gxtar-和-gxuntar"><a class="header" href="#gxtar-和-gxuntar">gx.tar 和 gx.untar</a></h2>
<h3 id="功能描述-9"><a class="header" href="#功能描述-9">功能描述</a></h3>
<p>创建和解压tar归档文件。</p>
<h3 id="语法定义-9"><a class="header" href="#语法定义-9">语法定义</a></h3>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: &lt;源文件/目录&gt;,     // 要归档的源文件或目录
  file: &lt;归档文件名&gt;      // 生成的归档文件名
}

// 解压tar归档
gx.untar {
  file: &lt;归档文件名&gt;,     // 要解压的归档文件
  dst: &lt;目标目录&gt;         // 解压到的目标目录
}
</code></pre>
<h3 id="示例代码-11"><a class="header" href="#示例代码-11">示例代码</a></h3>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: "src/",
  file: "source.tar"
}

// 解压tar归档
gx.untar {
  file: "source.tar",
  dst: "extracted/"
}
</code></pre>
<h2 id="gxartifact"><a class="header" href="#gxartifact">gx.artifact</a></h2>
<h3 id="功能描述-10"><a class="header" href="#功能描述-10">功能描述</a></h3>
<p>处理构建产物文件。</p>
<h3 id="语法定义-10"><a class="header" href="#语法定义-10">语法定义</a></h3>
<pre><code class="language-gxl">gx.artifact {
  file: &lt;文件路径&gt;,       // 构建产物文件路径
  dst_path: &lt;目标路径&gt;    // 目标存储路径
}
</code></pre>
<h3 id="示例代码-12"><a class="header" href="#示例代码-12">示例代码</a></h3>
<pre><code class="language-gxl">// 处理构建产物
gx.artifact {
  file: "target/release/myapp",
  dst_path: "artifacts/v1.0.0/"
}
</code></pre>
<h2 id="gxrun"><a class="header" href="#gxrun">gx.run</a></h2>
<h3 id="功能描述-11"><a class="header" href="#功能描述-11">功能描述</a></h3>
<p>运行其他GXL工作流文件。</p>
<h3 id="语法定义-11"><a class="header" href="#语法定义-11">语法定义</a></h3>
<pre><code class="language-gxl">gx.run {
  local: &lt;工作流路径&gt;,    // 要运行的工作流文件路径
  env: &lt;环境配置&gt;,        // 环境配置（可选）
  flow: &lt;流程列表&gt;,       // 要执行的流程列表（可选）
  conf: &lt;配置文件&gt;,       // 配置文件路径（可选）
  isolate: &lt;布尔值&gt;       // 是否隔离环境（可选）
}
</code></pre>
<h3 id="示例代码-13"><a class="header" href="#示例代码-13">示例代码</a></h3>
<pre><code class="language-gxl">// 运行其他工作流
gx.run {
  local: "./subflow.gxl"
}

// 在特定环境中运行工作流
gx.run {
  local: "./deploy.gxl",
  env: "production",
  flow: "build,deploy"
}

// 隔离环境运行
gx.run {
  local: "./test.gxl",
  isolate: true
}
</code></pre>
<h2 id="gxdefined"><a class="header" href="#gxdefined">gx.defined</a></h2>
<h3 id="功能描述-12"><a class="header" href="#功能描述-12">功能描述</a></h3>
<p>检查变量是否已定义。</p>
<h3 id="语法定义-12"><a class="header" href="#语法定义-12">语法定义</a></h3>
<pre><code class="language-gxl">gx.defined(${变量名})
</code></pre>
<h3 id="示例代码-14"><a class="header" href="#示例代码-14">示例代码</a></h3>
<pre><code class="language-gxl">// 检查变量是否已定义
if (gx.defined(${MY_VAR})) {
  gx.echo { value: "MY_VAR已定义，值为: ${MY_VAR}" }
} else {
  gx.echo { value: "MY_VAR未定义" }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxartifact-1"><a class="header" href="#gxartifact-1">gx.artifact</a></h1>
<h2 id="功能描述-13"><a class="header" href="#功能描述-13">功能描述</a></h2>
<p>处理构建产物文件。</p>
<h2 id="语法定义-13"><a class="header" href="#语法定义-13">语法定义</a></h2>
<pre><code class="language-gxl">gx.artifact {
  file: &lt;文件路径&gt;,       // 构建产物文件路径
  dst_path: &lt;目标路径&gt;    // 目标存储路径
}
</code></pre>
<h2 id="示例代码-15"><a class="header" href="#示例代码-15">示例代码</a></h2>
<pre><code class="language-gxl">// 处理构建产物
gx.artifact {
  file: "target/release/myapp",
  dst_path: "artifacts/v1.0.0/"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxassert-1"><a class="header" href="#gxassert-1">gx.assert</a></h1>
<h2 id="功能描述-14"><a class="header" href="#功能描述-14">功能描述</a></h2>
<p>执行断言检查，验证表达式的值是否符合预期。</p>
<h2 id="语法定义-14"><a class="header" href="#语法定义-14">语法定义</a></h2>
<pre><code class="language-gxl">gx.assert {
  value: &lt;表达式&gt;,      // 要检查的值
  expect: &lt;期望值&gt;,     // 期望的值
  err: &lt;错误信息&gt;,      // 断言失败时的错误信息（可选）
  result: &lt;变量名&gt;      // 存储断言结果的变量名（可选）
}
</code></pre>
<h2 id="示例代码-16"><a class="header" href="#示例代码-16">示例代码</a></h2>
<pre><code class="language-gxl">// 检查变量值是否等于期望值
gx.assert {
  value: ${MY_VAR},
  expect: "expected_value",
  err: "MY_VAR值不正确"
}

// 检查表达式结果并存储结果
gx.assert {
  value: ${CALC_RESULT},
  expect: 42,
  result: "assert_result"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxcmd-1"><a class="header" href="#gxcmd-1">gx.cmd</a></h1>
<h2 id="功能描述-15"><a class="header" href="#功能描述-15">功能描述</a></h2>
<p>执行系统命令或脚本。</p>
<h2 id="语法定义-15"><a class="header" href="#语法定义-15">语法定义</a></h2>
<pre><code class="language-gxl">gx.cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  shell: &lt;Shell类型&gt;,    // 指定使用的Shell（可选）
  out: &lt;输出变量名&gt;,     // 捕获命令标准输出的变量名（可选）
  err: &lt;错误变量名&gt;,     // 捕获命令错误输出的变量名（可选）
  suc: &lt;成功标识&gt;,       // 命令执行成功的标识（可选）
  sudo: &lt;布尔值&gt;,        // 是否使用sudo权限执行（可选）
  log: &lt;日志级别&gt;,       // 日志记录级别（可选）
  silence: &lt;布尔值&gt;      // 是否静默执行（可选）
}
</code></pre>
<h2 id="示例代码-17"><a class="header" href="#示例代码-17">示例代码</a></h2>
<pre><code class="language-gxl">// 执行简单命令
gx.cmd {
  cmd: "ls -la"
}

// 执行命令并捕获输出
gx.cmd {
  cmd: "date",
  out: "current_date"
}

// 使用sudo权限执行命令
gx.cmd {
  cmd: "systemctl restart nginx",
  sudo: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxdefined-1"><a class="header" href="#gxdefined-1">gx.defined</a></h1>
<h2 id="功能描述-16"><a class="header" href="#功能描述-16">功能描述</a></h2>
<p>检查变量是否已定义。</p>
<h2 id="语法定义-16"><a class="header" href="#语法定义-16">语法定义</a></h2>
<pre><code class="language-gxl">gx.defined(${变量名})
</code></pre>
<h2 id="示例代码-18"><a class="header" href="#示例代码-18">示例代码</a></h2>
<pre><code class="language-gxl">// 检查变量是否已定义
if (gx.defined(${MY_VAR})) {
  gx.echo { value: "MY_VAR已定义，值为: ${MY_VAR}" }
} else {
  gx.echo { value: "MY_VAR未定义" }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxdownload-和-gxupload-1"><a class="header" href="#gxdownload-和-gxupload-1">gx.download 和 gx.upload</a></h1>
<h2 id="功能描述-17"><a class="header" href="#功能描述-17">功能描述</a></h2>
<p>下载和上传文件。</p>
<h2 id="语法定义-17"><a class="header" href="#语法定义-17">语法定义</a></h2>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: &lt;下载URL&gt;,        // 文件下载URL
  local_file: &lt;本地路径&gt;, // 保存到本地的文件路径
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}

// 上传文件
gx.upload {
  url: &lt;上传URL&gt;,        // 文件上传URL
  local_file: &lt;本地路径&gt;, // 要上传的本地文件路径
  method: &lt;HTTP方法&gt;,     // HTTP方法（如POST、PUT等，默认POST）
  username: &lt;用户名&gt;,     // 认证用户名（可选）
  password: &lt;密码&gt;        // 认证密码（可选）
}
</code></pre>
<h2 id="示例代码-19"><a class="header" href="#示例代码-19">示例代码</a></h2>
<pre><code class="language-gxl">// 下载文件
gx.download {
  url: "https://example.com/file.zip",
  local_file: "downloaded_file.zip"
}

// 上传文件
gx.upload {
  url: "https://example.com/upload",
  local_file: "local_file.txt",
  method: "POST"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxecho-1"><a class="header" href="#gxecho-1">gx.echo</a></h1>
<h2 id="功能描述-18"><a class="header" href="#功能描述-18">功能描述</a></h2>
<p>输出文本信息到控制台。</p>
<h2 id="语法定义-18"><a class="header" href="#语法定义-18">语法定义</a></h2>
<pre><code class="language-gxl">gx.echo {
  value: &lt;文本内容&gt;,     // 要输出的文本内容
  file: &lt;文件路径&gt;,      // 输出到文件的路径（可选）
  export: &lt;变量名&gt;,      // 导出为环境变量的名称（可选）
  inc: &lt;布尔值&gt;          // 是否追加到文件末尾（可选）
}
</code></pre>
<h2 id="示例代码-20"><a class="header" href="#示例代码-20">示例代码</a></h2>
<pre><code class="language-gxl">// 输出简单文本
gx.echo {
  value: "Hello, Galaxy Flow!"
}

// 输出到文件
gx.echo {
  value: "This is a log entry",
  file: "app.log"
}

// 追加到文件
gx.echo {
  value: "Additional information",
  file: "app.log",
  inc: true
}

// 导出为环境变量
gx.echo {
  value: "production",
  export: "ENV_TYPE"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxread-1"><a class="header" href="#gxread-1">gx.read</a></h1>
<h2 id="功能描述-19"><a class="header" href="#功能描述-19">功能描述</a></h2>
<p>从不同来源读取数据并存储到变量中。</p>
<h2 id="语法定义-19"><a class="header" href="#语法定义-19">语法定义</a></h2>
<pre><code class="language-gxl">// 从文件读取
gx.read_file {
  file: &lt;文件路径&gt;,      // 要读取的文件路径
  name: &lt;变量名&gt;         // 存储文件内容的变量名
}

// 从标准输入读取
gx.read_stdin {
  name: &lt;变量名&gt;,        // 存储输入内容的变量名
  prompt: &lt;提示文本&gt;     // 输入提示文本（可选）
}

// 从命令输出读取
gx.read_cmd {
  cmd: &lt;命令字符串&gt;,     // 要执行的命令
  name: &lt;变量名&gt;,        // 存储命令输出的变量名
  shell: &lt;Shell类型&gt;     // 指定使用的Shell（可选）
}
</code></pre>
<h2 id="示例代码-21"><a class="header" href="#示例代码-21">示例代码</a></h2>
<pre><code class="language-gxl">// 从文件读取内容
gx.read_file {
  file: "config.json",
  name: "config_data"
}

// 从标准输入读取
gx.read_stdin {
  name: "user_input",
  prompt: "请输入您的姓名: "
}

// 从命令输出读取
gx.read_cmd {
  cmd: "git rev-parse HEAD",
  name: "commit_hash"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxrun-1"><a class="header" href="#gxrun-1">gx.run</a></h1>
<h2 id="功能描述-20"><a class="header" href="#功能描述-20">功能描述</a></h2>
<p>运行其他GXL工作流文件。</p>
<h2 id="语法定义-20"><a class="header" href="#语法定义-20">语法定义</a></h2>
<pre><code class="language-gxl">gx.run {
  local: &lt;工作流路径&gt;,    // 要运行的工作流文件路径
  env: &lt;环境配置&gt;,        // 环境配置（可选）
  flow: &lt;流程列表&gt;,       // 要执行的流程列表（可选）
  conf: &lt;配置文件&gt;,       // 配置文件路径（可选）
  isolate: &lt;布尔值&gt;       // 是否隔离环境（可选）
}
</code></pre>
<h2 id="示例代码-22"><a class="header" href="#示例代码-22">示例代码</a></h2>
<pre><code class="language-gxl">// 运行其他工作流
gx.run {
  local: "./subflow.gxl"
}

// 在特定环境中运行工作流
gx.run {
  local: "./deploy.gxl",
  env: "production",
  flow: "build,deploy"
}

// 隔离环境运行
gx.run {
  local: "./test.gxl",
  isolate: true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxshell-1"><a class="header" href="#gxshell-1">gx.shell</a></h1>
<h2 id="功能描述-21"><a class="header" href="#功能描述-21">功能描述</a></h2>
<p>执行Shell脚本文件。</p>
<h2 id="语法定义-21"><a class="header" href="#语法定义-21">语法定义</a></h2>
<pre><code class="language-gxl">gx.shell {
  shell: &lt;脚本文件路径&gt;,  // 要执行的Shell脚本文件路径
  arg_file: &lt;参数文件&gt;,   // 参数文件路径（可选）
  out_var: &lt;输出变量名&gt;,  // 捕获脚本输出的变量名（可选）
  default: &lt;默认脚本&gt;     // 默认脚本文件路径（可选，与shell互斥）
}
</code></pre>
<h2 id="示例代码-23"><a class="header" href="#示例代码-23">示例代码</a></h2>
<pre><code class="language-gxl">// 执行Shell脚本
gx.shell {
  shell: "deploy.sh"
}

// 执行脚本并捕获输出
gx.shell {
  shell: "build.sh",
  out_var: "build_output"
}

// 使用参数文件
gx.shell {
  shell: "install.sh",
  arg_file: "install.args"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxtar-和-gxuntar-1"><a class="header" href="#gxtar-和-gxuntar-1">gx.tar 和 gx.untar</a></h1>
<h2 id="功能描述-22"><a class="header" href="#功能描述-22">功能描述</a></h2>
<p>创建和解压tar归档文件。</p>
<h2 id="语法定义-22"><a class="header" href="#语法定义-22">语法定义</a></h2>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: &lt;源文件/目录&gt;,     // 要归档的源文件或目录
  file: &lt;归档文件名&gt;      // 生成的归档文件名
}

// 解压tar归档
gx.untar {
  file: &lt;归档文件名&gt;,     // 要解压的归档文件
  dst: &lt;目标目录&gt;         // 解压到的目标目录
}
</code></pre>
<h2 id="示例代码-24"><a class="header" href="#示例代码-24">示例代码</a></h2>
<pre><code class="language-gxl">// 创建tar归档
gx.tar {
  src: "src/",
  file: "source.tar"
}

// 解压tar归档
gx.untar {
  file: "source.tar",
  dst: "extracted/"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxtpl-1"><a class="header" href="#gxtpl-1">gx.tpl</a></h1>
<h2 id="功能描述-23"><a class="header" href="#功能描述-23">功能描述</a></h2>
<p>使用模板引擎处理文件模板。</p>
<h2 id="语法定义-23"><a class="header" href="#语法定义-23">语法定义</a></h2>
<pre><code class="language-gxl">gx.tpl {
  tpl: &lt;模板内容&gt;,       // 模板内容
  dst: &lt;目标文件路径&gt;,   // 生成文件的路径
  data: &lt;数据变量名&gt;,    // 模板数据变量名（可选）
  engine: &lt;引擎类型&gt;,    // 模板引擎类型（可选）
  file: &lt;模板文件路径&gt;   // 模板文件路径（可选，与tpl互斥）
}
</code></pre>
<h2 id="示例代码-25"><a class="header" href="#示例代码-25">示例代码</a></h2>
<pre><code class="language-gxl">// 使用内联模板
gx.tpl {
  tpl: "Hello, {{name}}! Welcome to {{app_name}}.",
  dst: "output.txt",
  data: "user_data"
}

// 使用模板文件
gx.tpl {
  file: "template.txt",
  dst: "output.txt",
  data: "template_data"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxvars-1"><a class="header" href="#gxvars-1">gx.vars</a></h1>
<h2 id="功能描述-24"><a class="header" href="#功能描述-24">功能描述</a></h2>
<p>定义和设置多个变量。</p>
<h2 id="语法定义-24"><a class="header" href="#语法定义-24">语法定义</a></h2>
<pre><code class="language-gxl">gx.vars {
  &lt;变量名1&gt;: &lt;值1&gt;,      // 变量名和对应的值
  &lt;变量名2&gt;: &lt;值2&gt;,      // 可以定义多个变量
  // ...
}
</code></pre>
<h2 id="示例代码-26"><a class="header" href="#示例代码-26">示例代码</a></h2>
<pre><code class="language-gxl">// 定义多个变量
gx.vars {
  app_name: "MyApp",
  version: "1.0.0",
  debug: true
}

// 使用变量引用
gx.vars {
  project_root: "${HOME}/projects",
  config_file: "${project_root}/config.yaml"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gxver-1"><a class="header" href="#gxver-1">gx.ver</a></h1>
<h2 id="功能描述-25"><a class="header" href="#功能描述-25">功能描述</a></h2>
<p>管理和操作版本信息。</p>
<h2 id="语法定义-25"><a class="header" href="#语法定义-25">语法定义</a></h2>
<pre><code class="language-gxl">gx.ver {
  value: &lt;版本值&gt;,       // 版本值
  default: &lt;默认值&gt;,     // 默认版本值（可选）
  file: &lt;文件路径&gt;,      // 版本文件路径（可选）
  export: &lt;变量名&gt;,      // 导出版本信息的变量名（可选）
  inc: &lt;递增类型&gt;        // 版本递增类型（可选，可选值：build/bugfix/feature/main）
}
</code></pre>
<h2 id="示例代码-27"><a class="header" href="#示例代码-27">示例代码</a></h2>
<pre><code class="language-gxl">// 设置版本值
gx.ver {
  value: "1.2.3"
}

// 从文件读取版本并递增
gx.ver {
  file: "VERSION",
  inc: "feature"
}

// 导出版本信息
gx.ver {
  value: "2.0.0",
  export: "APP_VERSION"
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./mermaid.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
